var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Home","text":"<p><code>quacc</code> (pronounced \"quack\" \ud83e\udd86) is a flexible platform for high-throughput computational materials science and quantum chemistry built for the exascale era, maintained by the Rosen Research Group at Princeton University.</p> <ul> <li> <p><code>quacc</code> makes it possible to easily run pre-made workflows that can be efficiently dispatched anywhere: locally, HPC, the cloud, or any combination thereof.</p> </li> <li> <p><code>quacc</code> leverages community resources. It is built around the Atomic Simulation Environment and much of the software infrastructure powering the Materials Project.</p> </li> <li> <p><code>quacc</code> gives you the freedom of choice. Through a single, unified interface to several supported workflow management solutions, <code>quacc</code> lets you use what best suits your unique computing needs.</p> </li> </ul> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project generally adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#121","title":"[1.2.1]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>The folders generated by quacc recipes now follows a hierarchical folder structure if the setting <code>AUTODISCOVER_DIR</code>   is set to <code>true.</code></li> </ul>"},{"location":"about/changelog.html#120","title":"[1.2.0]","text":""},{"location":"about/changelog.html#fixed","title":"Fixed","text":"<ul> <li>Jobflow is now fully supported!</li> </ul>"},{"location":"about/changelog.html#116","title":"[1.1.6]","text":""},{"location":"about/changelog.html#changed","title":"Changed","text":"<ul> <li>Some minor updates to the TochSim schemas and supported properties</li> </ul>"},{"location":"about/changelog.html#115","title":"[1.1.5]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>Improved TorchSim recipes and added tutorials</li> </ul>"},{"location":"about/changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>Fixed <code>copy_files</code> so it ignores Custodian error folders</li> </ul>"},{"location":"about/changelog.html#114","title":"[1.1.4]","text":""},{"location":"about/changelog.html#changed_1","title":"Changed","text":"<ul> <li>Disables the use of the VASP INCAR copilot for recipes that mimic databaset settings (e.g. MatPES, OMat) to ensure full consistency.</li> <li>Changed the default keyword arguments in <code>matpes_static_job</code> to <code>use_improvements=False</code> and <code>write_extra_files=False</code> instead of <code>True</code> for both to ensure full consistency with MatPES settings by default.</li> </ul>"},{"location":"about/changelog.html#113","title":"[1.1.3]","text":""},{"location":"about/changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>Fixed file I/O when Jobflow is used with <code>run_locally(create_folders=True)</code></li> </ul>"},{"location":"about/changelog.html#112","title":"[1.1.2]","text":""},{"location":"about/changelog.html#fixed_3","title":"Fixed","text":"<ul> <li>Wrapped adsorbate positions so it appears within the unit cell when using <code>make_adsorbate_structures</code></li> </ul>"},{"location":"about/changelog.html#111","title":"[1.1.1]","text":""},{"location":"about/changelog.html#added_2","title":"Added","text":"<ul> <li>Added logging to the <code>Vasp</code> calculator to report which pseudopotentials are used as well as the VASP command</li> </ul>"},{"location":"about/changelog.html#110","title":"[1.1.0]","text":""},{"location":"about/changelog.html#changed_2","title":"Changed","text":"<ul> <li>Using <code>.original</code> as the <code>potpaw_PBE</code> suffix for the original pseudopotential set provided by VASP</li> </ul>"},{"location":"about/changelog.html#109","title":"[1.0.9]","text":""},{"location":"about/changelog.html#changed_3","title":"Changed","text":"<ul> <li>Made ASE 3.27.0 the minimum allowed version</li> <li>Explicitly set <code>pp_version=\"64\"</code> for the default VASP presets as well as <code>pp_version=\"54\"</code> for the <code>QMOFSet</code> and the OMC/OMat recipes. When going from Atomate2 to ASE input sets, the <code>pp_version</code> is now set</li> </ul>"},{"location":"about/changelog.html#108","title":"[1.0.8]","text":""},{"location":"about/changelog.html#added_3","title":"Added","text":"<ul> <li>TorchSim recipes</li> </ul>"},{"location":"about/changelog.html#changed_4","title":"Changed","text":"<ul> <li>Minimum version of Custodian changes to 2025.12.14</li> </ul>"},{"location":"about/changelog.html#removed","title":"Removed","text":"<ul> <li>Dropped support for Covalent</li> </ul>"},{"location":"about/changelog.html#107","title":"[1.0.7]","text":""},{"location":"about/changelog.html#added_4","title":"Added","text":"<ul> <li>Added OMC static recipe</li> <li>Added OMat static recipe</li> </ul>"},{"location":"about/changelog.html#fixed_4","title":"Fixed","text":"<ul> <li>Various dependency updates</li> </ul>"},{"location":"about/changelog.html#106","title":"[1.0.6]","text":""},{"location":"about/changelog.html#changed_5","title":"Changed","text":"<ul> <li>Changed the default <code>SYMPREC</code> in the VASP <code>relax_job</code> to 1e-6 instead of 1e-8</li> </ul>"},{"location":"about/changelog.html#105","title":"[1.0.5]","text":""},{"location":"about/changelog.html#fixed_5","title":"Fixed","text":"<ul> <li>Fixed bug when trying to use Custodian to run a single-point VASP calculation on an Atoms object with constraints</li> <li>Fixed various type hints</li> </ul>"},{"location":"about/changelog.html#104","title":"[1.0.4]","text":""},{"location":"about/changelog.html#added_5","title":"Added","text":"<ul> <li>A MatPES-compatible job</li> </ul>"},{"location":"about/changelog.html#changed_6","title":"Changed","text":"<ul> <li>Set ALGO = Normal for DefaultSetHybrid instead of ALGO = All</li> <li>When ALGO = All in VASP, ISEARCH is set to 1 per the VASP manual.</li> </ul>"},{"location":"about/changelog.html#fixed_6","title":"Fixed","text":"<ul> <li>Fixed various type hints</li> </ul>"},{"location":"about/changelog.html#removed_1","title":"Removed","text":"<ul> <li>Removed the deprecated Rosen sets</li> </ul>"},{"location":"about/changelog.html#103","title":"[1.0.3]","text":""},{"location":"about/changelog.html#added_6","title":"Added","text":"<ul> <li>The \"old\" MP recipes are back, now under the <code>quacc.recipes.vasp.mp_legacy</code> module</li> </ul>"},{"location":"about/changelog.html#changed_7","title":"Changed","text":"<ul> <li>The \"new\" MP recipes are moved from <code>quacc.recipes.vasp.mp</code> to <code>quacc.recipes.vasp.mp24</code></li> <li>The MP recipes, both new and old, no longer copy CHGCARs between runs because this never did anything in the first place</li> </ul>"},{"location":"about/changelog.html#fixed_7","title":"Fixed","text":"<ul> <li>Fixed a bug that would lead to a crash when setting <code>Atoms=None</code> in the <code>MPtoASEConverter</code></li> </ul>"},{"location":"about/changelog.html#102","title":"[1.0.2]","text":""},{"location":"about/changelog.html#added_7","title":"Added","text":"<ul> <li>Added <code>DefaultSetMetaGGA</code> and <code>DefaultSetHybrid</code></li> </ul>"},{"location":"about/changelog.html#changed_8","title":"Changed","text":"<ul> <li>Renamed <code>DefaultSetPBE</code> to <code>DefaultSetGGA</code></li> </ul>"},{"location":"about/changelog.html#101","title":"[1.0.1]","text":""},{"location":"about/changelog.html#changed_9","title":"Changed","text":"<ul> <li>Increased the minimum version of Custodian to address some I/O issues</li> <li>Removed <code>maggma</code> as a core dependency since it is only for optional features</li> </ul>"},{"location":"about/changelog.html#100","title":"[1.0.0]","text":""},{"location":"about/changelog.html#added_8","title":"Added","text":"<ul> <li>A <code>GenericRunner</code> to run arbitrary commands</li> <li>D3(BJ) parameters for HSE06 in the <code>Vasp</code> calculator</li> </ul>"},{"location":"about/changelog.html#changed_10","title":"Changed","text":"<ul> <li>The default <code>BulkSet.yaml</code> will be removed and replaced with <code>DefaultSetPBE.yaml</code>. The two are extremely similar. Updates include: ALGO = Fast \u2192 ALGO = Normal, GGA_COMPAT = False, and changing the default Yb and Eu pseudopotentials from _2 to _3.</li> <li>The <code>SlabSet.yaml</code> will be removed and replaced with <code>SlabSetPBE.yaml</code> to ensure internal consistency with the base <code>DefaultSetPBE.yaml</code>.</li> <li>The <code>VASP_PRESET_MAG_DEFAULT</code> setting has been changed from a default of 1.0 to 0.5 to prevent accidental convergence to erroneous radical states, particularly in molecular systems.</li> <li>The Materials Project recipes were updated to match the newer MP24 settings</li> </ul>"},{"location":"about/changelog.html#0171","title":"[0.17.1]","text":""},{"location":"about/changelog.html#changed_11","title":"Changed","text":"<ul> <li>Makes ASE 3.26.0 the minimum supporte version</li> </ul>"},{"location":"about/changelog.html#0170","title":"[0.17.0]","text":""},{"location":"about/changelog.html#added_9","title":"Added","text":"<ul> <li>Added <code>RosenFastSetPBE.yaml</code>, <code>RosenFastSetR2SCAN.yaml</code>, and <code>setups_rosen.yaml</code></li> <li>The user will now be warned if they are likely to have Pulay stresses due to the use of <code>Li_sv</code> and <code>ENCUT</code> &lt; 650</li> </ul>"},{"location":"about/changelog.html#changed_12","title":"Changed","text":"<ul> <li>Renamed <code>magmoms_base.yaml</code> to <code>magmoms_high.yaml</code></li> <li>Merged the identical <code>setups_54.yaml</code> and <code>setups_64.yaml</code> files into a single <code>setups_recommended.yaml</code></li> <li>The RosenSets will now use <code>Eu_3</code> and <code>Yb_3</code> instead of <code>Eu_2</code> and <code>Yb_2</code></li> </ul>"},{"location":"about/changelog.html#0160","title":"[0.16.0]","text":""},{"location":"about/changelog.html#added_10","title":"Added","text":"<ul> <li>Added support for TensorNet</li> </ul>"},{"location":"about/changelog.html#changed_13","title":"Changed","text":"<ul> <li>Default MLP calculators have been updated across the board: M3GNET and CHGNet now default to the MatPES PBE models, CHGNet relies on matgl, and mace-mp-0 has been renamed mace-mp to get the default model.</li> </ul>"},{"location":"about/changelog.html#0155","title":"[0.15.5]","text":""},{"location":"about/changelog.html#changed_14","title":"Changed","text":"<ul> <li>Simplified FAIRChem MLP usage</li> </ul>"},{"location":"about/changelog.html#0154","title":"[0.15.4]","text":""},{"location":"about/changelog.html#changed_15","title":"Changed","text":"<ul> <li><code>RosenPBESet.yaml</code> now uses ALGO = \"All\" instead of \"Fast\"</li> </ul>"},{"location":"about/changelog.html#0153","title":"[0.15.3]","text":""},{"location":"about/changelog.html#added_11","title":"Added","text":"<ul> <li>Updated FAIRChem models to support UMA and redesigned FAIRChem repo</li> </ul>"},{"location":"about/changelog.html#0152","title":"[0.15.2]","text":""},{"location":"about/changelog.html#fixed_8","title":"Fixed","text":"<ul> <li>Allow for <code>kpts=None</code> with VASP auto-swaps</li> </ul>"},{"location":"about/changelog.html#0151","title":"[0.15.1]","text":""},{"location":"about/changelog.html#added_12","title":"Added","text":"<ul> <li>Added <code>RosenSetPBE.yaml</code> and <code>RosenSetR2CAN.yaml</code> for recommended VASP parameters that Rosen likes to use.</li> </ul>"},{"location":"about/changelog.html#changed_16","title":"Changed","text":"<ul> <li>No longer automatically sets <code>NPAR = 1</code> when <code>LELF = True</code> due to convergence issues that can arise.</li> </ul>"},{"location":"about/changelog.html#0150","title":"[0.15.0]","text":""},{"location":"about/changelog.html#fixed_9","title":"Fixed","text":"<ul> <li>Various dependency fixes</li> </ul>"},{"location":"about/changelog.html#0140","title":"[0.14.0]","text":""},{"location":"about/changelog.html#fixed_10","title":"Fixed","text":"<ul> <li>Force <code>relax_cell=False</code> for elastic calculations</li> </ul>"},{"location":"about/changelog.html#removed_2","title":"Removed","text":"<ul> <li>There is no more <code>quacc_results.json.gz</code> file written out to disk. This turned out to be way more trouble than it was worth, over-complicating recipes by requiring the use of schemas with knowledge of the current working directory at all times.</li> <li>There is no more <code>STORE</code> quacc setting. Storing in databases will require calling the <code>results_to_db</code> function or using a workflow engine (e.g. Jobflow, FireWorks, Prefect, Covalent).</li> </ul>"},{"location":"about/changelog.html#0130","title":"[0.13.0]","text":""},{"location":"about/changelog.html#added_13","title":"Added","text":"<ul> <li>New elastic workflows for MLIPs and EMT</li> </ul>"},{"location":"about/changelog.html#changed_17","title":"Changed","text":"<ul> <li>The existing elastic workflow has been completely overhauled so that it is more practical t ouse</li> <li>The results dictionary returned at the end of the run has been modified, such that the structure metadata is now put under the <code>structure_metadata</code> key rather than the root level of the dictionary. Should this breaking change prove undesirable by the community, it can be reverted.</li> </ul>"},{"location":"about/changelog.html#fixed_11","title":"Fixed","text":"<ul> <li>Fixed various type hints</li> </ul>"},{"location":"about/changelog.html#0123","title":"[0.12.3]","text":""},{"location":"about/changelog.html#added_14","title":"Added","text":"<ul> <li>Added support for <code>fairchem-core</code> calculators</li> </ul>"},{"location":"about/changelog.html#0122","title":"[0.12.2]","text":""},{"location":"about/changelog.html#added_15","title":"Added","text":"<ul> <li>Added a new keyword argument, <code>filter_kwargs</code>, to the <code>Runner.run_opt()</code> class to modify the ASE filter</li> </ul>"},{"location":"about/changelog.html#0121","title":"[0.12.1]","text":""},{"location":"about/changelog.html#changed_18","title":"Changed","text":"<ul> <li>Clarifies handling of ASE environment variables by defining them at import time rather than calculator instantiation time. Can help with debugging rare edge cases.</li> </ul>"},{"location":"about/changelog.html#01119","title":"[0.11.19]","text":""},{"location":"about/changelog.html#fixed_12","title":"Fixed","text":"<ul> <li>Fixed automatic setting of D4 parameters for r2SCAN</li> </ul>"},{"location":"about/changelog.html#01118","title":"[0.11.18]","text":""},{"location":"about/changelog.html#changed_19","title":"Changed","text":"<ul> <li>Decrease the verbosity of the bader and chargemol analyses when they don't run.</li> </ul>"},{"location":"about/changelog.html#01117","title":"[0.11.17]","text":""},{"location":"about/changelog.html#added_16","title":"Added","text":"<ul> <li>Added automatic r2SCAN D4 parameter settings for Vasp calculator</li> </ul>"},{"location":"about/changelog.html#01116","title":"[0.11.16]","text":""},{"location":"about/changelog.html#changed_20","title":"Changed","text":"<ul> <li>VASP: Automatic setting of <code>NCORE</code> to sqrt(# of cores) unless otherwise specified</li> </ul>"},{"location":"about/changelog.html#01115","title":"[0.11.15]","text":""},{"location":"about/changelog.html#fixed_13","title":"Fixed","text":"<ul> <li>Sets NPAR = 1 for LELF = True</li> </ul>"},{"location":"about/changelog.html#01114","title":"[0.11.14]","text":""},{"location":"about/changelog.html#fixed_14","title":"Fixed","text":"<ul> <li>Fixed incompatability with PyMongo</li> </ul>"},{"location":"about/changelog.html#01113","title":"[0.11.13]","text":""},{"location":"about/changelog.html#fixed_15","title":"Fixed","text":"<ul> <li>No changes. Fixed PyPI release</li> </ul>"},{"location":"about/changelog.html#01112","title":"[0.11.12]","text":""},{"location":"about/changelog.html#added_17","title":"Added","text":"<ul> <li>MRCC calculator and basic recipes</li> </ul>"},{"location":"about/changelog.html#01111","title":"[0.11.11]","text":""},{"location":"about/changelog.html#added_18","title":"Added","text":"<ul> <li>NEB runner</li> <li>NEB-based TS job for NewtonNet</li> </ul>"},{"location":"about/changelog.html#01110","title":"[0.11.10]","text":""},{"location":"about/changelog.html#fixed_16","title":"Fixed","text":"<ul> <li>Fixed compatability with Prefect 3.1.11</li> </ul>"},{"location":"about/changelog.html#0119","title":"[0.11.9]","text":""},{"location":"about/changelog.html#changed_21","title":"Changed","text":"<ul> <li>ASE&gt;=3.24.0 is required due to upstream breaking changes</li> </ul>"},{"location":"about/changelog.html#fixed_17","title":"Fixed","text":"<ul> <li>Fixed a bug where DFT+U parameters might not be set appropriately if the <code>Atoms</code> object is sorted when using MP input sets</li> </ul>"},{"location":"about/changelog.html#0118","title":"[0.11.8]","text":""},{"location":"about/changelog.html#added_19","title":"Added","text":"<ul> <li>Support for SevenNet and Orb models as MLPs</li> </ul>"},{"location":"about/changelog.html#0117","title":"[0.11.7]","text":""},{"location":"about/changelog.html#added_20","title":"Added","text":"<ul> <li>New phonopy routines to handle fixed atoms</li> </ul>"},{"location":"about/changelog.html#0116","title":"[0.11.6]","text":""},{"location":"about/changelog.html#fixed_18","title":"Fixed","text":"<ul> <li>Fixed handling of async prefect tasks</li> </ul>"},{"location":"about/changelog.html#0115","title":"[0.11.5]","text":""},{"location":"about/changelog.html#added_21","title":"Added","text":"<ul> <li>Added support for atomate2&gt;=0.0.15</li> </ul>"},{"location":"about/changelog.html#changed_22","title":"Changed","text":"<ul> <li>Overhauled handling of Prefect futures/states. Refer to the documentation for more details.</li> <li>The minimum supported Python version is now 3.10 in alignment with Pymatgen</li> </ul>"},{"location":"about/changelog.html#0114","title":"[0.11.4]","text":""},{"location":"about/changelog.html#changed_23","title":"Changed","text":"<ul> <li>Put a <code>&lt;=</code> version pin on Atomate2 to resolve upstream breaking change</li> </ul>"},{"location":"about/changelog.html#0113","title":"[0.11.3]","text":""},{"location":"about/changelog.html#added_22","title":"Added","text":"<ul> <li>Added support for <code>preset: Path</code> type in the <code>Espresso</code> calculator</li> <li>Raise a custom <code>JobFailure</code> error when a calculation fails, which stores the directory where the files remain as well as the parent error</li> </ul>"},{"location":"about/changelog.html#fixed_19","title":"Fixed","text":"<ul> <li>Fixed Parsl MPI support for Espresso recipes</li> <li>Fixed miscellaneous inconsistencies with <code>preset</code> handling</li> </ul>"},{"location":"about/changelog.html#0112","title":"[0.11.2]","text":""},{"location":"about/changelog.html#added_23","title":"Added","text":"<ul> <li>Added support for <code>preset: Path</code> type in the <code>Vasp</code> calculator</li> </ul>"},{"location":"about/changelog.html#0111","title":"[0.11.1]","text":""},{"location":"about/changelog.html#added_24","title":"Added","text":"<ul> <li>Added an <code>additional_fields</code> keyword argument to all recipes</li> </ul>"},{"location":"about/changelog.html#changed_24","title":"Changed","text":"<ul> <li>Gaussian and ORCA schemas have been updated to reflect the removal of cclib</li> </ul>"},{"location":"about/changelog.html#fixed_20","title":"Fixed","text":"<ul> <li>Fixed support for Prefect 3</li> <li>Fixed support for ORCA 6.0.0</li> </ul>"},{"location":"about/changelog.html#removed_3","title":"Removed","text":"<ul> <li>Removed cclib-based schemas due to fragility and replaced them with the standard ASE schemas</li> </ul>"},{"location":"about/changelog.html#0110","title":"[0.11.0]","text":""},{"location":"about/changelog.html#added_25","title":"Added","text":"<ul> <li>Added support for HarmonicThermo as a thermochemistry method</li> <li>Added a VASP frequency recipe</li> </ul>"},{"location":"about/changelog.html#changed_25","title":"Changed","text":"<ul> <li>Overhauled schemas throughout quacc to improve maintainability. They are now classes (mostly) instead of functions.</li> <li>Changed the thermo runner to a schema</li> <li>Renamed the Q-Chem perturb IRC job to <code>quasi_irc_job</code> for internal consistency</li> <li>Removed the preliminary relaxation steps from all phonon workflows for greater composability</li> </ul>"},{"location":"about/changelog.html#fixed_21","title":"Fixed","text":"<ul> <li>Fixed a crash when Espresso checked kpts and kspacing usage</li> </ul>"},{"location":"about/changelog.html#removed_4","title":"Removed","text":"<ul> <li>Removed the Q-Chem quasi-IRC job since it was redundant with the perturb IRC job</li> </ul>"},{"location":"about/changelog.html#0101","title":"[0.10.1]","text":""},{"location":"about/changelog.html#changed_26","title":"Changed","text":"<ul> <li>Overhauled type hinting system</li> <li>Added kspacing default to Espresso non_scf_job</li> </ul>"},{"location":"about/changelog.html#fixed_22","title":"Fixed","text":"<ul> <li>Fixed breaking change from monty 07.12.2024</li> <li>Fixed a variety of incompatible type hints</li> </ul>"},{"location":"about/changelog.html#0100","title":"[0.10.0]","text":""},{"location":"about/changelog.html#added_26","title":"Added","text":"<ul> <li>Added a function <code>from quacc import get_settings</code> to fetch the current settings on a thread</li> <li>Added a mechanism to update the settings on-the-fly via a special <code>settings_swap</code> keyword argument that can be passed to the decorators when a workflow engine is used.</li> <li>Support for MD workflows</li> </ul>"},{"location":"about/changelog.html#fixed_23","title":"Fixed","text":"<ul> <li>Fixed an edge-case that can occur in multithreading environments where in-memory changes to the <code>QuaccSettings</code> could carry over to a concurrent thread</li> <li>Made the detection of intermediate step directories more robust</li> </ul>"},{"location":"about/changelog.html#removed_5","title":"Removed","text":"<ul> <li>The global <code>SETTINGS</code> variable is gone! Modifying a global variable can cause havoc in multithreaded environments and was never compatible with workflow engines. Refer to the Modifying Settings page for the recommended approach. For most users without an active workflow engine, this will be the <code>with change_settings()</code> context manager.</li> </ul>"},{"location":"about/changelog.html#095","title":"[0.9.5]","text":""},{"location":"about/changelog.html#changed_27","title":"Changed","text":"<ul> <li>Pinned numpy version to &lt; 2.0 (for now...)</li> </ul>"},{"location":"about/changelog.html#094","title":"[0.9.4]","text":""},{"location":"about/changelog.html#added_27","title":"Added","text":"<ul> <li>VASP: Added a new logging statement to specifically highlight which parameters were swapped, not just which recommendations were made</li> </ul>"},{"location":"about/changelog.html#changed_28","title":"Changed","text":"<ul> <li>VASP: Removed EFERMI=\"midgap\" co-pilot swap since it does not influence the results and prevents VASP 5.x compatability</li> </ul>"},{"location":"about/changelog.html#fixed_24","title":"Fixed","text":"<ul> <li>Fixed MD5-based <code>Atoms</code> hashing to work on FIPS-encrypted OSs</li> </ul>"},{"location":"about/changelog.html#093","title":"[0.9.3]","text":""},{"location":"about/changelog.html#changed_29","title":"Changed","text":"<ul> <li>Update the default <code>shear_strain</code> value in <code>quacc.atoms.defects.make_deformations_from_bulk</code> to match that of Pymatgen</li> <li>Internal refactoring of the runners to be class-based</li> </ul>"},{"location":"about/changelog.html#fixed_25","title":"Fixed","text":"<ul> <li>Fixed an issue where the <code>Atoms</code> object in the output schema could get a stray calculator attached to it when passed between <code>@job</code>s</li> </ul>"},{"location":"about/changelog.html#092","title":"[0.9.2]","text":""},{"location":"about/changelog.html#added_28","title":"Added","text":"<ul> <li>Added support for controlling which properties to calculate with MLP static jobs</li> </ul>"},{"location":"about/changelog.html#changed_30","title":"Changed","text":"<ul> <li>Bumped minimum version of pymatgen</li> </ul>"},{"location":"about/changelog.html#091","title":"[0.9.1]","text":""},{"location":"about/changelog.html#changed_31","title":"Changed","text":"<ul> <li>No longer need to install <code>master</code> branch of ASE</li> <li>Modified Espresso and ONETEP settings to support new ASE profile features</li> <li>Removed <code>nsteps</code> from the <code>OptSchema</code></li> </ul>"},{"location":"about/changelog.html#090","title":"[0.9.0]","text":""},{"location":"about/changelog.html#added_29","title":"Added","text":"<ul> <li>The <code>RESULTS_DIR</code> and <code>SCRATCH_DIR</code> settings can now be relative paths, if desired</li> </ul>"},{"location":"about/changelog.html#changed_32","title":"Changed","text":"<ul> <li>Failed calculations are now stored in a <code>failed-quacc-12345-</code> directory to distinguish these tasks from the running tasks in <code>tmp-quacc-12345-</code></li> <li>The output schema is now written to a serialized JSON file instead of pickle for security and ease-of-use reasons. It can be rehydrated via <code>loadfn(\"quacc_results.json.gz\")</code> where <code>loadfn</code> is from <code>monty.serialization import loadfn</code></li> <li>The <code>fmax</code> attribute was moved from the base level to the <code>parameters_opt</code> section since it is an input parameter</li> </ul>"},{"location":"about/changelog.html#fixed_26","title":"Fixed","text":"<ul> <li>File shuttling after a completed calculation is now faster since we simply rename the directory instead of moving each individual file</li> </ul>"},{"location":"about/changelog.html#080","title":"[0.8.0]","text":""},{"location":"about/changelog.html#added_30","title":"Added","text":"<ul> <li>Added a context handler, <code>quacc.settings.change_settings</code>, that can be used to modify global settings temporarily</li> <li>Added <code>quacc.calculators.vasp.params.MPtoASEConverter</code> to convert between Pymatgen- and Atomate2-style input parameters to ASE-compatabile parameters</li> </ul>"},{"location":"about/changelog.html#fixed_27","title":"Fixed","text":"<ul> <li>Fixed copying of WAVECAR between steps of the QMOF recipes</li> </ul>"},{"location":"about/changelog.html#changed_33","title":"Changed","text":"<ul> <li>Overhauled the MP recipes to ensure better compatability with atomate2 workflows</li> <li>The workflow engine must be directly specified with <code>WORKFLOW_ENGINE</code>, as noted in the docs</li> <li>Changed <code>VASP_MAG_CUTOFF</code> from 0.05 to 0.02</li> <li>Removed the <code>preset</code> keyword argument from the QMOF recipes</li> </ul>"},{"location":"about/changelog.html#removed_6","title":"Removed","text":"<ul> <li>Removed the <code>pmg_input_set</code> keyword argument from the <code>Vasp</code> calculator</li> </ul>"},{"location":"about/changelog.html#078","title":"[0.7.8]","text":""},{"location":"about/changelog.html#added_31","title":"Added","text":"<ul> <li>Added support for Parsl \"special\" keyword arguments (e.g. <code>timeout</code>, <code>parsl_resource_specification</code>)</li> </ul>"},{"location":"about/changelog.html#fixed_28","title":"Fixed","text":"<ul> <li>Fixed bug where the common phonon subflow would generate a <code>Phonopy</code> object based on the unrelaxed, rather than relaxed, structure</li> <li>Sped up the common phonon subflow by removing duplicate <code>get_phonopy()</code> calls</li> </ul>"},{"location":"about/changelog.html#077","title":"[0.7.7]","text":""},{"location":"about/changelog.html#added_32","title":"Added","text":"<ul> <li>Added quasi IRC recipes to ORCA and Q-Chem</li> <li>Added frequency recipe to ORCA</li> </ul>"},{"location":"about/changelog.html#fixed_29","title":"Fixed","text":"<ul> <li>Fixed various type hints</li> <li>Improved performance for the common phonon flow</li> <li>Improved performance for ideal gas thermo calculations</li> </ul>"},{"location":"about/changelog.html#076","title":"[0.7.6]","text":""},{"location":"about/changelog.html#fixed_30","title":"Fixed","text":"<ul> <li>Fixed file extension for the optimizer trajectories, which should have been <code>.json</code> instead of <code>.pckl</code></li> </ul>"},{"location":"about/changelog.html#075","title":"[0.7.5]","text":""},{"location":"about/changelog.html#changed_34","title":"Changed","text":"<ul> <li>Removed the <code>atoms_info</code> field from the <code>AtomsSchema</code> since this is already available in the database via Pymatgen's <code>MSONAtoms</code> serialization</li> </ul>"},{"location":"about/changelog.html#074","title":"[0.7.4]","text":""},{"location":"about/changelog.html#changed_35","title":"Changed","text":"<ul> <li>Only call <code>jsanitize</code> once before uploading to the <code>Store</code></li> </ul>"},{"location":"about/changelog.html#073","title":"[0.7.3]","text":""},{"location":"about/changelog.html#added_33","title":"Added","text":"<ul> <li>Added new Espresso recipes to perform electron-phonon calculations and Fourier interpolation of the phonon potential</li> </ul>"},{"location":"about/changelog.html#fixed_31","title":"Fixed","text":"<ul> <li>Fixed potential issues with I/O settings and Espresso</li> <li>Fixed passing of custom decorators in the Espresso <code>grid_phonon_flow</code></li> </ul>"},{"location":"about/changelog.html#072","title":"[0.7.2]","text":""},{"location":"about/changelog.html#changed_36","title":"Changed","text":"<ul> <li>Calculator executable commands are now <code>str</code> type instead of <code>Path</code></li> <li>Removed <code>slowconv</code> from the default parameters of the ORCA recipes</li> <li>The Q-Chem calculator now uses the TaskDoc from emmet in its <code>results</code> attribute</li> </ul>"},{"location":"about/changelog.html#fixed_32","title":"Fixed","text":"<ul> <li>Fixed user setting of LOGGER level</li> <li>Fixed a glob-based issue with <code>copy_decompress_files</code></li> </ul>"},{"location":"about/changelog.html#071","title":"[0.7.1]","text":""},{"location":"about/changelog.html#added_34","title":"Added","text":"<ul> <li>Added an optional MP compatability checker for MP recipes</li> <li>Summaries for intermediate ASE optimization steps are now stored in the output schema for VASP and cclib-based recipes when <code>store_intermediate_results=True</code></li> <li>Added a <code>WRITE_PICKLE</code> setting, which by default, will write out a <code>.pkl</code> file containing the result schema to the directory</li> </ul>"},{"location":"about/changelog.html#changed_37","title":"Changed","text":"<ul> <li>Updated <code>ruff</code> settings</li> <li>The Gaussian and ORCA <code>static_job</code> routines do a force calculation by default now</li> </ul>"},{"location":"about/changelog.html#fixed_33","title":"Fixed","text":"<ul> <li>Fixed input file formatting for <code>orcablocks</code> in ORCA recipes</li> </ul>"},{"location":"about/changelog.html#removed_7","title":"Removed","text":"<ul> <li>Removed the <code>CHDIR</code> setting</li> </ul>"},{"location":"about/changelog.html#070","title":"[0.7.0]","text":""},{"location":"about/changelog.html#added_35","title":"Added","text":"<ul> <li>Added a <code>non_scf_job</code> for VASP</li> </ul>"},{"location":"about/changelog.html#changed_38","title":"Changed","text":"<ul> <li>There are no more <code>os.chdir</code> calls to ensure thread safety</li> <li>Use <code>pymatgen.io.ase.MSONAtoms</code> to make MSONable <code>Atoms</code></li> <li>Changed default NEDOS value from 5001 to 3001 for VASP static jobs (10x the default)</li> </ul>"},{"location":"about/changelog.html#fixed_34","title":"Fixed","text":"<ul> <li>Fixed multithreaded <code>@task</code> distribution with VASP and Q-Chem</li> <li>Fixed a bug where, with Prefect, the <code>State</code> would raise an indexing error when passing around deferred <code>dict</code> entries</li> <li>Fixed a bug when <code>job_parameters</code> and <code>job_decorators</code> are both passed to <code>customize_funcs()</code></li> <li>Raise a <code>ValueError</code> when the user provides <code>SCRATCH_DIR</code> or <code>RESULTS_DIR</code> as a relative path</li> </ul>"},{"location":"about/changelog.html#0610","title":"[0.6.10]","text":""},{"location":"about/changelog.html#fixed_35","title":"Fixed","text":"<ul> <li>Fixed pickle-ability of the schemas</li> <li>Fixed multithreaded <code>@task</code> distribution with GULP, Espresso, and common phonon flow recipes</li> <li>Fixed concurrency issues with VASP/Q-Chem due to refactoring</li> </ul>"},{"location":"about/changelog.html#removed_8","title":"Removed","text":"<ul> <li>Removed the <code>quacc.schemas.atoms._quacc_sanitize</code> function</li> </ul>"},{"location":"about/changelog.html#069","title":"[0.6.9]","text":""},{"location":"about/changelog.html#added_36","title":"Added","text":"<ul> <li>Added MP compatability corrections in VASP MP recipes</li> <li>Added various phonon recipes for Espresso</li> <li>Added various DOS recipes for Espresso</li> </ul>"},{"location":"about/changelog.html#fixed_36","title":"Fixed","text":"<ul> <li>Fixed a rare edge case where final magmoms would not be moved to initial magmoms of next run in MP VASP recipes</li> </ul>"},{"location":"about/changelog.html#068","title":"[0.6.8]","text":""},{"location":"about/changelog.html#added_37","title":"Added","text":"<ul> <li>Added an option to prevent <code>os.chdir</code> calls for multithread safety</li> <li>Added a common elastic calculation</li> </ul>"},{"location":"about/changelog.html#changed_39","title":"Changed","text":"<ul> <li>Switched to <code>ruff</code> for formatting, replacing the need for <code>black</code> and <code>isort</code></li> <li>Changed VASP double relaxes to be flows and not jobs</li> <li>Changed the behavior of <code>quacc.utils.files.copy_decompress_files</code></li> </ul>"},{"location":"about/changelog.html#fixed_37","title":"Fixed","text":"<ul> <li>Fixed <code>copy_files</code> handling with workflow engines</li> <li>Fixed MP VASP double relaxes, where the same relaxation was done twice by mistake</li> <li>Fixed use of <code>**calc_kwargs</code> in MP flow recipes</li> </ul>"},{"location":"about/changelog.html#067","title":"[0.6.7]","text":""},{"location":"about/changelog.html#added_38","title":"Added","text":"<ul> <li>Added a <code>store_intermediate_results</code> keyword option to <code>quacc.runners.ase.run_opt()</code> to allow for storing of the logfiles in intermediate geometry optimization steps.</li> <li>Added support for Pymatgen-based input sets in VASP jobs</li> <li>Added an MP meta-GGA VASP static job</li> <li>Added MP GGA relax job, MP GGA static job, and MP GGA relax flow</li> <li>Added a validity checker on CLI parameters</li> </ul>"},{"location":"about/changelog.html#changed_40","title":"Changed","text":"<ul> <li>Changed the default ASE optimizer from <code>FIRE</code> to <code>BFGS</code> for most recipes</li> <li>Changed the VASP <code>DoubleRelaxSchema</code> to be consistent between flows</li> <li>Refactored VASP and Q-Chem execution commands in custom calculators</li> </ul>"},{"location":"about/changelog.html#fixed_38","title":"Fixed","text":"<ul> <li>Fixed <code>dir_name</code> in VASP output schema</li> <li>Fixed auto-detection of the Prefect workflow engine in settings</li> <li>Fixed compatability of MP meta-GGA workflow with that in atomate2</li> </ul>"},{"location":"about/changelog.html#066","title":"[0.6.6]","text":""},{"location":"about/changelog.html#fixed_39","title":"Fixed","text":"<ul> <li>Using environment variables to set a setting to <code>None</code> now works as expected</li> <li>Overall, more intuitive and robust handling of settings across the various input methods</li> </ul>"},{"location":"about/changelog.html#065","title":"[0.6.5]","text":""},{"location":"about/changelog.html#added_39","title":"Added","text":"<ul> <li>PDOS jobs and flows for Espresso</li> </ul>"},{"location":"about/changelog.html#changed_41","title":"Changed","text":"<ul> <li>Modified the Espresso results schema to be DB-compatible</li> <li>The <code>PRIMARY_STORE</code> setting has changed to <code>STORE</code> and is now formatted more intuitively</li> <li>Uses 2024 stable release of <code>black</code></li> </ul>"},{"location":"about/changelog.html#fixed_40","title":"Fixed","text":"<ul> <li>Fixed usage of <code>MontyStore</code> as the data store option</li> </ul>"},{"location":"about/changelog.html#removed_9","title":"Removed","text":"<ul> <li>Removed the deprecated \"q-chem legacy\" recipes</li> </ul>"},{"location":"about/changelog.html#064","title":"[0.6.4]","text":""},{"location":"about/changelog.html#added_40","title":"Added","text":"<ul> <li>Added a <code>supercell_matrix</code> keyword argument to the phonon recipes.</li> <li>More data is now generated, parsed, and stored in phonon workflows, including total DOS and the automatically generated band structure</li> </ul>"},{"location":"about/changelog.html#changed_42","title":"Changed","text":"<ul> <li>The <code>seekpath</code> dependency is now required for phonon workflows, as reflected in the <code>quacc[phonons]</code> optional dependencies</li> <li>Changed the <code>min_length: float | None</code> keyword argument in phonon flows to <code>min_lengths: float | tuple[float, float, float] | None</code> for greater flexibility. The default value is now set to 20.0 instead of 15.0 as well.</li> </ul>"},{"location":"about/changelog.html#fixed_41","title":"Fixed","text":"<ul> <li>Fixed occasional edge cases where the charge/spin multiplicity checker would raise a <code>ValueError</code> in generating the <code>RunSchema</code></li> <li>Fixed phonon flow with MACE-MP-0 when <code>dispersion=True</code></li> </ul>"},{"location":"about/changelog.html#063","title":"[0.6.3]","text":""},{"location":"about/changelog.html#added_41","title":"Added","text":"<ul> <li>Added phonon job for MLPs</li> <li>Added an ASE relax job recipe for ONETEP</li> <li>Added a non-SCF job for Quantum Espresso</li> <li>Added a DOS job for Quantum Espresso</li> <li>Added a DOS flow for Quantum Espresso</li> </ul>"},{"location":"about/changelog.html#changed_43","title":"Changed","text":"<ul> <li>Redesigned the <code>common_phonon_flow</code> to accept new keyword arguments that enable symmetry reduction. A pre-relaxation step is now also carried out by default.</li> </ul>"},{"location":"about/changelog.html#fixed_42","title":"Fixed","text":"<ul> <li>Ensures the \"restart\" keyword argument is not set when a SciPy optimizer is used</li> <li>Fixed the <code>ONETEP_CMD</code> setting to be <code>str</code> instead of <code>Path</code> when used to instantiate the calculator</li> <li>Quantum Espresso restarts are now disabled between steps in ASE relaxations</li> <li>Various bug fixes for the Espresso <code>grid_phonon_flow</code></li> <li>Fixed redundant <code>Structure</code> info in the <code>RunSchema</code></li> </ul>"},{"location":"about/changelog.html#062","title":"[0.6.2]","text":""},{"location":"about/changelog.html#changed_44","title":"Changed","text":"<ul> <li>The <code>CREATE_UNIQUE_DIR</code> setting is now set to <code>True</code> by default.</li> <li>The temporary directory name and its symlink have been slightly updated to have \"tmp-\" and \"symlink-\" at the front of the name instead of the end for easier file navigation.</li> <li>Updated the \"trajectory\" entry in the <code>OptSchema</code> to be <code>list[Atoms]</code> instead of <code>list[AtomsSchema]</code></li> </ul>"},{"location":"about/changelog.html#fixed_43","title":"Fixed","text":"<ul> <li>Fixed an occasional race condition that occurs when running concurrent calculations in multi-threaded mode</li> <li>The temporary directory made when a <code>@job</code> runs now has a name consistent with the folder where the results will ultimately be stored.</li> <li>Significant speedup in generating the <code>OptSchema</code></li> </ul>"},{"location":"about/changelog.html#061","title":"[0.6.1]","text":""},{"location":"about/changelog.html#added_42","title":"Added","text":"<ul> <li>Support for ONETEP recipes (@nekkrad)</li> <li>New Espresso recipe for ASE external relaxations (@tomdemeyere)</li> </ul>"},{"location":"about/changelog.html#fixed_44","title":"Fixed","text":"<ul> <li>Fixed bug where autoamtic k-point schemes in VASP would return <code>kpts</code> as <code>list[float]</code> instead of <code>list[int]</code></li> <li>VASP runs now respect the <code>CHECK_CONVERGENCE</code> global setting when set to <code>False</code></li> <li>Fixed bug where the gamma-point only version of VASP was being called if <code>kpts</code> was <code>None</code> but <code>kspacing</code> was not <code>None</code></li> </ul>"},{"location":"about/changelog.html#removed_10","title":"Removed","text":"<ul> <li>Removed the broken TRICs support with Sella</li> <li>Removed the <code>covalent_to_db</code> function</li> </ul>"},{"location":"about/changelog.html#060","title":"[0.6.0]","text":""},{"location":"about/changelog.html#added_43","title":"Added","text":"<ul> <li>A new <code>grid_phonon</code> recipe in Espresso (@tomdemeyere)</li> <li>Preliminary support for the Prefect workflow engine, again, but this time without it breaking everything</li> </ul>"},{"location":"about/changelog.html#changed_45","title":"Changed","text":"<ul> <li>Raised the default LOGGER level from <code>WARNING</code> to <code>INFO</code></li> </ul>"},{"location":"about/changelog.html#fixed_45","title":"Fixed","text":"<ul> <li>Codes calling Custodian can be used in Jupyter Notebooks</li> <li>Fixed an error in the Espresso <code>phonon_flow</code> when using the <code>master</code> branch of ASE</li> <li>Fixed a few erroneous type hints</li> <li>Fixed the <code>typer</code> depenendecy in <code>pyproject.toml</code> to be <code>typer[all]</code> like it was supposed to be</li> <li>Fixed a bug when passing decorator keyword arguments when using Dask</li> </ul>"},{"location":"about/changelog.html#052","title":"[0.5.2]","text":""},{"location":"about/changelog.html#changed_46","title":"Changed","text":"<ul> <li>ORCA and GULP recipes now use a more intuitive and concise <code>list[str]</code> input argument format instead of a <code>dict</code> format when overriding defaults</li> </ul>"},{"location":"about/changelog.html#fixed_46","title":"Fixed","text":"<ul> <li>Fixed concurrency issues with Dask subflows</li> </ul>"},{"location":"about/changelog.html#051","title":"[0.5.1]","text":""},{"location":"about/changelog.html#added_44","title":"Added","text":"<ul> <li>Adds a new <code>ase_relax_job</code> for ORCA</li> <li>Adds a new <code>relax_job</code> and <code>post_processing_job</code> for Quantum Espresso</li> <li><code>quacc.wflow_tools.customizers.strip_decorator</code> and <code>quacc.wflow_tools.customizers.redecorate</code> are imported in the base <code>__init__.py</code> for easy user access</li> <li>The CLI now has color</li> </ul>"},{"location":"about/changelog.html#changed_47","title":"Changed","text":"<ul> <li>The test suite's SCRATCH_DIR and RESULTS_DIR are now fixed to a given location</li> <li>The default Espresso preset has been changed to \"sssp_1.3.0_pbe_efficiency\"</li> <li>To remove calculator defaults entirely, <code>quacc.Remove</code> is recommended in place of <code>None</code></li> <li>The <code>quacc.wflow_tools.customizers.strip_decorator</code> function is recommended instead of calling <code>.__wrapped__</code></li> </ul>"},{"location":"about/changelog.html#fixed_47","title":"Fixed","text":"<ul> <li>Fixed Dask subflows that were calling <code>.compute()</code></li> <li>Fixed various bugs in the Espresso calculator and recipes</li> </ul>"},{"location":"about/changelog.html#050","title":"[0.5.0]","text":""},{"location":"about/changelog.html#added_45","title":"Added","text":"<ul> <li>Created a <code>quacc.wflow_tools.customizers</code> module to aid in customizing pre-made recipes.</li> </ul>"},{"location":"about/changelog.html#changed_48","title":"Changed","text":"<ul> <li>Overhauled how sub-jobs in recipes can be dynamically modified by the user to increase flexibility.</li> <li>Changed default <code>fmax</code> for <code>quacc.recipes.mlp.core.relax_job</code> to 0.05.</li> <li>Renamed the <code>quacc.utils.dicts.merge_dicts</code> function to <code>._recursive_dict_pair_merge</code> to better reflect its functionality.</li> <li>Renamed the <code>quacc.utils.dicts.merge_several_dicts</code> function to <code>.recursive_dict_merge</code> to better reflect its functionality.</li> </ul>"},{"location":"about/changelog.html#fixed_48","title":"Fixed","text":"<ul> <li>Increased support of <code>~/</code> throughout quacc file handling mechanisms</li> <li>Fixed an infinite recursion error when <code>copy_decompress_files_from_dir</code> was run in the current working directory.</li> </ul>"},{"location":"about/changelog.html#046","title":"[0.4.6]","text":""},{"location":"about/changelog.html#added_46","title":"Added","text":"<ul> <li>The <code>WORKFLOW_ENGINE</code> quacc setting now accepts <code>None</code>.</li> <li>A <code>DEBUG</code> quacc setting as been added.</li> </ul>"},{"location":"about/changelog.html#changed_49","title":"Changed","text":"<ul> <li>The way to run complex, dynamic flows has been modified to rely on <code>functools.partial()</code> instead of kwargs. See the updated documentation.</li> <li>Refactored test suite</li> </ul>"},{"location":"about/changelog.html#045","title":"[0.4.5]","text":""},{"location":"about/changelog.html#added_47","title":"Added","text":"<ul> <li>Added ML interatomic potential recipes</li> </ul>"},{"location":"about/changelog.html#changed_50","title":"Changed","text":"<ul> <li>ASE optimization log files and pickle files are written to disk by default</li> <li>Deprecated the old Q-Chem recipes and replaced them with the updated versions</li> </ul>"},{"location":"about/changelog.html#removed_11","title":"Removed","text":"<ul> <li>Officially drop support of the Prefect workflow engine</li> </ul>"},{"location":"about/changelog.html#044","title":"[0.4.4]","text":""},{"location":"about/changelog.html#added_48","title":"Added","text":"<ul> <li>Added core Quantum ESPRESSO recipes and custom calculator. (@tomdemeyere)</li> <li>Added a new function, <code>quacc.utils.files.copy_decompress_files_from_dir</code></li> </ul>"},{"location":"about/changelog.html#changed_51","title":"Changed","text":"<ul> <li>The <code>copy_files</code> kwarg in most recipes can now include a directory</li> <li>Renamed <code>quacc.utils.files.copy_decompress</code> to <code>quacc.utils.files.copy_decompress_files</code></li> </ul>"},{"location":"about/changelog.html#fixed_49","title":"Fixed","text":"<ul> <li>Quacc settings that are paths now have <code>~/</code> expanded in most cases</li> </ul>"},{"location":"about/changelog.html#043","title":"[0.4.3]","text":""},{"location":"about/changelog.html#added_49","title":"Added","text":"<ul> <li>Added preliminary support for the <code>Dask</code> workflow engine via Dask Delayed and Dask Distributed.</li> </ul>"},{"location":"about/changelog.html#changed_52","title":"Changed","text":"<ul> <li>Renamed <code>CREATE_UNIQUE_WORKDIR</code> to <code>CREATE_UNIQUE_DIR</code> to better reflect its utility.</li> <li>The default for the <code>SCRATCH_DIR</code> setting is now <code>None</code> instead of <code>~/.quacc_scratch</code>. In other words, the default is to not use a scratch directory. This should help with onboarding, and the ability to set it as <code>None</code> may be broadly of interest. Setting the <code>SCRATCH_DIR</code> to a given <code>Path</code> will still work as expected.</li> <li>Files are no longer recursively copied from <code>SCRATCH_DIR</code> to <code>RESULTS_DIR</code>. Instead, they are recursively moved. This should speed up I/O operations.</li> </ul>"},{"location":"about/changelog.html#fixed_50","title":"Fixed","text":"<ul> <li>Fixed a missing <code>phonopy_kwargs</code> keyword argument in <code>quacc.recipes.common.phonons</code></li> </ul>"},{"location":"about/changelog.html#042","title":"[0.4.2]","text":""},{"location":"about/changelog.html#added_50","title":"Added","text":"<ul> <li>Added a Jenkins-based test suite that runs tests on HPC resources without mocking for Gaussian, GULP, ORCA, and VASP (minimal)</li> <li>Added a TBLite phonon recipe</li> </ul>"},{"location":"about/changelog.html#changed_53","title":"Changed","text":"<ul> <li>Changed the <code>auto_kpts</code> kwarg in the <code>Vasp</code> calculator to <code>pmg_kpts</code></li> <li>Internal refactoring of recipes to have a separate <code>_base.py</code> module when appropriate</li> <li>Removed the unnecessary <code>Atoms</code> arg from the <code>calc_setup</code> function</li> </ul>"},{"location":"about/changelog.html#fixed_51","title":"Fixed","text":"<ul> <li>Fixed slow initial import (3 s \u2192 1 s)</li> <li>Fixed a few broken type hints</li> <li>Fixed functional and basis set strings in Gaussian recipes</li> <li>Uses number of physical cores instead of logical cores as default for molecular DFT recipes</li> </ul>"},{"location":"about/changelog.html#041","title":"[0.4.1]","text":""},{"location":"about/changelog.html#changed_54","title":"Changed","text":"<ul> <li>Switched to using the PyPI release of NewtonNet (1.1).</li> <li>NewtonNet recipes don't run a Hessian calculation by default unless needed</li> </ul>"},{"location":"about/changelog.html#fixed_52","title":"Fixed","text":"<ul> <li>Fixed circular import issue when running Q-Chem calculations.</li> </ul>"},{"location":"about/changelog.html#removed_12","title":"Removed","text":"<ul> <li>Removed unsupported <code>qchem_internal_relax_job</code></li> </ul>"},{"location":"about/changelog.html#040","title":"[0.4.0]","text":""},{"location":"about/changelog.html#added_51","title":"Added","text":"<ul> <li>Added <code>quacc.recipes.common</code>, including <code>quacc.recipes.common.slabs</code>, <code>quacc.recipes.common.defects</code>, and <code>quacc.recipes.common.phonons</code></li> <li>Added phonopy schema in <code>quacc.schemas.phonons</code></li> <li>Added EMT phonon workflow</li> </ul>"},{"location":"about/changelog.html#changed_55","title":"Changed","text":"<ul> <li>The method for specifying swaps to the default calculator arguments in recipes has been overhauled. In place of the previous <code>calc_swaps: dict</code> approach, additional parameters can be specified via the <code>**kwargs</code>. In practice, this means in recipes you can do <code>scf = \"diis\", max_steps=100</code> instead of <code>calc_swaps={\"scf\":\"diis\", \"max_steps\":100}</code>, for instance.</li> <li>Moved <code>quacc.runners.calc</code> to <code>quacc.runners.ase</code></li> <li>Moved <code>quacc.runners.prep</code> to <code>quacc.schemas.prep</code></li> <li>Reduced code duplication across complex flows</li> </ul>"},{"location":"about/changelog.html#0313","title":"[0.3.13]","text":""},{"location":"about/changelog.html#fixed_53","title":"Fixed","text":"<ul> <li>Fixed support for the most recent version of ASE as of 11/2/2023</li> </ul>"},{"location":"about/changelog.html#0312","title":"[0.3.12]","text":""},{"location":"about/changelog.html#added_52","title":"Added","text":"<ul> <li>Added more type hints for input keyword arguments</li> <li>Added the <code>quacc info</code> command-line argument for error reporting</li> </ul>"},{"location":"about/changelog.html#changed_56","title":"Changed","text":"<ul> <li>Consolidated VASP INCAR co-pilot settings</li> <li>Internal refactoring of the Q-Chem and VASP calculators</li> </ul>"},{"location":"about/changelog.html#fixed_54","title":"Fixed","text":"<ul> <li>All <code>Path</code>-based settings have <code>.expanduser()</code> applied</li> </ul>"},{"location":"about/changelog.html#0311","title":"[0.3.11]","text":""},{"location":"about/changelog.html#changed_57","title":"Changed","text":"<ul> <li>Improved error handling</li> </ul>"},{"location":"about/changelog.html#0310","title":"[0.3.10]","text":""},{"location":"about/changelog.html#changed_58","title":"Changed","text":"<ul> <li>DFTB+ <code>MaxSccIterations</code> set to 200 by default</li> <li>SCC errors in DFTB+ relaxations will be reported with higher priority than a relaxation error</li> </ul>"},{"location":"about/changelog.html#039","title":"[0.3.9]","text":""},{"location":"about/changelog.html#changed_59","title":"Changed","text":"<ul> <li>Changed prefix of scratch directories to have the datetime in it for easier debugging</li> </ul>"},{"location":"about/changelog.html#fixed_55","title":"Fixed","text":"<ul> <li>DFTB+ recipes now won't crash when <code>kpts=None</code> for structures with PBCs</li> </ul>"},{"location":"about/changelog.html#038","title":"[0.3.8]","text":""},{"location":"about/changelog.html#changed_60","title":"Changed","text":"<ul> <li>Changed minimum version of Parsl</li> </ul>"},{"location":"about/changelog.html#037","title":"[0.3.7]","text":""},{"location":"about/changelog.html#added_53","title":"Added","text":"<ul> <li>Added type-hinting for schemas</li> </ul>"},{"location":"about/changelog.html#changed_61","title":"Changed","text":"<ul> <li>Recipes now take <code>Atoms</code> instead of <code>Atoms | dict</code> as input</li> <li>Recipes no longer require the use of <code>fetch_atoms</code></li> <li>Standardized schema fields</li> </ul>"},{"location":"about/changelog.html#removed_13","title":"Removed","text":"<ul> <li>Removed the <code>fetch_atoms</code> function</li> </ul>"},{"location":"about/changelog.html#036","title":"[0.3.6]","text":""},{"location":"about/changelog.html#fixed_56","title":"Fixed","text":"<ul> <li>Fixed VASP recipes to always respect <code>calc_swaps</code>.</li> <li>Fixed setting multiple cores in Custodian for Q-Chem runs.</li> </ul>"},{"location":"about/changelog.html#035","title":"[0.3.5]","text":""},{"location":"about/changelog.html#added_54","title":"Added","text":"<ul> <li>Added a new <code>VibThermoSchema</code> that merges the <code>VibSchema</code> and <code>ThermoSchema</code> as a convenience</li> </ul>"},{"location":"about/changelog.html#changed_62","title":"Changed","text":"<ul> <li>The output of recies no longer automatically removes blank lists/dicts/sets to maintain a consistent schema.</li> <li>The tblite <code>freq_job</code> and lj <code>freq_job</code> now use <code>VibThermoSchema</code> as the output</li> <li>Changed default <code>SCRATCH_DIR</code> from <code>Path.cwd() / \".scratch\"</code> to <code>Path(\"~/.scratch\")</code></li> </ul>"},{"location":"about/changelog.html#034","title":"[0.3.4]","text":""},{"location":"about/changelog.html#added_55","title":"Added","text":"<ul> <li>Added a new documentation section for worked examples on HPC.</li> </ul>"},{"location":"about/changelog.html#changed_63","title":"Changed","text":"<ul> <li>Updated the minimum required versions for Pymatgen and emmet-core to reflect Pydantic 2 update.</li> <li>Added <code>symprec=1e-8</code> to the default parameters of VASP relaxation jobs.</li> <li>VASP bulk recipes now use \"BulkSet\" as the default preset instead of <code>None</code>.</li> <li>VASP slab recipes now use \"SlabSet\" as the default preset instead of <code>None</code>.</li> </ul>"},{"location":"about/changelog.html#033","title":"[0.3.3]","text":""},{"location":"about/changelog.html#fixed_57","title":"Fixed","text":"<ul> <li>Fixed pip version conflict when installing Covalent dependencies.</li> </ul>"},{"location":"about/changelog.html#032","title":"[0.3.2]","text":""},{"location":"about/changelog.html#changed_64","title":"Changed","text":"<ul> <li>Migration to Pydantic 2 is complete, along with the corresponding dependencies.</li> </ul>"},{"location":"about/changelog.html#031","title":"[0.3.1]","text":""},{"location":"about/changelog.html#changed_65","title":"Changed","text":"<ul> <li>Pydantic field type validation has been improved.</li> <li>Moved <code>quacc.utils.atoms</code>/<code>.slabs</code>/<code>.defects</code> into <code>quacc.atoms.core</code>/<code>.slabs</code>/<code>.defects</code></li> <li>Moved <code>quacc.custodian</code> to <code>quacc.calculators.custodian</code></li> <li>Moved <code>quacc.utils.thermo.ideal_gas</code> to <code>quacc.builders.thermo.run_ideal_gas</code></li> <li>Renamed <code>quacc.schemas.ase.summarize_thermo</code> to <code>quacc.schemas.ase.summarize_ideal_gas_thermo</code></li> </ul>"},{"location":"about/changelog.html#030","title":"[0.3.0]","text":""},{"location":"about/changelog.html#changed_66","title":"Changed","text":"<ul> <li>Changed default <code>SCRATCH_DIR</code> from <code>/tmp</code> to <code>Path.cwd() / .scratch</code></li> <li>Refactored decorator handling to be more concise</li> <li>Renamed <code>[optimizers]</code> extras to <code>[sella]</code></li> <li>Moved <code>quacc.utils.wflows</code> into <code>quacc.wflow_tools.decorators</code> and <code>quacc.wflow_tools.prefect</code></li> <li>Moved <code>quacc.utils.db</code> into <code>quacc.wflow_tools.db</code></li> <li>Moved <code>quacc.utils.calc</code> to <code>quacc.runners.ase</code></li> <li>Moved <code>quacc.presets</code> to <code>quacc.calculators.presets</code></li> </ul>"},{"location":"about/changelog.html#fixed_58","title":"Fixed","text":"<ul> <li>Fixed parsing of <code>RESULTS_DIR</code> and <code>SCRATCH_DIR</code> paths when they contain <code>~</code></li> <li>Symlinks are no longer created if <code>RESULTS_DIR == SCRATCH_DIR</code> since this is redundant</li> <li>If <code>RESULTS_DIR</code> or <code>SCRATCH_DIR</code> are not present, they will be automatically made</li> </ul>"},{"location":"about/changelog.html#028","title":"[0.2.8]","text":""},{"location":"about/changelog.html#changed_67","title":"Changed","text":"<ul> <li>Decorators are now applied at import time rather than at function-call time.</li> </ul>"},{"location":"about/changelog.html#fixed_59","title":"Fixed","text":"<ul> <li>Fixed compatibility with FireWorks.</li> <li>Fixed I/O issue on Windows and NFS file systems where Sella optimizations would crash.</li> </ul>"},{"location":"about/changelog.html#027","title":"[0.2.7]","text":""},{"location":"about/changelog.html#added_56","title":"Added","text":"<ul> <li>Added a <code>freq_job</code> recipe in Q-Chem (@samblau)</li> <li>Added support for TRICs in Sella calculations (@samblau)</li> </ul>"},{"location":"about/changelog.html#changed_68","title":"Changed","text":"<ul> <li>Refactored all recipes to prevent code duplication</li> <li>Set <code>LREAL = False</code> in VASP <code>BulkSet.yaml</code></li> </ul>"},{"location":"about/changelog.html#026","title":"[0.2.6]","text":""},{"location":"about/changelog.html#added_57","title":"Added","text":"<ul> <li>Add support for <code>Path</code> objects everywhere possible.</li> </ul>"},{"location":"about/changelog.html#changed_69","title":"Changed","text":"<ul> <li>Charge and spin multiplicity are now required arguments in molecular DFT calculators.</li> <li>Slab recipes now use <code>make_slabs_from_bulk</code> instead of <code>make_max_slabs_from_bulk</code></li> <li>Use the <code>logging</code> module when warnings do not need to be immediately addressed.</li> <li>Functions are no longer used as kwargs in recipes to help with (de)serialization in certain workflow engines.</li> </ul>"},{"location":"about/changelog.html#removed_14","title":"Removed","text":"<ul> <li>Removed <code>make_max_slabs_from_bulk</code> function.</li> </ul>"},{"location":"about/changelog.html#025","title":"[0.2.5]","text":""},{"location":"about/changelog.html#added_58","title":"Added","text":"<ul> <li>Added support for the Redun workflow engine.</li> <li>Added a simple CLI for (un)setting YAML config parameters.</li> </ul>"},{"location":"about/changelog.html#changed_70","title":"Changed","text":"<ul> <li>Internal refactoring of the <code>Vasp</code> calculator.</li> </ul>"},{"location":"about/changelog.html#removed_15","title":"Removed","text":"<ul> <li>Removed the demonstration Jobflow EMT slab recipe.</li> </ul>"},{"location":"about/changelog.html#024","title":"[0.2.4]","text":""},{"location":"about/changelog.html#changed_71","title":"Changed","text":"<ul> <li>Updated VASP co-pilot rules and <code>BulkSet.yaml</code> in accordance with recent MP benchmarking (#849).</li> <li>Moved <code>fetch_atoms</code> to <code>quacc.schemas</code>.</li> </ul>"},{"location":"about/changelog.html#fixed_60","title":"Fixed","text":"<ul> <li>VASP: Fixed a scenario where SIGMA was set to 0.05 if the user provided SIGMA &gt; 0.05. This was supposed to happen when ISMEAR = 0 but was previously done when ISMEAR = -5, which is not influenced by SIGMA.</li> <li>Fixed <code>mp_metagga_relax_flow</code> to use a <code>@flow</code> decorator instead of <code>@job</code></li> <li>Fixed the Q-Chem Quasi-IRC job to run as one <code>@job</code> instead of two.</li> </ul>"},{"location":"about/changelog.html#023","title":"[0.2.3]","text":""},{"location":"about/changelog.html#added_59","title":"Added","text":"<ul> <li>Added new defect EMT workflows (@rwexler)</li> <li>Added new defect utilities (@rwexler)</li> <li>Added a custom Q-Chem calculator based on Pymatgen and Custodian. (@samblau)</li> <li>Added Q-chem core recipes. (@samblau)</li> <li>Added the ability to pass option <code>run_kwargs</code> to the <code>.run()</code> method of the ASE optimizers.</li> </ul>"},{"location":"about/changelog.html#changed_72","title":"Changed","text":"<ul> <li>Removed the need to call <code>ct.dispatch</code> when launching Covalent workflows.</li> <li>Renamed <code>quacc.util</code> to <code>quacc.utils</code></li> <li>Refactored and standardized the NewtonNet recipes to match the other recipes</li> </ul>"},{"location":"about/changelog.html#fixed_61","title":"Fixed","text":"<ul> <li>The <code>WORKFLOW_ENGINE</code> setting can now be set dynamically, as expected.</li> </ul>"},{"location":"about/changelog.html#022","title":"[0.2.2]","text":""},{"location":"about/changelog.html#changed_73","title":"Changed","text":"<ul> <li>Changed package handling in <code>pyproject.toml</code> to better handle pip installs.</li> </ul>"},{"location":"about/changelog.html#021","title":"[0.2.1]","text":""},{"location":"about/changelog.html#added_60","title":"Added","text":"<ul> <li>Added NewtonNet recipes and better sella support (@kumaranu)</li> </ul>"},{"location":"about/changelog.html#changed_74","title":"Changed","text":"<ul> <li>Standardized <code>relax_cell</code> to be <code>False</code> by default for all recipes.</li> <li>Update the default <code>SIGMA</code> and <code>ISMEAR</code> in <code>MPScanSet</code> to match the new values to be used in Atomate2.</li> </ul>"},{"location":"about/changelog.html#fixed_62","title":"Fixed","text":"<ul> <li>Fixed a bug on Windows where the trajectory file would not be closed after a relaxation, causing permission errors.</li> </ul>"},{"location":"about/changelog.html#removed_16","title":"Removed","text":"<ul> <li>Removed atomate2 as a dependency.</li> <li>Removed experimental Prefect support.</li> </ul>"},{"location":"about/changelog.html#020","title":"[0.2.0]","text":""},{"location":"about/changelog.html#added_61","title":"Added","text":"<ul> <li>Added a quacc global setting, <code>WORKFLOW_ENGINE</code>, to set the workflow manager.</li> <li>Added support for the new <code>covalent-hpc-plugin</code> in <code>pyproject.toml</code>.</li> </ul>"},{"location":"about/changelog.html#changed_75","title":"Changed","text":"<ul> <li>Quacc recipes are now decorated with generic <code>@job</code>, <code>@subflow</code>, or <code>@flow</code> decorators to be workflow engine-agnostic.</li> <li>Covalent is now an optional dependency to allow the base <code>quacc</code> package to be dependency-light.</li> <li>Default VASP pseudopotentials changed to <code>setups_pbe54.yaml</code>.</li> <li>Changed <code>quacc.recipes.emt.jobflow</code> and <code>quacc.recipes.emt.prefect</code> to <code>quacc.recipes.emt._jobflow</code> and <code>quacc.recipes.emt._prefect</code></li> </ul>"},{"location":"about/changelog.html#fixed_63","title":"Fixed","text":"<ul> <li>Set <code>LMAXMIX</code> based on the <code>Z</code> value, not the s/p/d/f-block type.</li> <li>Do not set automatically <code>LMAXTAU</code> to 8 for f-containing elements in <code>Vasp</code> calculator.</li> </ul>"},{"location":"about/changelog.html#removed_17","title":"Removed","text":"<ul> <li>Removed <code>quacc.recipes.emt.parsl</code> since it is now obsolete.</li> <li>Removed <code>quacc config</code> command-line option.</li> </ul>"},{"location":"about/changelog.html#013","title":"[0.1.3]","text":""},{"location":"about/changelog.html#added_62","title":"Added","text":"<ul> <li>Added a <code>PRIMARY_STORE</code> quacc setting that, when specified, will automatically store all results in the specified Maggma store.</li> </ul>"},{"location":"about/changelog.html#changed_76","title":"Changed","text":"<ul> <li>The trajectory is now stored in <code>quacc.schemas.cclib.summarize_run</code>.</li> <li>By default, results are now stored in a fixed <code>RESULTS_DIR</code>, which defaults to the current working directory.</li> </ul>"},{"location":"about/changelog.html#fixed_64","title":"Fixed","text":"<ul> <li>Fix path-related issues when running in local multi-threaded mode.</li> <li>Psi4 recipes now use <code>uks</code> for unrestricted calculations instead of <code>uhf</code>.</li> </ul>"},{"location":"about/changelog.html#012","title":"[0.1.2]","text":""},{"location":"about/changelog.html#added_63","title":"Added","text":"<ul> <li>Added support for Prefect.</li> <li>Added <code>quacc.wflow_tools</code> module.</li> </ul>"},{"location":"about/changelog.html#changed_77","title":"Changed","text":"<ul> <li>Made slab-related kwargs more consistent, such as by changing <code>slab_relax_electron</code>/<code>slab_relax_app</code> to just <code>slab_relax</code> regardless of workflow manager.</li> </ul>"},{"location":"about/changelog.html#011","title":"[0.1.1]","text":""},{"location":"about/changelog.html#added_64","title":"Added","text":"<ul> <li>Added this <code>CHANGELOG.md</code> file.</li> <li>Added the <code>quacc.recipes.emt.parsl</code> module.</li> <li>Added a CLI for <code>quacc</code> along with a <code>quacc config</code> option to configure Covalent appropriately upon install.</li> <li>Added generic type hints for schemas.</li> <li>Added a <code>CREATE_UNIQUE_DIR</code> global setting to have quacc automatically make a unique working directory for each calculation.</li> <li>Added <code>CHECK_CONVERGENCE</code> to global settings.</li> </ul>"},{"location":"about/changelog.html#changed_78","title":"Changed","text":"<ul> <li>The <code>quacc</code> directory is now found in a <code>src</code> basefolder.</li> <li>All recipes now support the <code>Atoms</code> object being passed in as an <code>AtomsSchema</code>.</li> <li>The <code>slab_relax_job</code> kwarg in <code>recipes.emt.slabs</code> and <code>recipes.vasp.slabs</code> workflows can no longer be set to <code>None</code>, as there are few situations where this would be desired.</li> <li>Class-based recipes have been converted to functions since they don't save state or have inheritance.</li> </ul>"},{"location":"about/changelog.html#docs","title":"Docs","text":"<ul> <li>Switched the docs from Furo to Material for MkDocs.</li> <li>Expanded upon Parsl documentation.</li> <li>Modified tutorials and added example configs for Slurm.</li> </ul>"},{"location":"about/changelog.html#fixed_65","title":"Fixed","text":"<ul> <li>Temporary directories are cleaned up after the run is completed.</li> </ul>"},{"location":"about/changelog.html#removed_18","title":"Removed","text":"<ul> <li>Removed <code>quacc.recipes.vasp.jobflow</code> module to prioritize Covalent and Parsl.</li> </ul>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.1.0 for more details.</p>"},{"location":"about/changelog.html#006","title":"[0.0.6]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.6 for more details.</p>"},{"location":"about/changelog.html#005","title":"[0.0.5]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.5 for more details.</p>"},{"location":"about/changelog.html#004","title":"[0.0.4]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.4 for more details.</p>"},{"location":"about/changelog.html#003","title":"[0.0.3]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.3 for more details.</p>"},{"location":"about/changelog.html#002","title":"[0.0.2]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.2 for more details.</p>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":"<p>See https://github.com/quantum-accelerators/quacc/releases/tag/v0.0.1 for more details.</p>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/contributors.html","title":"People","text":""},{"location":"about/contributors.html#lead-developers","title":"Lead Developers","text":"<p>Quacc was originally designed and developed by Andrew S. Rosen.</p>"},{"location":"about/contributors.html#active-maintainers","title":"Active Maintainers","text":"<p>The currently active maintainers are as follows:</p> <ul> <li>@Andrew_S_Rosen</li> </ul>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here. Some of their contributions are summarized below.</p> <p>Add Your Name!</p> <p>Don't see your name and want to update the list? Submit a PR and update this documentation page!</p> <ul> <li>@kumaranu: NewtonNet recipes.</li> <li>@nekkrad: ONETEP recipes.</li> <li>@rwexler: Defect utilities and EMT defect recipe.</li> <li>@samblau: Custom Q-Chem calculator, Q-Chem recipes.</li> <li>@tomdemeyere: Custom Espresso calculator, Espresso recipes.</li> <li>@ViktoriiaBaib: Initial testing of quacc.</li> <li>@zulissimeta: Dask support</li> <li>@yw-fang: VASP Non-SCF recipe</li> <li>@espottesmith: Some ORCA and Q-Chem workflows, mostly re: IRC</li> <li>@honghuikim: Dynamic changing of quacc settings with workflow engines</li> <li>@benshi97: VASP frequency recipe</li> </ul>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Quacc was originally inspired by Atomate2, developed by Alex Ganose.</p>"},{"location":"about/faq.html","title":"FAQ","text":"<p>Q: How do I pronounce <code>quacc</code>?</p> <p>A: Like the sound a duck makes: \"quack!\"</p> <p>Q: What's the philosophy behind quacc?</p> <p>A: This is a big question. I'll explain with some points that were on my mind when I made it:</p> <ol> <li> <p>Everyone's computing needs are different, which means not everyone is going to want to use the same workflow engine. This has historically hindered the widespread adoption of prior computational materials science libraries and makes it difficult to share workflows with others. quacc supports several workflow engines out-of-the-box using largely the same syntax, and you can pick your favorite (or use none at all).</p> </li> <li> <p>We should leverage tools that are widely used in the community. Python packages like ASE and Pymatgen are staples in the computational materials science community. Rather than reinvent the wheel, quacc takes advantage of what is already out there and \u2014 crucially \u2014 makes them play nicely together.</p> </li> <li> <p>Developers should be able to focus on the science, not the workflow architecture. Many similar packages have the science closely intertwined with the workflow logic. This makes it difficult to write new workflows without learning the intricacies of the workflow stack. quacc solely relies on the use of function decorators that make it easy to transform typical functions into ones that are workflow-ready.</p> </li> <li> <p>An overeliance on classes and inheritance can be confusing at the expense of conciseneess. I love classes, but in a computational materials science library, too much class inheritance can make it difficult to track down what parameters are getting set where. Students are also less familiar with classes and may have a difficult time in understanding how they work. The recipes in quacc take a more direct and familiar functional programming approach.</p> </li> <li> <p>And last but not least, I'm opinionated. quacc represents choices that I think make the most sense for my group and me. Hopefully they make sense for you too.</p> </li> </ol> <p>Q: Which workflow management system should I use?</p> <p>A: Good question! Check out the Workflow Engines Overview Guide for a comparison of several common options to see which might be best for you.</p> <p>Q: Why is quacc better than <code>InsertMyFavoriteCode</code>?</p> <p>A: Better is all in the eye of the beholder. If you are happy with the tools you are using, my goal is not to convince you to switch. That said, if you find that writing high-throughput computational workflows has a huge learning curve or simply takes too much time away from your science, then quacc may be for you.</p> <p>Q: Do you have any tips for writing new workflows?</p> <p>A: When developing new workflows, I strongly recommend writing an initial draft based on a low-cost ASE calculator like <code>EMT</code> or <code>LJ</code>, which will allow you to test on your local machine with fast turnaround. Also try to keep things modular. Trying to do too much in one function can make it difficult to debug.</p> <p>Q: How is quacc different than just using the Atomic Simulation Environment (ASE)</p> <p>A: quacc is designed to supercharge ASE for the efficient design of high-throughput workflows. Quacc makes it possible to easily design complex ASE workflows that can be run on heterogeneous compute environments with modern workflow managers. Quacc also makes it possible to combine ASE with the powerful Materials Project software stack, such as Custodian for on-the-fly error handling. For the database enthusiasts, quacc is interoperable with Maggma to store calculation results in a readily queryable format like MongoDB.</p> <p>Q: How is quacc different than Atomate2?</p> <p>A: Atomate2 is a fantastic code that can be used to run libraries of computational materials science workflows. Quacc was originally inspired by Atomate2 and can be thought of as a \"sister code\" to it. That said, there are several important differences.</p> <ul> <li> <p>In Atomate2, workflows are built around the Materials Project software stack and can be cumbersome to interface with the Atomic Simulation Environment (ASE). In contrast, quacc was built around ASE from the ground up while still making it possible to leverage much of the software underlying the Materials Project. Since quacc is built around ASE, it is also trivial to add new recipes based on any code that has an existing ASE Calculator even if it is not in quacc yet.</p> </li> <li> <p>Atomate2 is built around Jobflow. Quacc is largely workflow engine-agnostic and has out-of-the-box support for numerous workflow codes, including but not limited to Jobflow.</p> </li> <li> <p>Atomate2 is often used as a database-first approach to materials science workflows. Quacc is fully compatible with the use of databases but only emphasizes their use for experts, with the goal of reducing the barrier to getting started.</p> </li> <li> <p>Atomate2 is developed and supported by the Materials Project team at Lawrence Berkeley National Laboratory. Quacc is developed and maintained by the Rosen Research Group at Princeton University.</p> </li> </ul> <p>Q: I want to contribute a new recipe to quacc, but it will require additional dependencies. Is that a problem?</p> <p>A: Absolutely not a problem! Simply make your dependencies optional in the <code>pyproject.toml</code> file and use a <code>monty.dev.requires</code> decorator to ensure your recipes and tests only run if your necessary dependencies are installed. Refer to quacc.recipes.tblite.core and the <code>[tblite]</code> extras in the <code>pyproject.toml</code> file for an example.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2025, Andrew S. Rosen.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n- Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"dev/contributing.html","title":"Contributing Guide","text":"<p>We welcome all contributions, big or small (provided they come with unit tests!). Here are some general guidelines and tips. Note that it is never too early to open a PR if you're looking for input or feedback!</p> <p>Contributions are Acknowledged</p> <p>Thank you for reading this page! If you need additional incentive to contribute to quacc, we plan to eventually submit a manuscript based on this code. If you contribute to quacc in a significant way (e.g. adding a new recipe or module), you will be contacted to opt-in for authorship once a draft is written. Regardless, all contributors are acknowledged in the About section of the documentation.</p>"},{"location":"dev/contributing.html#steps-to-contribute","title":"Steps to Contribute","text":"<p>To contribute to quacc, we recommend doing the following:</p> <ul> <li> <p>Fork the repository to your personal GitHub account.</p> </li> <li> <p>Clone this forked repository to your local machine, e.g. via <code>git clone &lt;repo url&gt;.git</code>.</p> </li> <li> <p>In the newly downloaded <code>quacc</code> base directory, run <code>pip install -e .[dev]</code> to install quacc in editable mode and with the development dependencies. For reproducibility purposes, we strongly recommend installing quacc in a fresh virtual environment.</p> </li> <li> <p>Commit your changes and push them to your personal forked repository in a new branch.</p> </li> <li> <p>Create a pull request (PR) to merge your changes into the main quacc repository.</p> </li> </ul>"},{"location":"dev/contributing.html#guidelines","title":"Guidelines","text":""},{"location":"dev/contributing.html#general","title":"General","text":"<p>Please abide by the following guidelines when contributing code to quacc:</p> <ul> <li> <p>All changes should have associated unit tests that pass. Code coverage should be maintained.</p> </li> <li> <p>All code should include type hints and have internally consistent documentation for the inputs and outputs.</p> </li> <li> <p>Use absolute paths and avoid using <code>os.chdir</code> or <code>os.getcwd()</code>. This helps ensure that quacc can be run in multi-threading mode.</p> </li> <li> <p><code>gzip</code> large test files to save space.</p> </li> </ul>"},{"location":"dev/contributing.html#writing-new-recipes","title":"Writing New Recipes","text":"<p>Tip</p> <p>In general, the easiest way to develop a new recipe is to first make one for a cheap-to-run calculator (e.g. EMT for solids, LJ for molecules), which you can then basically copy and paste for your more expensive calculator of choice.</p> <p>If contributing new recipes, please abide by the following guidelines:</p> <ul> <li> <p>Please mimic one of the other recipes as a general template for internal consistency.</p> </li> <li> <p>Decorate your individual compute jobs with a <code>@job</code> decorator and your flows with a <code>@flow</code> decorator. Name them accordingly.</p> </li> <li> <p>In general, your tests for new recipes should use a small molecule/solid (and cheap settings, where possible) to ensure that the unit tests run quickly.</p> </li> </ul>"},{"location":"dev/contributing.html#style","title":"Style","text":"<p>In general, please try to keep the code style consistent when possible, particularly:</p> <ol> <li> <p>Use NumPy-style docstrings.</p> </li> <li> <p>Address any relevant issues raised by the GitHub Actions test suite.</p> </li> <li> <p>All Python code should be formatted with ruff (<code>ruff check --fix &amp;&amp; ruff format</code>).</p> </li> </ol>"},{"location":"dev/contributing.html#unit-tests","title":"Unit Tests","text":""},{"location":"dev/contributing.html#general_1","title":"General","text":"<p>All changes you make to quacc should be accompanied by unit tests and should not break existing tests. The full test suite will run automatically via GitHub Actions. If you are fixing a bug, include a regression test to make sure the fix you submit continues to work.</p>"},{"location":"dev/contributing.html#running-locally","title":"Running Locally","text":"<p>To run the core test suite locally, run <code>pytest tests/core</code>.</p> <p>If you wish to test the behavior of a given workflow engine, run <code>pytest tests/WORKFLOW_ENGINE</code> where <code>WORKFLOW_ENGINE</code> is the name of your workflow engine.</p>"},{"location":"dev/contributing.html#coverage","title":"Coverage","text":"<p>Each PR will report the code coverage once your tests pass, but if you'd like to generate a coverage report locally, you can use pytest-cov, such as by doing <code>pytest --cov=quacc .</code></p>"},{"location":"dev/contributing.html#monkeypatching","title":"Monkeypatching","text":"<p>For recipes that involve a calculation that cannot be easily run in the test suite (e.g. the underlying calculator cannot be installed via <code>pip</code> or <code>conda</code>), you will need to make a <code>conftest.py</code> file in the recipe directory that monkeypatches the relevant functions (refer to the Gaussian recipe tests for an example). Ideally, the tests should be written in such a way that they would also pass if the executable were actually available and the <code>conftest.py</code> file were not applied. To run the test on your own machine without the <code>conftest.py</code> file applied, you can use the <code>--noconftest</code> flag when calling <code>pytest</code>. If this is not practical (e.g. because it would take too long), a separate minimal test suite can be made specifically for running on an HPC machine.</p>"},{"location":"dev/contributing.html#running-a-pr-on-an-hpc-machine","title":"Running a PR on an HPC Machine","text":"<p>It is possible to trigger the test suite on a Princeton-hosted HPC machine where the licensed executables are run without monkeypatching. If you are a member of the @Quantum-Accelerators, this will happen automatically. If you are not, then an admin will need to give permission. Permission is only needed if your PR is modifying a calculator or recipe.</p>"},{"location":"dev/docs.html","title":"Updating the Docs","text":"<p>To install the dependencies to build the documentation, run <code>pip install -e .[docs]</code>.</p> <p>The quacc documentation is built using Material for MkDocs. To build the documentation locally (e.g. to evaluate changes), run <code>mkdocs serve</code> in the base directory and open the URL shown in the terminal.</p>"},{"location":"dev/recipes/flows.html","title":"Writing Flows","text":""},{"location":"dev/recipes/flows.html#simple-flows","title":"Simple Flows","text":""},{"location":"dev/recipes/flows.html#overview","title":"Overview","text":"<p>A flow is a Python function decorated by <code>@flow</code> that contains a collection of jobs. Refer to the Workflow Syntax page for more information on the syntax of flows.</p> <p>The Most Important Rules of Flows</p> <p>The flow itself does not contain computationally intensive tasks. It simply calls other jobs (and/or flows) and defines the workflow logic. In general, essentially no operations can be done on the outputs of a job in a flow; they can only be passed as inputs to other jobs. This is because the output is a future whose value is not resolved until runtime. Note that doing <code>result[\"atoms\"]</code>, where <code>result</code> is the output of a job in the flow, returns a future and not the actual <code>Atoms</code> object. When passed as an input to a subsequent job, however, it will know to automatically resolve the <code>Atoms</code> object before running.</p>"},{"location":"dev/recipes/flows.html#production-example","title":"Production Example","text":"<p>A simple, representative flow can be found in quacc.recipes.vasp.mp24.mp_metagga_relax_flow.</p> <p>Note</p> <p>All <code>@flow</code>-decorated functions distributed with quacc must allow for the individual job parameters and decorators to be updated by the user, which is typically done via the quacc.wflow_tools.customizers.customize_funcs function. Refer to the example above for details.</p>"},{"location":"dev/recipes/flows.html#dynamic-flows","title":"Dynamic Flows","text":"<p>quacc fully supports complex, dynamic flows where the number of jobs is not known a priori. In this case, a common pattern is the use of a subflow, defined with a <code>@subflow</code> decorator. A subflow is just like a flow, except the returned object is a list of job outputs.</p> <p>Minimal Example</p> <p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Make a list of random length of the output of Step 1 (e.g. <code>[3, 3, 3]</code>)</li> <li>Add a third number to each element of the list from Step 2 (e.g. <code>[3 + 3, 3 + 3, 3 + 3]</code>)</li> </ol> <p>In practice, we would want each of the two tasks to be their own compute job.</p> <pre><code>graph LR\nA[Input] --&gt; B(add) --&gt; C(make list)\nC(make list) --&gt; D(add) --&gt; G[Output]\nC(make list) --&gt; E(add) --&gt; G[Output]\nC(make list) --&gt; F(add) --&gt; G[Output]</code></pre> <pre><code>from random import randint\nfrom quacc import flow, job, subflow\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\n@job\ndef make_list(val):\n    return [val] * randint(2, 5)\n\n\n@subflow\ndef add_distributed(vals, c):\n    outputs = []\n    for val in vals:\n        output = add(val, c)\n        outputs.append(output)\n    return outputs\n\n\n@flow\ndef workflow(a, b, c):\n    output1 = add(a, b)\n    output2 = make_list(output1)\n    output3 = add_distributed(output2, c)\n    return output3\n</code></pre>"},{"location":"dev/recipes/flows.html#production-example_1","title":"Production Example","text":"<p>A representative example of a complex flow can be found in quacc.recipes.emt.slabs.bulk_to_slabs_flow.</p> <p>This flow is \"dynamic\" because the number of slabs is not known until the pre-requisite relaxation step is completed.</p> <p>Note</p> <p>To prevent code duplication, we put common recipes that are code-agnostic in <code>quacc.recipes.common</code>. These recipes are not meant to be run directly, but rather called by other recipes.</p> <p>For instance, quacc.recipes.emt.slabs.bulk_to_slabs_flow and quacc.recipes.vasp.slabs.bulk_to_slabs_flow both call the same quacc.recipes.common.slabs.bulk_to_slabs_subflow.</p>"},{"location":"dev/recipes/jobs.html","title":"Writing Jobs","text":""},{"location":"dev/recipes/jobs.html#overview","title":"Overview","text":"<p>Individual compute tasks are called jobs. You can think of these as distinct calculations you would submit to the job scheduler (e.g. Slurm). Refer to the Workflow Syntax page for more information on the syntax of jobs.</p>"},{"location":"dev/recipes/jobs.html#examples","title":"Examples","text":"<p>For an example job using an ASE optimizer, refer to quacc.recipes.tblite.core.relax_job.</p> <p>For a representative job involving a code that uses an internal geometry optimizer, refer to quacc.recipes.vasp.core.relax_job.</p>"},{"location":"dev/recipes/jobs.html#requirements-and-recommendations","title":"Requirements and Recommendations","text":"<p>In quacc, jobs are defined as Python functions that are decorated with <code>@job</code>.</p> <p>The following are typical guidelines for jobs:</p> <ul> <li> <p>The function inputs and outputs must be serializable with pickle.</p> </li> <li> <p>The function generally should take an <code>Atoms</code> object as the input, along with any other keyword arguments needed to set calculator parameters and define the logic flow.</p> </li> <li> <p>The returned object should typically be a dictionary of results, as defined in <code>quacc.schemas</code>. If a dictionary is returned, the keys cannot have \".\" in them.</p> </li> <li> <p>Calculations should be executed using a runner from <code>quacc.runners</code>.</p> </li> <li> <p>When given the choice between using an ASE optimizer and the electronic structure package's built-in optimizer, you should typically use the latter.</p> </li> </ul>"},{"location":"dev/recipes/jobs.html#schemas","title":"Schemas","text":"<p>A schema is a dictionary containing tabulated input and output properties from a calculation.</p> <p>All available schemas are stored in <code>quacc.schemas</code>, and type-hints associated with the outputs are stored in <code>quacc.types</code>.</p> <p>All schemas create quacc-compatible dictionaries from a given calculation and also will automatically store results in the user's database, if one is specified in the global settings.</p>"},{"location":"install/codes.html","title":"Calculator Setup","text":"<p>Start Simple</p> <p>Just getting started? Try using the EMT or LJ recipes before worrying about setting up one of the calculators below.</p> <p>Here, we outline how to ensure that quacc can run the quantum chemistry package of your choosing. You only need to follow the instructions for the code(s) you intend to use.</p>"},{"location":"install/codes.html#dftb","title":"DFTB+","text":"<p>If you plan to use DFTB+ with quacc, you will need to install the code as follows:</p> <pre><code>conda install -c conda-forge dftbplus\n</code></pre>"},{"location":"install/codes.html#emt","title":"EMT","text":"<p>No setup needed!</p>"},{"location":"install/codes.html#gaussian","title":"Gaussian","text":"<p>To use quacc with Gaussian, you will need to define the <code>GAUSSIAN_CMD</code> setting to be the path of the Gaussian executable (or the name of the executable if it is already in your <code>PATH</code>). This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variable:</p> <pre><code>export QUACC_GAUSSIAN_CMD=\"/path/to/g16\"\n</code></pre>"},{"location":"install/codes.html#gulp","title":"GULP","text":"<p>To use quacc with GULP, you will need to download and compile GULP 6.2+ per the official manual. Then you will define the <code>GULP_CMD</code> setting to be the path of the GULP executable and the <code>GULP_LIB</code> setting to be the path to the GULP force field library. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variables in your <code>~/.bashrc</code>:</p> <pre><code>export QUACC_GULP_CMD=\"/path/to/gulp\"\nexport QUACC_GULP_LIB=\"/path/to/gulp-#.#.#/Libraries\"\n</code></pre> Receive a Compilation Error? <p>If you receive an error upon compilation, you likely are using an old version of gfortran. Try <code>./mkgulp_old_gfortran</code> instead of <code>./mkgulp</code> in the <code>Src</code> directory.</p>"},{"location":"install/codes.html#lennard-jones","title":"Lennard Jones","text":"<p>No setup needed!</p>"},{"location":"install/codes.html#mlps","title":"MLPs","text":"<p>Several pre-trained \"universal\" machine-learned potentials (MLPs) are natively supported in quacc, including those provided in the MACE, matgl, Orb, and FAIR-Chem repositories.</p> <p>To use these potentials, you will need to install the corresponding packages, which are listed in the <code>pyproject.toml</code>.</p>"},{"location":"install/codes.html#newtonnet","title":"NewtonNet","text":"<p>If you plan to use NewtonNet with Quacc, you will need to install it prior to use. This can be done as follows:</p> <pre><code>pip install quacc[newtonnet]\n</code></pre>"},{"location":"install/codes.html#onetep","title":"ONETEP","text":"<p>If you plan on using ONETEP with quacc, you will need to obtain and install ONETEP. This can be done as described in the How to Get Onetep section of the software documentation.</p> <p>At minimum, you will need to define and set <code>ONETEP_CMD</code> to be the full path to your ONETEP binary. You can also specify the <code>ONETEP_PP_PATH</code> to be the path to the pseudopotentials. This can be done as described in the section on \"Modifying Quacc Settings\".</p> <p>An example is provided below on how to define the commands in your <code>~/.bashrc</code>:</p> <pre><code>export ONETEP_CMD=\"/path/to/onetep/binary\"\nexport ONETEP_PP_PATH=\"/path/to/my/pseudos\"\n</code></pre>"},{"location":"install/codes.html#orca","title":"ORCA","text":"<p>To use quacc with ORCA, you will need to define the <code>ORCA_CMD</code> setting to be the full, absolute path to your ORCA executable. This can be done as described in the section on \"Modifying Quacc Settings\", such as by defining the following environment variable in your <code>~/.bashrc</code>:</p> <pre><code>export QUACC_ORCA_CMD=\"/path/to/orca/orca\"\n</code></pre>"},{"location":"install/codes.html#psi4","title":"Psi4","text":"<p>If you plan to use Psi4 with quacc, you will need to install it prior to use. This can be done as follows:</p> <pre><code>conda install -n base conda-libmamba-solver\nconda install psi4 -c conda-forge --solver libmamba\n</code></pre>"},{"location":"install/codes.html#q-chem","title":"Q-Chem","text":"<p>If you plan to use Q-Chem with Quacc, you will need to install <code>openbabel</code>. This can be done as follows:</p> <pre><code>conda install -c conda-forge openbabel\n</code></pre>"},{"location":"install/codes.html#quantum-espresso","title":"Quantum ESPRESSO","text":"<p>To use quacc with Quantum ESPRESSO, you will first need to download and install Quantum ESPRESSO. This can be most easily down as follows:</p> <pre><code>conda install -c conda-forge qe\n</code></pre> <p>You will also need to download the relevant pseudopotentials.</p> <p>Finally, you will need to define multiple environment variables. This can be done as described in the section on \"Modifying Quacc Settings\".</p> <p>At minimum, you should define the <code>ESPRESSO_PSEUDO</code> setting:</p> <pre><code>export QUACC_ESPRESSO_PSEUDO=\"/path/to/pseudopotentials\"\n</code></pre> <p>The various ESPRESSO binaries should be present in your <code>PATH</code>, or you should modify the <code>ESPRESSO_BIN_PATHS</code> quacc setting accordingly.</p>"},{"location":"install/codes.html#tblite","title":"TBLite","text":"<p>If you plan to use TBLite with quacc, you will need to install the tblite interface with ASE support.</p> CondaPip <pre><code>conda install -c conda-forge tblite-python\n</code></pre> <pre><code>pip install quacc[tblite] # only on Linux\n</code></pre> <p>Refer to the TBLite documentation for details on how to parallelize calculations and adjust the memory limits.</p>"},{"location":"install/codes.html#vasp","title":"VASP","text":"<p>To use quacc with VASP, you will need to define several environment variables, as described in the section on \"Modifying Quacc Settings\". The most important are listed below:</p> <pre><code>export QUACC_VASP_PARALLEL_CMD=\"srun -N 2 --ntasks-per-node 24\"\nexport QUACC_VASP_PP_PATH=\"/path/to/POTCARs\"\nexport QUACC_VASP_PP_VERSION=\"64\"\n</code></pre> <p>The <code>VASP_PARALLEL_CMD</code> setting tells Custodian and/or ASE how to parallelize VASP. Note that it does not include the executable.</p> <p>The <code>VASP_PP_PATH</code> setting should be defined as described in the ASE documentation such that it is a directory containing each VASP pseudopotential folder. Similarly, the <code>VASP_PP_VERSION</code> setting defines the version of the pseudopotentials to use.</p> <p>Additional settings can be specified as well, such as the name of the VASP executables if they differ from the default values (i.e. <code>vasp_std</code>, <code>vasp_gam</code>).</p>"},{"location":"install/install.html","title":"Installation","text":""},{"location":"install/install.html#pre-requisites","title":"Pre-Requisites","text":"<p>Using Windows?</p> <p>If you are on a Windows machine, we recommend using the Windows Subsystem for Linux (WSL) to benefit from all the features of quacc.</p> <ol> <li>Install Python 3.10+, preferably in conjunction with an environment manager. For instance, download and run the Miniconda installer</li> <li>When asked to add Miniconda to your <code>PATH</code>, select yes</li> <li>Create a fresh Python environment by running <code>conda create -n quacc python=3.11</code></li> <li>Activate this environment via <code>conda activate quacc</code></li> </ol>"},{"location":"install/install.html#installing-quacc","title":"Installing quacc","text":"<p>In your newly activated conda environment, run the following commands to install quacc. Note that you will need to install quacc on all machines where you plan to run calculations.</p> <p>For the latest PyPI release:</p> <pre><code>pip install quacc\n</code></pre> <p>For the development version:</p> <pre><code>pip install \"quacc @ git+https://github.com/quantum-accelerators/quacc.git\"\n</code></pre>"},{"location":"install/wflow_engines.html","title":"Workflow Engine Setup","text":"<p>Using a workflow engine is a crucial component for scaling up quacc calculations in a high-throughput setting. We describe the necessary installation steps here for the workflow manager of your choosing.</p> <p>Picking a Workflow Engine</p> <p>If you don't want to use a workflow engine or are just starting out, you can simply skip this section.</p> <p>For a comparison of the different compatible workflow engines, refer to the Workflow Engines Overview section.</p> DaskParslPrefectRedunJobflow <p>Installation</p> <p>To install Dask, run the following:</p> <pre><code>pip install quacc[dask]\n</code></pre> <p>Installation</p> <p>To install Parsl, run the following:</p> <pre><code>pip install quacc[parsl]\n</code></pre> <p>Parsl has many configuration options, which we will cover later in the documentation.</p> <p>Installation</p> <p>To install Prefect, run the following:</p> <pre><code>pip install quacc[prefect]\n</code></pre> <p>To connect to Prefect Cloud, run the following as well:</p> <pre><code>prefect cloud login\n</code></pre> <p>Prefect has many configuration options. For instance, you can store the quacc logs in the UI as follows:</p> <pre><code>prefect config set PREFECT_LOGGING_EXTRA_LOGGERS=quacc\n</code></pre> <p>Installation</p> <p>To install Redun, run the following:</p> <pre><code>pip install quacc[redun]\n</code></pre> Jobflow-RemoteFireworks <p>Installation</p> <p>To install Jobflow with support for Jobflow-Remote, run the following:</p> <pre><code>pip install quacc[jobflow]\n</code></pre> <p>MongoDB Setup</p> <p>Jobflow requires the use of a database (most commonly a MongoDB instance) to store calculation results.</p> <p>Tip</p> <p>If it is not possible to use MongoDB, you can use a variety of other data store options available within the maggma package.</p> <p>Jobflow DB Setup</p> <p>If you plan to use Jobflow-Remote to run your workflows, you will need to carry out the following steps:</p> <ol> <li> <p>Run <code>jf project generate cms</code></p> </li> <li> <p>Replace the <code>~/.jfremote/cms.yaml</code> with the configuration parameters outlined in the Jobflow Remote configuration documentation. There are many different kinds of configurations. A representative example is shown below for the \"all-in-one\" configuration. When the YAML is completed, run <code>jf project check --errors</code>. If there are no errors, you can run <code>jf runner start</code> to start the runner.</p> </li> </ol> ~/.jfremote/cms.yaml<pre><code>name: cms\nworkers:\n  basic_python:\n    type: local\n    scheduler_type: slurm\n    work_dir: /path/to/my/workdir/jobflow/python\n    pre_run: |\n      source ~/.bashrc\n      module load anaconda3/2025.6\n      conda activate cms\n      export QUACC_WORKFLOW_ENGINE=jobflow\n    timeout_execute: 60\n    resources:\n      nodes: 1\n      ntasks_per_node: 1\n      cpus_per_task: 1\n      mem: 8G\n      time: 04:00:00\n      account: rosengroup\n  basic_vasp:\n    type: local\n    scheduler_type: slurm\n    work_dir: /path/to/my/workdir/jobflow/python\n    pre_run: |\n      source ~/.bashrc\n      module load anaconda3/2025.6\n      conda activate cms\n      module load vasp/6.5.1\n      export QUACC_VASP_PARALLEL_CMD=\"srun --nodes 1 --ntasks-per-node 112\"\n      export QUACC_WORKFLOW_ENGINE=jobflow\n    timeout_execute: 60\n    resources:\n      nodes: 1\n      ntasks_per_node: 112\n      cpus_per_task: 1\n      mem: 900G\n      time: 04:00:00\n      account: rosengroup\nqueue:\n  store:\n    type: MongoStore\n    host: localhost\n    database: &lt;MongoDB Database Name&gt;\n    username: &lt;MongoDB UserName&gt;\n    password: &lt;MongoDB PW&gt;\n    collection_name: jf_jobs\n  flows_collection: jf_flows\n  auxiliary_collection: jf_aux\nexec_config: {}\njobstore:\n  docs_store:\n    type: MongoStore\n    database: &lt;MongoDB Database Name&gt;\n    host: localhost\n    username: &lt;MongoDB UserName&gt;\n    password: &lt;MongoDB PW&gt;\n    collection_name: jf_outputs\n</code></pre> <p>Afterwards, confirm that everything works by running the following minimal example:</p> <pre><code>from jobflow_remote.utils.examples import add\nfrom jobflow_remote import submit_flow\nfrom jobflow import Flow\n\njob1 = add(1, 2)\njob2 = add(job1.output, 2)\nflow = Flow([job1, job2])\n\nids = submit_flow(flow, worker=\"basic_python\")\nprint(ids)\n</code></pre> <p>Installation</p> <p>To install Jobflow with support for Fireworks, run the following:</p> <pre><code>pip install quacc[jobflow] fireworks\n</code></pre> <p>MongoDB Setup</p> <p>Jobflow requires the use of a database (most commonly a MongoDB instance) to store calculation results.</p> <p>Tip</p> <p>If it is not possible to use MongoDB, you can use a variety of other data store options available within the maggma package.</p> <p>Jobflow DB Setup</p> <p>If you plan to use Jobflow to write your workflows, you will need to make a <code>jobflow.yaml</code> file. This file will generally be formatted like the example below. Fill in the fields with the appropriate values for your MongoDB cluster, which is where all your calculation inputs and outputs will be stored.</p> jobflow.yaml<pre><code>JOB_STORE:\n  docs_store:\n    type: MongoStore\n    host: &lt;host name&gt;\n    port: 27017\n    username: &lt;username&gt;\n    password: &lt;password&gt;\n    database: &lt;database name&gt;\n    collection_name: &lt;collection name&gt;\n</code></pre> MongoDB Atlas <p>If you are using a URI (as is common with MongoDB Atlas), then you will instead have a <code>jobflow.yaml</code> file that looks like the example below. Here, you will put the full URI in the <code>host</code> field. The <code>username</code> and <code>password</code> are part of the URI and so should not be included elsewhere in the YAML file.</p> jobflow.yaml<pre><code>JOB_STORE:\n  docs_store:\n    type: MongoStore\n    host: &lt;URI&gt;\n    port: 27017\n    database: &lt;database name&gt;\n    collection_name: &lt;collection name&gt;\n</code></pre> <p>You will then need to define a <code>JOBFLOW_CONFIG_FILE</code> environment variable pointing to the file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export JOBFLOW_CONFIG_FILE=\"/path/to/my/jobflow.yaml\"\n</code></pre> <p>FireWorks Setup</p> <p>If you plan to use FireWorks to dispatch your Jobflow workflows, you will also need to make a few configuration files: <code>FW_config.yaml</code>, <code>my_fworker.yaml</code>, <code>my_launchpad.yaml</code>, and <code>my_qadapter.yaml</code>. To begin, make a directory called <code>fw_config</code> where you will store the four files described in greater detail below. The directory structure will look like the following:</p> <pre><code>fw_config\n\u251c\u2500\u2500 FW_config.yaml\n\u251c\u2500\u2500 my_fworker.yaml\n\u251c\u2500\u2500 my_launchpad.yaml\n\u2514\u2500\u2500 my_qadapter.yaml\n</code></pre> <p>FW Config File</p> <p>For the <code>FW_config.yaml</code>, you can use the following template. Make sure to update the path to the <code>fw_config</code> folder where the file resides.</p> FW_config.yaml<pre><code>CONFIG_FILE_DIR: &lt;/path/to/fw_config&gt;\nQUEUE_UPDATE_INTERVAL: 2\n</code></pre> <p>You will also need to define a <code>FW_CONFIG_FILE</code> environment variable pointing to the <code>FW_config.yaml</code> file you made. For instance, in your <code>~/.bashrc</code> file, add the following line:</p> <pre><code>export FW_CONFIG_FILE=\"/path/to/config/fw_config/FW_config.yaml\"\n</code></pre> <p>FWorker</p> <p>For the <code>my_fworker.yaml</code>, you can use the following template. You do not need to make any modifications.</p> my_fworker.yaml<pre><code>name: quacc_fworker\ncategory: \"\"\nquery: \"{}\"\n</code></pre> <p>Launchpad</p> <p>For the <code>my_launchpad.yaml</code>, you can use the following template. Replace the entries in <code>&lt;&gt;</code> with the appropriate values for your Mongo database.</p> my_launchpad.yaml<pre><code>host: &lt;host name&gt;\nport: 27017\nname: &lt;database name&gt;\nusername: &lt;username&gt;\npassword: &lt;password&gt;\nlogdir: null\nstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> MongoDB Atlas <p>If you are accessing your MongoDB via a URI (e.g. as with MongoDB Atlas), then you will use the following <code>my_launchpad.yaml</code> template instead.</p> my_launchpad.yaml<pre><code>host: &lt;URI&gt;\nport: 27017\nname: &lt;database name&gt;\nuri_store: true\nlogdir: null\nstrm_lvl: DEBUG\nuser_indices: []\nwf_user_indices: []\n</code></pre> <p>QAdapter</p> <p>Assuming you plan to use a queuing system for your compute jobs, you will need to make a <code>my_qadapter.yaml</code> file. For this, you will need to follow the instructions in the FireWorks documentation for your specific job scheduling system. An example <code>my_qadapter.yaml</code> file is shown below for Slurm, assuming that you have a <code>cms</code> Conda environment.</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w &lt;/path/to/fw_config/my_fworker.yaml&gt; singleshot\nnodes: 1\nwalltime: 00:30:00\naccount: &lt;account&gt;\njob_name: quacc_firework\nqos: regular\nsignal: SIGINT@60\npre_rocket: |\n            conda activate cms\n            export QUACC_WORKFLOW_ENGINE=jobflow\n</code></pre> <p>In the above example, you would need to change the path in the <code>rocket_launch</code> field to the correct path to your <code>my_fworker.yaml</code>. The nodes, walltime, account, and qos are the corresponding parameters for your queuing system. Finally, anything in the <code>pre_rocket</code> field will be executed before the job begins running. It is a good place to load modules and set environment variables. A representative example has been provided above.</p> <p>Database Initialization</p> <p>Danger</p> <p>Running <code>lpad reset</code> will clear your FireWorks launchpad, so only use this command if you are a new user.</p> <p>To check that FireWorks can connect to your database, run <code>lpad reset</code> if this is your first time using FireWorks.</p>"},{"location":"maintainers/internal.html","title":"Overview","text":""},{"location":"maintainers/internal.html#approving-jenkins-builds","title":"Approving Jenkins Builds","text":"<p>We have a Jenkins build pipeline that is automatically launched on pull requests, running a subset of the tests on the Adroit cluster at Princeton with the <code>--noconftest</code> pytest flag. This makes it possible to test recipes for licensed codes in a true production environment.</p> <p>When a new pull request is opened by someone who is on the whitelist (by default, everyone in the @Quantum-Accelerators organization), the build process will automatically start.</p> <p>For a pull request opened by a contributor not on the whitelist, @buildbot-princeton will ask \"Can one of the admins verify this patch?\". No build will be launched until one of the following actions are taken by a member on the whitelist:</p> <ul> <li>\"@buildbot-princeton test this please\" to run the test once. Use this if you don't personally know the contributor. Use \"@buildbot-princeton retest this please\" to launch a follow-up test, if needed.</li> <li>\"@buildbot-princeton ok to test\" to run tests for all future commits in the pull request. Use this for trusted contributors only.</li> <li>\"@buildbot-princeton add to whitelist\" to add a contributor to the whitelist permanently. Use this only after consulting with a maintainer of <code>quacc</code>.</li> </ul>"},{"location":"maintainers/internal.html#manual-upload-to-pypi","title":"Manual Upload to PyPI","text":"<p>To upload to PyPI manually in the case of a GitHub Actions failure:</p> <pre><code>pip install -e .\npython -m build\ntwine check dist/*\ntwine upload dist/*\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>quacc<ul> <li>atoms<ul> <li>core</li> <li>defects</li> <li>deformation</li> <li>phonons</li> <li>slabs</li> <li>ts</li> </ul> </li> <li>calculators<ul> <li>espresso<ul> <li>espresso</li> <li>utils</li> </ul> </li> <li>mrcc<ul> <li>io</li> <li>mrcc</li> </ul> </li> <li>qchem<ul> <li>io</li> <li>params</li> <li>qchem</li> <li>qchem_custodian</li> </ul> </li> <li>vasp<ul> <li>io</li> <li>params</li> <li>vasp</li> <li>vasp_custodian</li> </ul> </li> </ul> </li> <li>recipes<ul> <li>common<ul> <li>defects</li> <li>elastic</li> <li>phonons</li> <li>slabs</li> </ul> </li> <li>dftb<ul> <li>_base</li> <li>core</li> </ul> </li> <li>emt<ul> <li>core</li> <li>defects</li> <li>elastic</li> <li>md</li> <li>phonons</li> <li>slabs</li> </ul> </li> <li>espresso<ul> <li>_base</li> <li>bands</li> <li>core</li> <li>dos</li> <li>phonons</li> </ul> </li> <li>gaussian<ul> <li>_base</li> <li>core</li> </ul> </li> <li>gulp<ul> <li>_base</li> <li>core</li> </ul> </li> <li>lj<ul> <li>core</li> </ul> </li> <li>mlp<ul> <li>_base</li> <li>core</li> <li>elastic</li> <li>phonons</li> </ul> </li> <li>mrcc<ul> <li>_base</li> <li>core</li> </ul> </li> <li>newtonnet<ul> <li>core</li> <li>ts</li> </ul> </li> <li>onetep<ul> <li>_base</li> <li>core</li> </ul> </li> <li>orca<ul> <li>_base</li> <li>core</li> </ul> </li> <li>psi4<ul> <li>_base</li> <li>core</li> </ul> </li> <li>qchem<ul> <li>_base</li> <li>core</li> <li>ts</li> </ul> </li> <li>tblite<ul> <li>core</li> <li>phonons</li> </ul> </li> <li>torchsim<ul> <li>_base</li> <li>core</li> </ul> </li> <li>vasp<ul> <li>_base</li> <li>core</li> <li>fairchem</li> <li>matpes</li> <li>mof_off</li> <li>mp24</li> <li>mp_legacy</li> <li>qmof</li> <li>slabs</li> </ul> </li> </ul> </li> <li>runners<ul> <li>_base</li> <li>ase</li> <li>generic</li> <li>phonons</li> <li>prep</li> </ul> </li> <li>schemas<ul> <li>ase</li> <li>atoms</li> <li>phonons</li> <li>prep</li> <li>thermo</li> <li>torchsim</li> <li>vasp</li> </ul> </li> <li>settings</li> <li>types</li> <li>utils<ul> <li>dicts</li> <li>files</li> <li>kpts</li> <li>lists</li> </ul> </li> <li>wflow_tools<ul> <li>context</li> <li>customizers</li> <li>decorators</li> <li>job_argument</li> <li>job_patterns</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/quacc/settings.html","title":"settings","text":"<p>Settings for quacc.</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings","title":"QuaccSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Settings for quacc.</p> <p>The default way to modify these is to make a ~/.quacc.yaml file. Alternatively, the environment variable QUACC_CONFIG_FILE can be set to point to a custom yaml file with quacc settings. The quacc CLI offers a <code>quacc set &lt;setting&gt; &lt;value&gt;</code> option to do this as well.</p> <p>The variables can also be modified individually though environment variables by using the \"QUACC\" prefix. e.g. <code>export QUACC_SCRATCH_DIR=/path/to/scratch</code>.</p>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.CHECK_CONVERGENCE","title":"CHECK_CONVERGENCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHECK_CONVERGENCE: bool = Field(\n    True,\n    description=\"Whether to check for convergence, when implemented by a given recipe.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.CONFIG_FILE","title":"CONFIG_FILE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONFIG_FILE: Path = Field(\n    _DEFAULT_CONFIG_FILE_PATH,\n    description=\"\\n            Path to the YAML file to load alternative quacc configuration\\n            defaults from.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.CREATE_UNIQUE_DIR","title":"CREATE_UNIQUE_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CREATE_UNIQUE_DIR: bool = Field(\n    True,\n    description=\"\\n            Whether to have a unique directory in RESULTS_DIR for each job.\\n            Some workflow engines have an option to do this for you already,\\n            in which case you should set this to False.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ESPRESSO_BINARIES","title":"ESPRESSO_BINARIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ESPRESSO_BINARIES: dict[str, str] = Field(\n    {\n        \"pw\": \"pw.x\",\n        \"ph\": \"ph.x\",\n        \"neb\": \"neb.x\",\n        \"q2r\": \"q2r.x\",\n        \"dos\": \"dos.x\",\n        \"matdyn\": \"matdyn.x\",\n        \"dynmat\": \"dynmat.x\",\n        \"bands\": \"bands.x\",\n        \"projwfc\": \"projwfc.x\",\n        \"pp\": \"pp.x\",\n        \"wannier90\": \"wannier90.x\",\n        \"fs\": \"fs.x\",\n        \"postahc\": \"postahc.x\",\n        \"dvscf_q2r\": \"dvscf_q2r.x\",\n    },\n    description=\"Name for each espresso binary.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ESPRESSO_BIN_DIR","title":"ESPRESSO_BIN_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ESPRESSO_BIN_DIR: Path = Field(\n    Path(),\n    description=\"Base path to the espresso binaries.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ESPRESSO_PARALLEL_CMD","title":"ESPRESSO_PARALLEL_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ESPRESSO_PARALLEL_CMD: Union[str, tuple[str, str]] = Field(\n    \"\",\n    description='\\n            Parallelization flags to run Espresso. The 0th index of the tuple\\n            contains any commands that come before the binary, and the 1st index\\n            contains any commands that come after the binary.\\n\\n            For example: [\"mpirun -np 4\", \"-nk 2\"] would be the same as running\\n            Espresso via `\"mpirun -np 4 {binary} -nk 2\"` where {binary} is the\\n            binary that is automatically determined based on the job type,\\n            `ESPRESSO_BIN_DIR` and `ESPRESSO_BINARIES`.\\n\\n            If only a `str` is provided, no post-binary commands will be used.\\n            ',\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ESPRESSO_PRESET_DIR","title":"ESPRESSO_PRESET_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ESPRESSO_PRESET_DIR: Path = Field(\n    parent / \"calculators\" / \"espresso\" / \"presets\",\n    description=\"Path to the espresso preset directory\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ESPRESSO_PSEUDO","title":"ESPRESSO_PSEUDO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ESPRESSO_PSEUDO: Path | None = Field(\n    None,\n    description=\"Path to a pseudopotential library for espresso.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.GAUSSIAN_CMD","title":"GAUSSIAN_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GAUSSIAN_CMD: str = Field(\n    \"g16\", description=\"Path to the Gaussian executable.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.GULP_CMD","title":"GULP_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GULP_CMD: str = Field(\n    \"gulp\", description=\"Path to the GULP executable.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.GULP_LIB","title":"GULP_LIB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GULP_LIB: Path | None = Field(\n    get(\"GULP_LIB\"),\n    description=\"Path to the GULP force field library. If not specified, the GULP_LIB environment variable will be used (if present).\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.GZIP_FILES","title":"GZIP_FILES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GZIP_FILES: bool = Field(\n    True,\n    description=\"Whether generated files should be gzip'd.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.LOG_FILENAME","title":"LOG_FILENAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOG_FILENAME: Path | None = Field(\n    None, description=\"Path to store the log file.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.LOG_LEVEL","title":"LOG_LEVEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOG_LEVEL: Literal[\n    \"CRITICAL\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"\n] = Field(\"INFO\", description=\"Logger level.\")\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.MRCC_CMD","title":"MRCC_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MRCC_CMD: str = Field(\n    \"dmrcc\",\n    description=\"\\n            Path to the MRCC executable.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.NESTED_RESULTS","title":"NESTED_RESULTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NESTED_RESULTS: bool = Field(\n    False,\n    description=\"\\n            Whether to auto-discover sensible paths for output files in\\n            RESULTS_DIR for each flow. The path chosen reflect the relationship\\n            the flow and the subflows/jobs executed within it.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.NEWTONNET_CONFIG_PATH","title":"NEWTONNET_CONFIG_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEWTONNET_CONFIG_PATH: Union[Path, list[Path]] = Field(\n    Path(\"config.yml\"),\n    description=\"Path to NewtonNet YAML settings file\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.NEWTONNET_MODEL_PATH","title":"NEWTONNET_MODEL_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEWTONNET_MODEL_PATH: Union[Path, list[Path]] = Field(\n    Path(\"best_model_state.tar\"),\n    description=\"Path to NewtonNet .tar model\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ONETEP_CMD","title":"ONETEP_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ONETEP_CMD: str = Field(\n    \"onetep.arch\",\n    description=\"Full ONETEP command, including parallelization flags.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ONETEP_PP_PATH","title":"ONETEP_PP_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ONETEP_PP_PATH: Path = Field(\n    Path(), description=\"Path to pseudopotentials.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.ORCA_CMD","title":"ORCA_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORCA_CMD: str = Field(\n    which(\"orca\") or \"orca\",\n    description=\"\\n            Path to the ORCA executable. This must be the full, absolute path\\n            for parallel calculations to work.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.PREFECT_AUTO_SUBMIT","title":"PREFECT_AUTO_SUBMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFECT_AUTO_SUBMIT: bool = Field(\n    True,\n    description=\"Whether to auto-submit tasks to the task runner.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.PREFECT_RESOLVE_FLOW_RESULTS","title":"PREFECT_RESOLVE_FLOW_RESULTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREFECT_RESOLVE_FLOW_RESULTS: bool = Field(\n    True,\n    description=\"Whether to resolve all futures in flow results to data and fail if not possible\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.QCHEM_CMD","title":"QCHEM_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QCHEM_CMD: str = Field(\n    \"qchem\",\n    description=\"Command to run the standard version of Q-Chem.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.QCHEM_CUSTODIAN_MAX_ERRORS","title":"QCHEM_CUSTODIAN_MAX_ERRORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QCHEM_CUSTODIAN_MAX_ERRORS: int = Field(\n    5, description=\"Maximum errors for Q-Chem Custodian.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.QCHEM_LOCAL_SCRATCH","title":"QCHEM_LOCAL_SCRATCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QCHEM_LOCAL_SCRATCH: Path = Field(\n    Path(\"/tmp\") if exists() else cwd() / \".qchem_scratch\",\n    description=\"Compute-node local scratch directory in which Q-Chem should perform IO.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.QCHEM_NBO_EXE","title":"QCHEM_NBO_EXE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QCHEM_NBO_EXE: Path | None = Field(\n    None, description=\"Full path to the NBO executable.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.QCHEM_NUM_CORES","title":"QCHEM_NUM_CORES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QCHEM_NUM_CORES: int = Field(\n    cpu_count(logical=False) or 1,\n    description=\"Number of cores to use for the Q-Chem calculation.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.QCHEM_USE_ERROR_HANDLERS","title":"QCHEM_USE_ERROR_HANDLERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QCHEM_USE_ERROR_HANDLERS: bool = Field(\n    True,\n    description=\"Whether Custodian's error handlers should be employed for Q-Chem.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.RESULTS_DIR","title":"RESULTS_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESULTS_DIR: Path = Field(\n    Path(),\n    description=\"\\n            Directory to permanently store I/O-based calculation results in.\\n            Note that this behavior may be modified by the chosen workflow engine.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.SCRATCH_DIR","title":"SCRATCH_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SCRATCH_DIR: Path | None = Field(\n    None,\n    description=\"\\n            The base directory where calculations are run. If set to None, calculations will be run in a\\n            temporary directory within `RESULTS_DIR`. If a `Path` is supplied, calculations will\\n            be run in a temporary directory within `SCRATCH_DIR`. Files are always moved back\\n            to `RESULTS_DIR` after the calculation is complete, and the temporary directory\\n            in `SCRATCH_DIR` is removed.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_BADER","title":"VASP_BADER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_BADER: bool = Field(\n    bool(which(\"bader\")),\n    description='\"\\n            Whether to run a Bader analysis when summarizing VASP results.\\n            Requires bader to be in PATH.\\n            ',\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CHARGEMOL","title":"VASP_CHARGEMOL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CHARGEMOL: bool = Field(\n    bool(get(\"DDEC6_ATOMIC_DENSITIES_DIR\")),\n    description=\"\\n            Whether to run a Chargemol (i.e. DDEC6, CM5) analysis when summarizing VASP results.\\n            Requires the Chargemol executable to be in PATH and the DDEC6_ATOMIC_DENSITIES_DIR environment variable.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CMD","title":"VASP_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CMD: str = Field(\n    \"vasp_std\",\n    description=\"Command to run the standard version of VASP.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_COPY_MAGMOMS","title":"VASP_COPY_MAGMOMS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_COPY_MAGMOMS: bool = Field(\n    True,\n    description=\"\\n            If True, any pre-existing atoms.get_magnetic_moments() will be set\\n            in atoms.set_initial_magnetic_moments().\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CUSTODIAN_HANDLERS","title":"VASP_CUSTODIAN_HANDLERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CUSTODIAN_HANDLERS: list[str] = Field(\n    [\n        \"VaspErrorHandler\",\n        \"MeshSymmetryErrorHandler\",\n        \"UnconvergedErrorHandler\",\n        \"NonConvergingErrorHandler\",\n        \"PotimErrorHandler\",\n        \"PositiveEnergyErrorHandler\",\n        \"FrozenJobErrorHandler\",\n        \"StdErrHandler\",\n        \"LargeSigmaHandler\",\n        \"IncorrectSmearingHandler\",\n    ],\n    description=\"Handlers for Custodian\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CUSTODIAN_MAX_ERRORS","title":"VASP_CUSTODIAN_MAX_ERRORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CUSTODIAN_MAX_ERRORS: int = Field(\n    5, description=\"Maximum errors for Custodian\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CUSTODIAN_VALIDATORS","title":"VASP_CUSTODIAN_VALIDATORS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CUSTODIAN_VALIDATORS: list[str] = Field(\n    [\"VasprunXMLValidator\", \"VaspFilesValidator\"],\n    description=\"Validators for Custodian\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CUSTODIAN_VTST","title":"VASP_CUSTODIAN_VTST  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CUSTODIAN_VTST: bool = Field(\n    False,\n    description=\"\\n            If VTST-related input swaps should be used when running Custodian.\\n            Requires VASP to be compiled with VTST\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_CUSTODIAN_WALL_TIME","title":"VASP_CUSTODIAN_WALL_TIME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_CUSTODIAN_WALL_TIME: int | None = Field(\n    None,\n    description=\"\\n            After this many seconds, Custodian will stop running\\n            and ensure that VASP writes a STOPCAR\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_GAMMA_CMD","title":"VASP_GAMMA_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_GAMMA_CMD: str = Field(\n    \"vasp_gam\",\n    description=\"Command to run the gamma-point only version of VASP.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_INCAR_COPILOT","title":"VASP_INCAR_COPILOT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_INCAR_COPILOT: Literal[\"off\", \"on\", \"aggressive\"] = (\n    Field(\n        \"on\",\n        description=\"\\n            Controls VASP co-pilot mode for automated INCAR parameter handling.\\n            off: Do not use co-pilot mode. INCAR parameters will be unmodified.\\n            on: Use co-pilot mode. This will only modify INCAR flags not already set by the user.\\n            aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR flags even if they are already set by the user.\\n            \",\n    )\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_MAG_CUTOFF","title":"VASP_MAG_CUTOFF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_MAG_CUTOFF: float = Field(\n    0.02,\n    description=\"\\n            If the absolute value of all magnetic moments are below this value,\\n            they will be set to 0 such that a spin-unpolarized calculation will be performed.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_PARALLEL_CMD","title":"VASP_PARALLEL_CMD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_PARALLEL_CMD: str = Field(\n    \"\",\n    description='\\n            Parallel command to run VASP with Custodian.\\n            For example: `\"srun -N 2 --ntasks-per-node 48\"`.\\n            Note that this does not include the executable name.\\n            ',\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_PP_PATH","title":"VASP_PP_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_PP_PATH: Path | None = Field(\n    get(\"VASP_PP_PATH\"),\n    description=\"Path to the VASP pseudopotential folders.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_PP_VERSION","title":"VASP_PP_VERSION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_PP_VERSION: str | None = Field(\n    get(\"VASP_PP_VERSION\"),\n    description=\"Version of VASP pseudopotentials to use\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_PRESET_DIR","title":"VASP_PRESET_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_PRESET_DIR: Path = Field(\n    parent / \"calculators\" / \"vasp\" / \"presets\",\n    description=\"Path to the VASP preset directory\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_PRESET_MAG_DEFAULT","title":"VASP_PRESET_MAG_DEFAULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_PRESET_MAG_DEFAULT: float = Field(\n    0.5,\n    description=\"\\n            Default initial magmom to use for a given element if a preset\\n            with magmoms is provided but an element is missing from the list.\\n            \",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_USE_CUSTODIAN","title":"VASP_USE_CUSTODIAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_USE_CUSTODIAN: bool = Field(\n    True,\n    description=\"Whether Custodian should be used to run VASP\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.VASP_VDW","title":"VASP_VDW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VASP_VDW: Path | None = Field(\n    get(\"ASE_VASP_VDW\"),\n    description=\"Path to the folder containing the vdw_kernel.bindat file for VASP vdW functionals.\",\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.WORKFLOW_ENGINE","title":"WORKFLOW_ENGINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WORKFLOW_ENGINE: (\n    Literal[\"dask\", \"parsl\", \"prefect\", \"redun\", \"jobflow\"]\n    | None\n) = Field(\n    None, description=\"The workflow manager to use, if any.\"\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    env_prefix=\"quacc_\",\n    env_nested_delimiter=\"__\",\n    env_parse_none_str=\"None\",\n    extra=\"forbid\",\n    validate_assignment=True,\n)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.expand_paths","title":"expand_paths  <code>classmethod</code>","text":"<pre><code>expand_paths(v: Path | None) -&gt; Path | None\n</code></pre> <p>Expand ~/ and $ENV_VARS in paths.</p> Source code in <code>quacc/settings.py</code> <pre><code>@field_validator(\n    \"RESULTS_DIR\",\n    \"SCRATCH_DIR\",\n    \"ESPRESSO_PRESET_DIR\",\n    \"ESPRESSO_PSEUDO\",\n    \"GULP_LIB\",\n    \"QCHEM_LOCAL_SCRATCH\",\n    \"NEWTONNET_MODEL_PATH\",\n    \"VASP_PRESET_DIR\",\n    \"VASP_PP_PATH\",\n    \"VASP_VDW\",\n)\n@classmethod\ndef expand_paths(cls, v: Path | None) -&gt; Path | None:\n    \"\"\"Expand ~/ and $ENV_VARS in paths.\"\"\"\n    if v:\n        v = Path(os.path.expandvars(v)).expanduser()\n    return v\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.load_user_settings","title":"load_user_settings  <code>classmethod</code>","text":"<pre><code>load_user_settings(\n    settings: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Loads settings from a root file if available and uses that as defaults in place of built in defaults. Will also convert common strings to their proper types.</p> <p>Parameters:</p> <ul> <li> <code>settings</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Settings to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Loaded settings.</p> </li> </ul> Source code in <code>quacc/settings.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef load_user_settings(cls, settings: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Loads settings from a root file if available and uses that as defaults in place\n    of built in defaults. Will also convert common strings to their proper types.\n\n    Parameters\n    ----------\n    settings\n        Settings to load.\n\n    Returns\n    -------\n    dict\n        Loaded settings.\n    \"\"\"\n    return _type_handler(cls._use_custom_config_settings(settings))\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.make_directories","title":"make_directories  <code>classmethod</code>","text":"<pre><code>make_directories(v: Path | None) -&gt; Path | None\n</code></pre> <p>Make directories.</p> Source code in <code>quacc/settings.py</code> <pre><code>@field_validator(\"RESULTS_DIR\", \"SCRATCH_DIR\")\n@classmethod\ndef make_directories(cls, v: Path | None) -&gt; Path | None:\n    \"\"\"Make directories.\"\"\"\n    if v:\n        v.mkdir(exist_ok=True, parents=True)\n    return v\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.set_jobflow_settings","title":"set_jobflow_settings","text":"<pre><code>set_jobflow_settings()\n</code></pre> <p>If WORKFLOW_ENGINE is jobflow, ensure that CREATE_UNIQUE_DIR is set to False since Jobflow already handles this for us.</p> Source code in <code>quacc/settings.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_jobflow_settings(self):\n    \"\"\"\n    If WORKFLOW_ENGINE is jobflow, ensure that CREATE_UNIQUE_DIR\n    is set to False since Jobflow already handles this for us.\n    \"\"\"\n    if self.WORKFLOW_ENGINE == \"jobflow\":\n        object.__setattr__(self, \"CREATE_UNIQUE_DIR\", False)\n    return self\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.QuaccSettings.validate_espresso_parallel_cmd","title":"validate_espresso_parallel_cmd  <code>classmethod</code>","text":"<pre><code>validate_espresso_parallel_cmd(\n    v: Union[str, tuple[str, str]],\n) -&gt; tuple[str, str]\n</code></pre> <p>Clean up Espresso parallel command.</p> Source code in <code>quacc/settings.py</code> <pre><code>@field_validator(\"ESPRESSO_PARALLEL_CMD\")\n@classmethod\ndef validate_espresso_parallel_cmd(\n    cls, v: Union[str, tuple[str, str]]\n) -&gt; tuple[str, str]:\n    \"\"\"Clean up Espresso parallel command.\"\"\"\n\n    if isinstance(v, str):\n        v = (v, \"\")\n\n    return v\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.change_settings","title":"change_settings","text":"<pre><code>change_settings(changes: dict[str, Any])\n</code></pre> <p>Temporarily change an attribute of an object.</p> <p>Parameters:</p> <ul> <li> <code>changes</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Dictionary of changes to make formatted as attribute: value.</p> </li> </ul> Source code in <code>quacc/settings.py</code> <pre><code>@contextmanager\ndef change_settings(changes: dict[str, Any]):\n    \"\"\"\n    Temporarily change an attribute of an object.\n\n    Parameters\n    ----------\n    changes\n        Dictionary of changes to make formatted as attribute: value.\n    \"\"\"\n    from quacc import _internally_set_settings, get_settings\n\n    if \"WORKFLOW_ENGINE\" in changes:\n        raise ValueError(\n            \"Cannot change the workflow engine in a context manager. Please use environment variables, e.g. `export QUACC_WORKFLOW_ENGINE=jobflow`, if you need to dynamically change the workflow engine.\"\n        )\n\n    settings = get_settings()\n    original_values = {attr: getattr(settings, attr) for attr in changes}\n\n    _internally_set_settings(changes=changes)\n\n    try:\n        yield\n    finally:\n        _internally_set_settings(changes=original_values)\n</code></pre>"},{"location":"reference/quacc/settings.html#quacc.settings.change_settings_wrap","title":"change_settings_wrap","text":"<pre><code>change_settings_wrap(\n    func: Callable, changes: dict[str, Any]\n) -&gt; Callable\n</code></pre> <p>Wraps a function with the change_settings context manager if not already wrapped.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The function to wrap.</p> </li> <li> <code>changes</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The settings to apply within the context manager.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped function.</p> </li> </ul> Source code in <code>quacc/settings.py</code> <pre><code>def change_settings_wrap(func: Callable, changes: dict[str, Any]) -&gt; Callable:\n    \"\"\"\n    Wraps a function with the change_settings context manager if not already wrapped.\n\n    Parameters\n    ----------\n    func\n        The function to wrap.\n    changes\n        The settings to apply within the context manager.\n\n    Returns\n    -------\n    Callable\n        The wrapped function.\n    \"\"\"\n    original_func = func._original_func if getattr(func, \"_changed\", False) else func\n\n    @wraps(original_func)\n    def wrapper(*args, **kwargs):\n        with change_settings(changes):\n            return original_func(*args, **kwargs)\n\n    wrapper._changed = True\n    wrapper._original_func = original_func\n    return wrapper\n</code></pre>"},{"location":"reference/quacc/types.html","title":"types","text":"<p>Custom types used throughout quacc.</p>"},{"location":"reference/quacc/types.html#quacc.types.Filenames","title":"Filenames  <code>module-attribute</code>","text":"<pre><code>Filenames = str | Path | list[str | Path]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SourceDirectory","title":"SourceDirectory  <code>module-attribute</code>","text":"<pre><code>SourceDirectory = str | Path\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AdsSiteFinderKwargs","title":"AdsSiteFinderKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>ads_site_finder_kwargs</code> in quacc.atoms.slabs.make_adsorbate_structures.</p>"},{"location":"reference/quacc/types.html#quacc.types.AdsSiteFinderKwargs.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AdsSiteFinderKwargs.mi_vec","title":"mi_vec  <code>instance-attribute</code>","text":"<pre><code>mi_vec: ArrayLike | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AdsSiteFinderKwargs.selective_dynamics","title":"selective_dynamics  <code>instance-attribute</code>","text":"<pre><code>selective_dynamics: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AnalysisDoc","title":"AnalysisDoc","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.tasks.AnalysisDoc.</p>"},{"location":"reference/quacc/types.html#quacc.types.AnalysisDoc.delta_volume","title":"delta_volume  <code>instance-attribute</code>","text":"<pre><code>delta_volume: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AnalysisDoc.delta_volume_percent","title":"delta_volume_percent  <code>instance-attribute</code>","text":"<pre><code>delta_volume_percent: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AnalysisDoc.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: list[str]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AnalysisDoc.max_force","title":"max_force  <code>instance-attribute</code>","text":"<pre><code>max_force: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AnalysisDoc.warnings","title":"warnings  <code>instance-attribute</code>","text":"<pre><code>warnings: list[str]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.AtomsSchema","title":"AtomsSchema","text":"<p>               Bases: <code>OptionalAtomsSchema</code></p> <p>Type hint associated with quacc.schemas.atoms.atoms_to_metadata</p>"},{"location":"reference/quacc/types.html#quacc.types.AtomsSchema.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms: Atoms\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.BaderSchema","title":"BaderSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with quacc.schemas.vasp._bader_runner.</p>"},{"location":"reference/quacc/types.html#quacc.types.BaderSchema.atomic_volume","title":"atomic_volume  <code>instance-attribute</code>","text":"<pre><code>atomic_volume: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.BaderSchema.bader_version","title":"bader_version  <code>instance-attribute</code>","text":"<pre><code>bader_version: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.BaderSchema.min_dist","title":"min_dist  <code>instance-attribute</code>","text":"<pre><code>min_dist: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.BaderSchema.partial_charges","title":"partial_charges  <code>instance-attribute</code>","text":"<pre><code>partial_charges: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.BaderSchema.spin_moments","title":"spin_moments  <code>instance-attribute</code>","text":"<pre><code>spin_moments: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CM5Schema","title":"CM5Schema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint used in DDECSchema</p>"},{"location":"reference/quacc/types.html#quacc.types.CM5Schema.partial_charges","title":"partial_charges  <code>instance-attribute</code>","text":"<pre><code>partial_charges: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation","title":"Calculation","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.Calculation.</p>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.bader","title":"bader  <code>instance-attribute</code>","text":"<pre><code>bader: dict\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.calc_type","title":"calc_type  <code>instance-attribute</code>","text":"<pre><code>calc_type: CalcType\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.completed_at","title":"completed_at  <code>instance-attribute</code>","text":"<pre><code>completed_at: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.dir_name","title":"dir_name  <code>instance-attribute</code>","text":"<pre><code>dir_name: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.has_vasp_completed","title":"has_vasp_completed  <code>instance-attribute</code>","text":"<pre><code>has_vasp_completed: TaskState | bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: CalculationInput\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: CalculationOutput\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.output_file_paths","title":"output_file_paths  <code>instance-attribute</code>","text":"<pre><code>output_file_paths: dict[str, str]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.run_type","title":"run_type  <code>instance-attribute</code>","text":"<pre><code>run_type: RunType\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.task_name","title":"task_name  <code>instance-attribute</code>","text":"<pre><code>task_name: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.task_type","title":"task_type  <code>instance-attribute</code>","text":"<pre><code>task_type: TaskType\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Calculation.vasp_version","title":"vasp_version  <code>instance-attribute</code>","text":"<pre><code>vasp_version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput","title":"CalculationInput","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.CalculationInput.</p>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.hubbards","title":"hubbards  <code>instance-attribute</code>","text":"<pre><code>hubbards: dict[str, float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.incar","title":"incar  <code>instance-attribute</code>","text":"<pre><code>incar: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.is_hubbard","title":"is_hubbard  <code>instance-attribute</code>","text":"<pre><code>is_hubbard: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.kpoints","title":"kpoints  <code>instance-attribute</code>","text":"<pre><code>kpoints: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.lattice_rec","title":"lattice_rec  <code>instance-attribute</code>","text":"<pre><code>lattice_rec: Lattice\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.nkpoints","title":"nkpoints  <code>instance-attribute</code>","text":"<pre><code>nkpoints: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.potcar","title":"potcar  <code>instance-attribute</code>","text":"<pre><code>potcar: list[str]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.potcar_spec","title":"potcar_spec  <code>instance-attribute</code>","text":"<pre><code>potcar_spec: list[PotcarSpec]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.potcar_type","title":"potcar_type  <code>instance-attribute</code>","text":"<pre><code>potcar_type: list[str]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationInput.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure: Structure\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput","title":"CalculationOutput","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.CalculationOutput.</p>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.bandgap","title":"bandgap  <code>instance-attribute</code>","text":"<pre><code>bandgap: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.cbm","title":"cbm  <code>instance-attribute</code>","text":"<pre><code>cbm: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.direct_gap","title":"direct_gap  <code>instance-attribute</code>","text":"<pre><code>direct_gap: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.dos_properties","title":"dos_properties  <code>instance-attribute</code>","text":"<pre><code>dos_properties: dict[str, dict[str, dict[str, float]]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.efermi","title":"efermi  <code>instance-attribute</code>","text":"<pre><code>efermi: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.elph_displaced_structures","title":"elph_displaced_structures  <code>instance-attribute</code>","text":"<pre><code>elph_displaced_structures: ElectronPhononDisplacedStructures\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.energy_per_atom","title":"energy_per_atom  <code>instance-attribute</code>","text":"<pre><code>energy_per_atom: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.epsilon_ionic","title":"epsilon_ionic  <code>instance-attribute</code>","text":"<pre><code>epsilon_ionic: ListMatrix3D\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.epsilon_static","title":"epsilon_static  <code>instance-attribute</code>","text":"<pre><code>epsilon_static: ListMatrix3D\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.epsilon_static_wolfe","title":"epsilon_static_wolfe  <code>instance-attribute</code>","text":"<pre><code>epsilon_static_wolfe: ListMatrix3D\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.force_constants","title":"force_constants  <code>instance-attribute</code>","text":"<pre><code>force_constants: list[list[Matrix3D]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.frequency_dependent_dielectric","title":"frequency_dependent_dielectric  <code>instance-attribute</code>","text":"<pre><code>frequency_dependent_dielectric: FrequencyDependentDielectric\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.ionic_steps","title":"ionic_steps  <code>instance-attribute</code>","text":"<pre><code>ionic_steps: list[IonicStep]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.is_gap_direct","title":"is_gap_direct  <code>instance-attribute</code>","text":"<pre><code>is_gap_direct: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.is_metal","title":"is_metal  <code>instance-attribute</code>","text":"<pre><code>is_metal: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.locpot","title":"locpot  <code>instance-attribute</code>","text":"<pre><code>locpot: dict[int, list[float]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.mag_density","title":"mag_density  <code>instance-attribute</code>","text":"<pre><code>mag_density: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.normalmode_eigenvals","title":"normalmode_eigenvals  <code>instance-attribute</code>","text":"<pre><code>normalmode_eigenvals: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.normalmode_eigenvecs","title":"normalmode_eigenvecs  <code>instance-attribute</code>","text":"<pre><code>normalmode_eigenvecs: list[list[Vector3D]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.normalmode_frequencies","title":"normalmode_frequencies  <code>instance-attribute</code>","text":"<pre><code>normalmode_frequencies: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.outcar","title":"outcar  <code>instance-attribute</code>","text":"<pre><code>outcar: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.run_stats","title":"run_stats  <code>instance-attribute</code>","text":"<pre><code>run_stats: RunStatistics\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure: Structure\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.transition","title":"transition  <code>instance-attribute</code>","text":"<pre><code>transition: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CalculationOutput.vbm","title":"vbm  <code>instance-attribute</code>","text":"<pre><code>vbm: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ChargemolSchema","title":"ChargemolSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with quacc.schemas.vasp._chargemol_runner`</p>"},{"location":"reference/quacc/types.html#quacc.types.ChargemolSchema.cm5","title":"cm5  <code>instance-attribute</code>","text":"<pre><code>cm5: CM5Schema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ChargemolSchema.ddec","title":"ddec  <code>instance-attribute</code>","text":"<pre><code>ddec: DDECSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CustodianDoc","title":"CustodianDoc","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.tasks.CustodianDoc.</p>"},{"location":"reference/quacc/types.html#quacc.types.CustodianDoc.corrections","title":"corrections  <code>instance-attribute</code>","text":"<pre><code>corrections: list[Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.CustodianDoc.job","title":"job  <code>instance-attribute</code>","text":"<pre><code>job: dict\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema","title":"DDECSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with quacc.schemas.vasp._ddec_runner.</p>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.bond_order_dict","title":"bond_order_dict  <code>instance-attribute</code>","text":"<pre><code>bond_order_dict: dict\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.bond_order_sums","title":"bond_order_sums  <code>instance-attribute</code>","text":"<pre><code>bond_order_sums: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.dipoles","title":"dipoles  <code>instance-attribute</code>","text":"<pre><code>dipoles: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.partial_charges","title":"partial_charges  <code>instance-attribute</code>","text":"<pre><code>partial_charges: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.rcubed_moments","title":"rcubed_moments  <code>instance-attribute</code>","text":"<pre><code>rcubed_moments: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.rfourth_moments","title":"rfourth_moments  <code>instance-attribute</code>","text":"<pre><code>rfourth_moments: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.rsquared_moments","title":"rsquared_moments  <code>instance-attribute</code>","text":"<pre><code>rsquared_moments: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DDECSchema.spin_moments","title":"spin_moments  <code>instance-attribute</code>","text":"<pre><code>spin_moments: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DefaultSetting","title":"DefaultSetting","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Type hint for when a default setting will be applied</p>"},{"location":"reference/quacc/types.html#quacc.types.DosProperties","title":"DosProperties","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with PhononSchema.</p>"},{"location":"reference/quacc/types.html#quacc.types.DosProperties.frequency_points","title":"frequency_points  <code>instance-attribute</code>","text":"<pre><code>frequency_points: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DosProperties.total_dos","title":"total_dos  <code>instance-attribute</code>","text":"<pre><code>total_dos: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DoubleRelaxSchema","title":"DoubleRelaxSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with the double relaxation jobs.</p>"},{"location":"reference/quacc/types.html#quacc.types.DoubleRelaxSchema.relax1","title":"relax1  <code>instance-attribute</code>","text":"<pre><code>relax1: VaspSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DoubleRelaxSchema.relax2","title":"relax2  <code>instance-attribute</code>","text":"<pre><code>relax2: VaspSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DynSchema","title":"DynSchema","text":"<p>               Bases: <code>RunSchema</code></p> <p>Schema for quacc.schemas.ase.Summarize.md</p>"},{"location":"reference/quacc/types.html#quacc.types.DynSchema.parameters_md","title":"parameters_md  <code>instance-attribute</code>","text":"<pre><code>parameters_md: ParametersDyn\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DynSchema.trajectory","title":"trajectory  <code>instance-attribute</code>","text":"<pre><code>trajectory: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DynSchema.trajectory_log","title":"trajectory_log  <code>instance-attribute</code>","text":"<pre><code>trajectory_log: TrajectoryLog\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.DynSchema.trajectory_results","title":"trajectory_results  <code>instance-attribute</code>","text":"<pre><code>trajectory_results: list[Results]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElasticSchema","title":"ElasticSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Elastic properties and fitting schema</p>"},{"location":"reference/quacc/types.html#quacc.types.ElasticSchema.deformed_results","title":"deformed_results  <code>instance-attribute</code>","text":"<pre><code>deformed_results: list[RunSchema | OptSchema]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElasticSchema.deformed_structure_set","title":"deformed_structure_set  <code>instance-attribute</code>","text":"<pre><code>deformed_structure_set: DeformedStructureSet\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElasticSchema.elasticity_doc","title":"elasticity_doc  <code>instance-attribute</code>","text":"<pre><code>elasticity_doc: ElasticityDoc\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElasticSchema.undeformed_result","title":"undeformed_result  <code>instance-attribute</code>","text":"<pre><code>undeformed_result: RunSchema | OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronPhononDisplacedStructures","title":"ElectronPhononDisplacedStructures","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.ElectronPhononDisplacedStructures.</p>"},{"location":"reference/quacc/types.html#quacc.types.ElectronPhononDisplacedStructures.structures","title":"structures  <code>instance-attribute</code>","text":"<pre><code>structures: list[Structure]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronPhononDisplacedStructures.temperatures","title":"temperatures  <code>instance-attribute</code>","text":"<pre><code>temperatures: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep","title":"ElectronicStep","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.ElectronicStep.</p>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.XCdc","title":"XCdc  <code>instance-attribute</code>","text":"<pre><code>XCdc: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.alphaZ","title":"alphaZ  <code>instance-attribute</code>","text":"<pre><code>alphaZ: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.atom","title":"atom  <code>instance-attribute</code>","text":"<pre><code>atom: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.bandstr","title":"bandstr  <code>instance-attribute</code>","text":"<pre><code>bandstr: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.e_0_energy","title":"e_0_energy  <code>instance-attribute</code>","text":"<pre><code>e_0_energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.e_fr_energy","title":"e_fr_energy  <code>instance-attribute</code>","text":"<pre><code>e_fr_energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.e_wo_entrp","title":"e_wo_entrp  <code>instance-attribute</code>","text":"<pre><code>e_wo_entrp: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.eentropy","title":"eentropy  <code>instance-attribute</code>","text":"<pre><code>eentropy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.ewald","title":"ewald  <code>instance-attribute</code>","text":"<pre><code>ewald: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.hartreedc","title":"hartreedc  <code>instance-attribute</code>","text":"<pre><code>hartreedc: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.pawaedc","title":"pawaedc  <code>instance-attribute</code>","text":"<pre><code>pawaedc: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronicStep.pawpsdc","title":"pawpsdc  <code>instance-attribute</code>","text":"<pre><code>pawpsdc: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronsData","title":"ElectronsData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.ElectronsData.conv_thr","title":"conv_thr  <code>instance-attribute</code>","text":"<pre><code>conv_thr: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronsData.mixing_beta","title":"mixing_beta  <code>instance-attribute</code>","text":"<pre><code>mixing_beta: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ElectronsData.mixing_mode","title":"mixing_mode  <code>instance-attribute</code>","text":"<pre><code>mixing_mode: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase","title":"EmmetBase","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with <code>emmet.core.base.EmmetBaseModel</code>.</p>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase.build_date","title":"build_date  <code>instance-attribute</code>","text":"<pre><code>build_date: datetime\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase.database_version","title":"database_version  <code>instance-attribute</code>","text":"<pre><code>database_version: str | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase.emmet_version","title":"emmet_version  <code>instance-attribute</code>","text":"<pre><code>emmet_version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license: Literal['BY-C', 'BY-NC']\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase.pull_request","title":"pull_request  <code>instance-attribute</code>","text":"<pre><code>pull_request: int | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EmmetBase.pymatgen_version","title":"pymatgen_version  <code>instance-attribute</code>","text":"<pre><code>pymatgen_version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBandsSchema","title":"EspressoBandsSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBandsSchema.bands_pp","title":"bands_pp  <code>instance-attribute</code>","text":"<pre><code>bands_pp: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBandsSchema.bands_pw","title":"bands_pw  <code>instance-attribute</code>","text":"<pre><code>bands_pw: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBandsSchema.fermi_surface","title":"fermi_surface  <code>instance-attribute</code>","text":"<pre><code>fermi_surface: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBaseSet","title":"EspressoBaseSet","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBaseSet.input_data","title":"input_data  <code>instance-attribute</code>","text":"<pre><code>input_data: InputData\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoBaseSet.kspacing","title":"kspacing  <code>instance-attribute</code>","text":"<pre><code>kspacing: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoDosSchema","title":"EspressoDosSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.EspressoDosSchema.dos_job","title":"dos_job  <code>instance-attribute</code>","text":"<pre><code>dos_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoDosSchema.non_scf_job","title":"non_scf_job  <code>instance-attribute</code>","text":"<pre><code>non_scf_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoDosSchema.static_job","title":"static_job  <code>instance-attribute</code>","text":"<pre><code>static_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoPhononDosSchema","title":"EspressoPhononDosSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.EspressoPhononDosSchema.matdyn_job","title":"matdyn_job  <code>instance-attribute</code>","text":"<pre><code>matdyn_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoPhononDosSchema.phonon_job","title":"phonon_job  <code>instance-attribute</code>","text":"<pre><code>phonon_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoPhononDosSchema.q2r_job","title":"q2r_job  <code>instance-attribute</code>","text":"<pre><code>q2r_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoProjwfcSchema","title":"EspressoProjwfcSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.EspressoProjwfcSchema.non_scf_job","title":"non_scf_job  <code>instance-attribute</code>","text":"<pre><code>non_scf_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.EspressoProjwfcSchema.static_job","title":"static_job  <code>instance-attribute</code>","text":"<pre><code>static_job: RunSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs","title":"FindAdsSitesKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>find_ads_sites_kwargs</code> in quacc.atoms.slabs.make_adsorbate_structures.</p>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs.distance","title":"distance  <code>instance-attribute</code>","text":"<pre><code>distance: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs.near_reduce","title":"near_reduce  <code>instance-attribute</code>","text":"<pre><code>near_reduce: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs.no_obtuse_hollow","title":"no_obtuse_hollow  <code>instance-attribute</code>","text":"<pre><code>no_obtuse_hollow: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs.positions","title":"positions  <code>instance-attribute</code>","text":"<pre><code>positions: list[\n    Literal[\"ontop\", \"bridge\", \"hollow\", \"subsurface\"]\n]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs.put_inside","title":"put_inside  <code>instance-attribute</code>","text":"<pre><code>put_inside: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FindAdsSitesKwargs.symm_reduce","title":"symm_reduce  <code>instance-attribute</code>","text":"<pre><code>symm_reduce: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FrequencyDependentDielectric","title":"FrequencyDependentDielectric","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.FrequencyDependentDielectric.</p>"},{"location":"reference/quacc/types.html#quacc.types.FrequencyDependentDielectric.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FrequencyDependentDielectric.imaginary","title":"imaginary  <code>instance-attribute</code>","text":"<pre><code>imaginary: list[list[float]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.FrequencyDependentDielectric.real","title":"real  <code>instance-attribute</code>","text":"<pre><code>real: list[list[float]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicSchema","title":"GeodesicSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicSchema.initial_images","title":"initial_images  <code>instance-attribute</code>","text":"<pre><code>initial_images: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicSchema.relax_product","title":"relax_product  <code>instance-attribute</code>","text":"<pre><code>relax_product: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicSchema.relax_reactant","title":"relax_reactant  <code>instance-attribute</code>","text":"<pre><code>relax_reactant: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicSchema.ts_atoms","title":"ts_atoms  <code>instance-attribute</code>","text":"<pre><code>ts_atoms: Atoms\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicTsSchema","title":"GeodesicTsSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicTsSchema.initial_images","title":"initial_images  <code>instance-attribute</code>","text":"<pre><code>initial_images: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicTsSchema.relax_product","title":"relax_product  <code>instance-attribute</code>","text":"<pre><code>relax_product: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicTsSchema.relax_reactant","title":"relax_reactant  <code>instance-attribute</code>","text":"<pre><code>relax_reactant: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.GeodesicTsSchema.ts_results","title":"ts_results  <code>instance-attribute</code>","text":"<pre><code>ts_results: NewtonNetTSSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.InputData","title":"InputData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.InputData.control","title":"control  <code>instance-attribute</code>","text":"<pre><code>control: NotRequired[dict[str, Any]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.InputData.electrons","title":"electrons  <code>instance-attribute</code>","text":"<pre><code>electrons: ElectronsData\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.InputData.system","title":"system  <code>instance-attribute</code>","text":"<pre><code>system: SystemData\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep","title":"IonicStep","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.IonicStep.</p>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.e_0_energy","title":"e_0_energy  <code>instance-attribute</code>","text":"<pre><code>e_0_energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.e_fr_energy","title":"e_fr_energy  <code>instance-attribute</code>","text":"<pre><code>e_fr_energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.e_wo_entrp","title":"e_wo_entrp  <code>instance-attribute</code>","text":"<pre><code>e_wo_entrp: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.electronic_steps","title":"electronic_steps  <code>instance-attribute</code>","text":"<pre><code>electronic_steps: list[ElectronicStep]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.forces","title":"forces  <code>instance-attribute</code>","text":"<pre><code>forces: list[Vector3D]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.stress","title":"stress  <code>instance-attribute</code>","text":"<pre><code>stress: Matrix3D\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.IonicStep.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure: Structure\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MDParams","title":"MDParams","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>md_params</code> used throughout quacc.</p>"},{"location":"reference/quacc/types.html#quacc.types.MDParams.dynamics","title":"dynamics  <code>instance-attribute</code>","text":"<pre><code>dynamics: MolecularDynamics\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MDParams.dynamics_kwargs","title":"dynamics_kwargs  <code>instance-attribute</code>","text":"<pre><code>dynamics_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MDParams.maxwell_boltzmann_kwargs","title":"maxwell_boltzmann_kwargs  <code>instance-attribute</code>","text":"<pre><code>maxwell_boltzmann_kwargs: (\n    MaxwellBoltzmanDistributionKwargs | None\n)\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MDParams.set_com_stationary","title":"set_com_stationary  <code>instance-attribute</code>","text":"<pre><code>set_com_stationary: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MDParams.set_zero_rotation","title":"set_zero_rotation  <code>instance-attribute</code>","text":"<pre><code>set_zero_rotation: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MDParams.steps","title":"steps  <code>instance-attribute</code>","text":"<pre><code>steps: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCEnergyInfo","title":"MRCCEnergyInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.MRCCEnergyInfo.ccsd_corr_energy","title":"ccsd_corr_energy  <code>instance-attribute</code>","text":"<pre><code>ccsd_corr_energy: float | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCEnergyInfo.ccsdt_corr_energy","title":"ccsdt_corr_energy  <code>instance-attribute</code>","text":"<pre><code>ccsdt_corr_energy: float | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCEnergyInfo.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCEnergyInfo.mp2_corr_energy","title":"mp2_corr_energy  <code>instance-attribute</code>","text":"<pre><code>mp2_corr_energy: float | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCEnergyInfo.scf_energy","title":"scf_energy  <code>instance-attribute</code>","text":"<pre><code>scf_energy: float | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCParamsInfo","title":"MRCCParamsInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.MRCCParamsInfo.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCParamsInfo.mrccblocks","title":"mrccblocks  <code>instance-attribute</code>","text":"<pre><code>mrccblocks: str | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCParamsInfo.mrccinput","title":"mrccinput  <code>instance-attribute</code>","text":"<pre><code>mrccinput: dict[str, str]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MRCCParamsInfo.mult","title":"mult  <code>instance-attribute</code>","text":"<pre><code>mult: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MaxwellBoltzmanDistributionKwargs","title":"MaxwellBoltzmanDistributionKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>maxwell_boltzmann_kwargs</code> in quacc.runners.ase.Runner.run_md.</p>"},{"location":"reference/quacc/types.html#quacc.types.MaxwellBoltzmanDistributionKwargs.force_temp","title":"force_temp  <code>instance-attribute</code>","text":"<pre><code>force_temp: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MaxwellBoltzmanDistributionKwargs.rng","title":"rng  <code>instance-attribute</code>","text":"<pre><code>rng: Generator | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MaxwellBoltzmanDistributionKwargs.temperature_K","title":"temperature_K  <code>instance-attribute</code>","text":"<pre><code>temperature_K: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MeshProperties","title":"MeshProperties","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with PhononSchema.</p>"},{"location":"reference/quacc/types.html#quacc.types.MeshProperties.eigenvectors","title":"eigenvectors  <code>instance-attribute</code>","text":"<pre><code>eigenvectors: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MeshProperties.frequencies","title":"frequencies  <code>instance-attribute</code>","text":"<pre><code>frequencies: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MeshProperties.group_velocities","title":"group_velocities  <code>instance-attribute</code>","text":"<pre><code>group_velocities: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MeshProperties.qpoints","title":"qpoints  <code>instance-attribute</code>","text":"<pre><code>qpoints: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MeshProperties.weights","title":"weights  <code>instance-attribute</code>","text":"<pre><code>weights: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata","title":"MoleculeMetadata","text":"<p>               Bases: <code>EmmetBase</code></p> <p>Type hint associated with emmet.core.structure.MoleculeMetadata</p>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.chemsys","title":"chemsys  <code>instance-attribute</code>","text":"<pre><code>chemsys: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.composition","title":"composition  <code>instance-attribute</code>","text":"<pre><code>composition: Composition\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.composition_reduced","title":"composition_reduced  <code>instance-attribute</code>","text":"<pre><code>composition_reduced: Composition\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.elements","title":"elements  <code>instance-attribute</code>","text":"<pre><code>elements: list[Element]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.formula_alphabetical","title":"formula_alphabetical  <code>instance-attribute</code>","text":"<pre><code>formula_alphabetical: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.formula_anonymous","title":"formula_anonymous  <code>instance-attribute</code>","text":"<pre><code>formula_anonymous: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.formula_pretty","title":"formula_pretty  <code>instance-attribute</code>","text":"<pre><code>formula_pretty: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.natoms","title":"natoms  <code>instance-attribute</code>","text":"<pre><code>natoms: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.nelements","title":"nelements  <code>instance-attribute</code>","text":"<pre><code>nelements: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.MoleculeMetadata.symmetry","title":"symmetry  <code>instance-attribute</code>","text":"<pre><code>symmetry: PointGroupData\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebSchema","title":"NebSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.NebSchema.initial_images","title":"initial_images  <code>instance-attribute</code>","text":"<pre><code>initial_images: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebSchema.neb_results","title":"neb_results  <code>instance-attribute</code>","text":"<pre><code>neb_results: dict\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebSchema.relax_product","title":"relax_product  <code>instance-attribute</code>","text":"<pre><code>relax_product: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebSchema.relax_reactant","title":"relax_reactant  <code>instance-attribute</code>","text":"<pre><code>relax_reactant: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebTsSchema","title":"NebTsSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.NebTsSchema.initial_images","title":"initial_images  <code>instance-attribute</code>","text":"<pre><code>initial_images: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebTsSchema.neb_results","title":"neb_results  <code>instance-attribute</code>","text":"<pre><code>neb_results: dict\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebTsSchema.relax_product","title":"relax_product  <code>instance-attribute</code>","text":"<pre><code>relax_product: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebTsSchema.relax_reactant","title":"relax_reactant  <code>instance-attribute</code>","text":"<pre><code>relax_reactant: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NebTsSchema.ts_results","title":"ts_results  <code>instance-attribute</code>","text":"<pre><code>ts_results: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetIRCSchema","title":"NewtonNetIRCSchema","text":"<p>               Bases: <code>OptSchema</code></p>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetIRCSchema.freq_job","title":"freq_job  <code>instance-attribute</code>","text":"<pre><code>freq_job: VibThermoSchema | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetQuasiIRCSchema","title":"NewtonNetQuasiIRCSchema","text":"<p>               Bases: <code>OptSchema</code></p>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetQuasiIRCSchema.freq_job","title":"freq_job  <code>instance-attribute</code>","text":"<pre><code>freq_job: VibThermoSchema | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetQuasiIRCSchema.irc_job","title":"irc_job  <code>instance-attribute</code>","text":"<pre><code>irc_job: NewtonNetIRCSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetTSSchema","title":"NewtonNetTSSchema","text":"<p>               Bases: <code>OptSchema</code></p>"},{"location":"reference/quacc/types.html#quacc.types.NewtonNetTSSchema.freq_job","title":"freq_job  <code>instance-attribute</code>","text":"<pre><code>freq_job: VibThermoSchema | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams","title":"OptParams","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>opt_params</code> used throughout quacc.</p>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.fmax","title":"fmax  <code>instance-attribute</code>","text":"<pre><code>fmax: float | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.fn_hook","title":"fn_hook  <code>instance-attribute</code>","text":"<pre><code>fn_hook: Callable | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.max_steps","title":"max_steps  <code>instance-attribute</code>","text":"<pre><code>max_steps: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.optimizer","title":"optimizer  <code>instance-attribute</code>","text":"<pre><code>optimizer: Dynamics\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.optimizer_kwargs","title":"optimizer_kwargs  <code>instance-attribute</code>","text":"<pre><code>optimizer_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.relax_cell","title":"relax_cell  <code>instance-attribute</code>","text":"<pre><code>relax_cell: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.run_kwargs","title":"run_kwargs  <code>instance-attribute</code>","text":"<pre><code>run_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptParams.store_intermediate_results","title":"store_intermediate_results  <code>instance-attribute</code>","text":"<pre><code>store_intermediate_results: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptSchema","title":"OptSchema","text":"<p>               Bases: <code>RunSchema</code></p> <p>Schema for quacc.schemas.ase.Summarize.opt</p>"},{"location":"reference/quacc/types.html#quacc.types.OptSchema.converged","title":"converged  <code>instance-attribute</code>","text":"<pre><code>converged: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptSchema.parameters_opt","title":"parameters_opt  <code>instance-attribute</code>","text":"<pre><code>parameters_opt: ParametersDyn\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptSchema.trajectory","title":"trajectory  <code>instance-attribute</code>","text":"<pre><code>trajectory: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptSchema.trajectory_results","title":"trajectory_results  <code>instance-attribute</code>","text":"<pre><code>trajectory_results: list[Results]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptionalAtomsSchema","title":"OptionalAtomsSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with quacc.schemas.atoms.atoms_to_metadata</p>"},{"location":"reference/quacc/types.html#quacc.types.OptionalAtomsSchema.molecule_metadata","title":"molecule_metadata  <code>instance-attribute</code>","text":"<pre><code>molecule_metadata: MoleculeMetadata\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OptionalAtomsSchema.structure_metadata","title":"structure_metadata  <code>instance-attribute</code>","text":"<pre><code>structure_metadata: StructureMetadata\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OrigInputs","title":"OrigInputs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.tasks.OrigInputs.</p>"},{"location":"reference/quacc/types.html#quacc.types.OrigInputs.incar","title":"incar  <code>instance-attribute</code>","text":"<pre><code>incar: Incar\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OrigInputs.kpoints","title":"kpoints  <code>instance-attribute</code>","text":"<pre><code>kpoints: Kpoints\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OrigInputs.poscar","title":"poscar  <code>instance-attribute</code>","text":"<pre><code>poscar: Poscar\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OrigInputs.potcar","title":"potcar  <code>instance-attribute</code>","text":"<pre><code>potcar: Potcar\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc","title":"OutputDoc","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.tasks.OutputDoc.</p>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.bandgap","title":"bandgap  <code>instance-attribute</code>","text":"<pre><code>bandgap: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.density","title":"density  <code>instance-attribute</code>","text":"<pre><code>density: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.energy_per_atom","title":"energy_per_atom  <code>instance-attribute</code>","text":"<pre><code>energy_per_atom: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.forces","title":"forces  <code>instance-attribute</code>","text":"<pre><code>forces: list[list[float]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.stress","title":"stress  <code>instance-attribute</code>","text":"<pre><code>stress: list[list[float]]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.OutputDoc.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure: Structure\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Parameters","title":"Parameters","text":"<p>               Bases: <code>TypedDict</code></p> <p>Dictionary of parameters from atoms.calc.parameters</p>"},{"location":"reference/quacc/types.html#quacc.types.ParametersDyn","title":"ParametersDyn","text":"<p>               Bases: <code>TypedDict</code></p> <p>Dictionary of parameters from Dynamics.todict()</p>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo","title":"ParametersThermo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.n_imag","title":"n_imag  <code>instance-attribute</code>","text":"<pre><code>n_imag: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.pressure","title":"pressure  <code>instance-attribute</code>","text":"<pre><code>pressure: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.sigma","title":"sigma  <code>instance-attribute</code>","text":"<pre><code>sigma: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.spin_multiplicity","title":"spin_multiplicity  <code>instance-attribute</code>","text":"<pre><code>spin_multiplicity: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.vib_energies","title":"vib_energies  <code>instance-attribute</code>","text":"<pre><code>vib_energies: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersThermo.vib_freqs","title":"vib_freqs  <code>instance-attribute</code>","text":"<pre><code>vib_freqs: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersVib","title":"ParametersVib","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.ParametersVib.delta","title":"delta  <code>instance-attribute</code>","text":"<pre><code>delta: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersVib.direction","title":"direction  <code>instance-attribute</code>","text":"<pre><code>direction: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersVib.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersVib.ndof","title":"ndof  <code>instance-attribute</code>","text":"<pre><code>ndof: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ParametersVib.nfree","title":"nfree  <code>instance-attribute</code>","text":"<pre><code>nfree: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononResults","title":"PhononResults","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.PhononResults.force_constants","title":"force_constants  <code>instance-attribute</code>","text":"<pre><code>force_constants: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononResults.mesh_properties","title":"mesh_properties  <code>instance-attribute</code>","text":"<pre><code>mesh_properties: MeshProperties\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononResults.thermal_properties","title":"thermal_properties  <code>instance-attribute</code>","text":"<pre><code>thermal_properties: ThermalProperties\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononResults.total_dos","title":"total_dos  <code>instance-attribute</code>","text":"<pre><code>total_dos: DosProperties\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema","title":"PhononSchema","text":"<p>               Bases: <code>AtomsSchema</code></p> <p>Type hint associated with quacc.schemas.phonons.summarize_phonopy</p>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema.dir_name","title":"dir_name  <code>instance-attribute</code>","text":"<pre><code>dir_name: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema.nid","title":"nid  <code>instance-attribute</code>","text":"<pre><code>nid: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema.phonopy_metadata","title":"phonopy_metadata  <code>instance-attribute</code>","text":"<pre><code>phonopy_metadata: PhonopyMetadata\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema.quacc_version","title":"quacc_version  <code>instance-attribute</code>","text":"<pre><code>quacc_version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhononSchema.results","title":"results  <code>instance-attribute</code>","text":"<pre><code>results: PhononResults\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PhonopyMetadata","title":"PhonopyMetadata","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with PhononSchema.</p>"},{"location":"reference/quacc/types.html#quacc.types.PhonopyMetadata.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PmgKpts","title":"PmgKpts","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>pmg_kpts</code> in quacc.utils.kpts.convert_pmg_kpts.</p>"},{"location":"reference/quacc/types.html#quacc.types.PmgKpts.kppa","title":"kppa  <code>instance-attribute</code>","text":"<pre><code>kppa: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PmgKpts.kppvol","title":"kppvol  <code>instance-attribute</code>","text":"<pre><code>kppvol: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PmgKpts.length_densities","title":"length_densities  <code>instance-attribute</code>","text":"<pre><code>length_densities: tuple[float, float, float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PmgKpts.line_density","title":"line_density  <code>instance-attribute</code>","text":"<pre><code>line_density: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData","title":"PointGroupData","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.symmetry.PointGroupData</p>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData.eigen_tolerance","title":"eigen_tolerance  <code>instance-attribute</code>","text":"<pre><code>eigen_tolerance: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData.linear","title":"linear  <code>instance-attribute</code>","text":"<pre><code>linear: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData.matrix_tolerance","title":"matrix_tolerance  <code>instance-attribute</code>","text":"<pre><code>matrix_tolerance: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData.point_group","title":"point_group  <code>instance-attribute</code>","text":"<pre><code>point_group: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData.rotation_number","title":"rotation_number  <code>instance-attribute</code>","text":"<pre><code>rotation_number: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PointGroupData.tolerance","title":"tolerance  <code>instance-attribute</code>","text":"<pre><code>tolerance: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PotcarSpec","title":"PotcarSpec","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.PotcarSpec.</p>"},{"location":"reference/quacc/types.html#quacc.types.PotcarSpec.hash","title":"hash  <code>instance-attribute</code>","text":"<pre><code>hash: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.PotcarSpec.titel","title":"titel  <code>instance-attribute</code>","text":"<pre><code>titel: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.QchemQuasiIRCSchema","title":"QchemQuasiIRCSchema","text":"<p>               Bases: <code>OptSchema</code></p>"},{"location":"reference/quacc/types.html#quacc.types.QchemQuasiIRCSchema.initial_irc","title":"initial_irc  <code>instance-attribute</code>","text":"<pre><code>initial_irc: OptSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.QchemResults","title":"QchemResults","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for the <code>results</code> attribute in quacc.calculators.qchem.qchem.QChem.</p>"},{"location":"reference/quacc/types.html#quacc.types.QchemResults.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.QchemResults.forces","title":"forces  <code>instance-attribute</code>","text":"<pre><code>forces: NotRequired[NDArray]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.QchemResults.hessian","title":"hessian  <code>instance-attribute</code>","text":"<pre><code>hessian: NotRequired[NDArray]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.QchemResults.taskdoc","title":"taskdoc  <code>instance-attribute</code>","text":"<pre><code>taskdoc: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.Results","title":"Results","text":"<p>               Bases: <code>TypedDict</code></p> <p>Dictionary of results from atoms.calc.results</p>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema","title":"RunSchema","text":"<p>               Bases: <code>AtomsSchema</code></p> <p>Schema for quacc.schemas.ase.Summarize.run</p>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema.dir_name","title":"dir_name  <code>instance-attribute</code>","text":"<pre><code>dir_name: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema.input_atoms","title":"input_atoms  <code>instance-attribute</code>","text":"<pre><code>input_atoms: AtomsSchema | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema.nid","title":"nid  <code>instance-attribute</code>","text":"<pre><code>nid: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: Parameters\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema.quacc_version","title":"quacc_version  <code>instance-attribute</code>","text":"<pre><code>quacc_version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunSchema.results","title":"results  <code>instance-attribute</code>","text":"<pre><code>results: Results\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics","title":"RunStatistics","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.vasp.calculation.RunStatistics.</p>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.average_memory","title":"average_memory  <code>instance-attribute</code>","text":"<pre><code>average_memory: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.cores","title":"cores  <code>instance-attribute</code>","text":"<pre><code>cores: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.elapsed_time","title":"elapsed_time  <code>instance-attribute</code>","text":"<pre><code>elapsed_time: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.max_memory","title":"max_memory  <code>instance-attribute</code>","text":"<pre><code>max_memory: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.system_time","title":"system_time  <code>instance-attribute</code>","text":"<pre><code>system_time: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.total_time","title":"total_time  <code>instance-attribute</code>","text":"<pre><code>total_time: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.RunStatistics.user_time","title":"user_time  <code>instance-attribute</code>","text":"<pre><code>user_time: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata","title":"StructureMetadata","text":"<p>               Bases: <code>EmmetBase</code></p> <p>Type hint associated with emmet.core.structure.StructureMetadata</p>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.chemsys","title":"chemsys  <code>instance-attribute</code>","text":"<pre><code>chemsys: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.composition","title":"composition  <code>instance-attribute</code>","text":"<pre><code>composition: Composition\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.density","title":"density  <code>instance-attribute</code>","text":"<pre><code>density: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.density_atomic","title":"density_atomic  <code>instance-attribute</code>","text":"<pre><code>density_atomic: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.elements","title":"elements  <code>instance-attribute</code>","text":"<pre><code>elements: list[Element]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.formula_anonymous","title":"formula_anonymous  <code>instance-attribute</code>","text":"<pre><code>formula_anonymous: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.formula_pretty","title":"formula_pretty  <code>instance-attribute</code>","text":"<pre><code>formula_pretty: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.nelements","title":"nelements  <code>instance-attribute</code>","text":"<pre><code>nelements: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.nsites","title":"nsites  <code>instance-attribute</code>","text":"<pre><code>nsites: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.symmetry","title":"symmetry  <code>instance-attribute</code>","text":"<pre><code>symmetry: SymmetryData\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.StructureMetadata.volume","title":"volume  <code>instance-attribute</code>","text":"<pre><code>volume: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData","title":"SymmetryData","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with emmet.core.symmetry.SymmetryData</p>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData.crystal_system","title":"crystal_system  <code>instance-attribute</code>","text":"<pre><code>crystal_system: CrystalSystem\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData.number","title":"number  <code>instance-attribute</code>","text":"<pre><code>number: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData.point_group","title":"point_group  <code>instance-attribute</code>","text":"<pre><code>point_group: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData.symbol","title":"symbol  <code>instance-attribute</code>","text":"<pre><code>symbol: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData.symprec","title":"symprec  <code>instance-attribute</code>","text":"<pre><code>symprec: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SymmetryData.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SystemData","title":"SystemData","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.SystemData.degauss","title":"degauss  <code>instance-attribute</code>","text":"<pre><code>degauss: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SystemData.occupations","title":"occupations  <code>instance-attribute</code>","text":"<pre><code>occupations: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.SystemData.smearing","title":"smearing  <code>instance-attribute</code>","text":"<pre><code>smearing: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc","title":"TaskDoc","text":"<p>               Bases: <code>StructureMetadata</code></p> <p>Type hint associated with emmet.core.tasks.TaskDoc.</p>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.additional_json","title":"additional_json  <code>instance-attribute</code>","text":"<pre><code>additional_json: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.analysis","title":"analysis  <code>instance-attribute</code>","text":"<pre><code>analysis: AnalysisDoc\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.author","title":"author  <code>instance-attribute</code>","text":"<pre><code>author: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.calcs_reversed","title":"calcs_reversed  <code>instance-attribute</code>","text":"<pre><code>calcs_reversed: list[Calculation]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.custodian","title":"custodian  <code>instance-attribute</code>","text":"<pre><code>custodian: list[CustodianDoc]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.dir_name","title":"dir_name  <code>instance-attribute</code>","text":"<pre><code>dir_name: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.entry","title":"entry  <code>instance-attribute</code>","text":"<pre><code>entry: ComputedEntry\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.included_objects","title":"included_objects  <code>instance-attribute</code>","text":"<pre><code>included_objects: VaspObject\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.last_updated","title":"last_updated  <code>instance-attribute</code>","text":"<pre><code>last_updated: datetime\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.orig_inputs","title":"orig_inputs  <code>instance-attribute</code>","text":"<pre><code>orig_inputs: OrigInputs\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: OutputDoc\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TaskState\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure: Structure\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags: list[str] | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.task_id","title":"task_id  <code>instance-attribute</code>","text":"<pre><code>task_id: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.task_label","title":"task_label  <code>instance-attribute</code>","text":"<pre><code>task_label: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.task_type","title":"task_type  <code>instance-attribute</code>","text":"<pre><code>task_type: CalcType | TaskType\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.transformations","title":"transformations  <code>instance-attribute</code>","text":"<pre><code>transformations: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TaskDoc.vasp_objects","title":"vasp_objects  <code>instance-attribute</code>","text":"<pre><code>vasp_objects: dict[VaspObject, Any]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermalProperties","title":"ThermalProperties","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with PhononSchema.</p>"},{"location":"reference/quacc/types.html#quacc.types.ThermalProperties.entropy","title":"entropy  <code>instance-attribute</code>","text":"<pre><code>entropy: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermalProperties.free_energy","title":"free_energy  <code>instance-attribute</code>","text":"<pre><code>free_energy: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermalProperties.heat_capacity","title":"heat_capacity  <code>instance-attribute</code>","text":"<pre><code>heat_capacity: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermalProperties.temperatures","title":"temperatures  <code>instance-attribute</code>","text":"<pre><code>temperatures: NDArray\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoResults","title":"ThermoResults","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.ThermoResults.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoResults.enthalpy","title":"enthalpy  <code>instance-attribute</code>","text":"<pre><code>enthalpy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoResults.entropy","title":"entropy  <code>instance-attribute</code>","text":"<pre><code>entropy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoResults.gibbs_energy","title":"gibbs_energy  <code>instance-attribute</code>","text":"<pre><code>gibbs_energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoResults.zpe","title":"zpe  <code>instance-attribute</code>","text":"<pre><code>zpe: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoSchema","title":"ThermoSchema","text":"<p>               Bases: <code>AtomsSchema</code></p>"},{"location":"reference/quacc/types.html#quacc.types.ThermoSchema.parameters_thermo","title":"parameters_thermo  <code>instance-attribute</code>","text":"<pre><code>parameters_thermo: ParametersThermo\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.ThermoSchema.results","title":"results  <code>instance-attribute</code>","text":"<pre><code>results: ThermoResults\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TrajectoryLog","title":"TrajectoryLog","text":"<p>               Bases: <code>TypedDict</code></p> <p>Dictionary of parameters related to the MD trajectory</p>"},{"location":"reference/quacc/types.html#quacc.types.TrajectoryLog.kinetic_energy","title":"kinetic_energy  <code>instance-attribute</code>","text":"<pre><code>kinetic_energy: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TrajectoryLog.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.TrajectoryLog.time","title":"time  <code>instance-attribute</code>","text":"<pre><code>time: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspASEOptSchema","title":"VaspASEOptSchema","text":"<p>               Bases: <code>VaspSchema</code>, <code>OptSchema</code></p> <p>Type hint associated with VASP relaxations run via ASE</p>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs","title":"VaspCustodianKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>custodian_kwargs</code> in quacc.calculators.vasp.vasp_custodian.run_custodian.</p>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.checkpoint","title":"checkpoint  <code>instance-attribute</code>","text":"<pre><code>checkpoint: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.gzipped_output","title":"gzipped_output  <code>instance-attribute</code>","text":"<pre><code>gzipped_output: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.max_errors_per_job","title":"max_errors_per_job  <code>instance-attribute</code>","text":"<pre><code>max_errors_per_job: int | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.monitor_freq","title":"monitor_freq  <code>instance-attribute</code>","text":"<pre><code>monitor_freq: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.polling_time_step","title":"polling_time_step  <code>instance-attribute</code>","text":"<pre><code>polling_time_step: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.skip_over_errors","title":"skip_over_errors  <code>instance-attribute</code>","text":"<pre><code>skip_over_errors: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.terminate_func","title":"terminate_func  <code>instance-attribute</code>","text":"<pre><code>terminate_func: Callable | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspCustodianKwargs.terminate_on_nonzero_returncode","title":"terminate_on_nonzero_returncode  <code>instance-attribute</code>","text":"<pre><code>terminate_on_nonzero_returncode: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs","title":"VaspJobKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>vasp_job_kwargs</code> in in quacc.calculators.vasp.vasp_custodian.run_custodian.</p>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.auto_continue","title":"auto_continue  <code>instance-attribute</code>","text":"<pre><code>auto_continue: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.auto_gamma","title":"auto_gamma  <code>instance-attribute</code>","text":"<pre><code>auto_gamma: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.auto_npar","title":"auto_npar  <code>instance-attribute</code>","text":"<pre><code>auto_npar: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.backup","title":"backup  <code>instance-attribute</code>","text":"<pre><code>backup: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.copy_magmom","title":"copy_magmom  <code>instance-attribute</code>","text":"<pre><code>copy_magmom: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.final","title":"final  <code>instance-attribute</code>","text":"<pre><code>final: bool\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.output_file","title":"output_file  <code>instance-attribute</code>","text":"<pre><code>output_file: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.settings_override","title":"settings_override  <code>instance-attribute</code>","text":"<pre><code>settings_override: dict | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.stderr_file","title":"stderr_file  <code>instance-attribute</code>","text":"<pre><code>stderr_file: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspJobKwargs.suffix","title":"suffix  <code>instance-attribute</code>","text":"<pre><code>suffix: str\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspSchema","title":"VaspSchema","text":"<p>               Bases: <code>RunSchema</code>, <code>TaskDoc</code></p> <p>Type hint associated with quacc.schemas.vasp.VaspSummarize.run</p>"},{"location":"reference/quacc/types.html#quacc.types.VaspSchema.bader","title":"bader  <code>instance-attribute</code>","text":"<pre><code>bader: BaderSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspSchema.chargemol","title":"chargemol  <code>instance-attribute</code>","text":"<pre><code>chargemol: ChargemolSchema\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VaspSchema.steps","title":"steps  <code>instance-attribute</code>","text":"<pre><code>steps: dict[int, TaskDoc]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibKwargs","title":"VibKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint for <code>vib_kwargs</code> in quacc.runners.ase.Runner.run_vib.</p>"},{"location":"reference/quacc/types.html#quacc.types.VibKwargs.delta","title":"delta  <code>instance-attribute</code>","text":"<pre><code>delta: float\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibKwargs.indices","title":"indices  <code>instance-attribute</code>","text":"<pre><code>indices: list[int] | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibKwargs.nfree","title":"nfree  <code>instance-attribute</code>","text":"<pre><code>nfree: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibResults","title":"VibResults","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/types.html#quacc.types.VibResults.imag_vib_freqs","title":"imag_vib_freqs  <code>instance-attribute</code>","text":"<pre><code>imag_vib_freqs: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibResults.n_imag","title":"n_imag  <code>instance-attribute</code>","text":"<pre><code>n_imag: int\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibResults.vib_energies","title":"vib_energies  <code>instance-attribute</code>","text":"<pre><code>vib_energies: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibResults.vib_energies_raw","title":"vib_energies_raw  <code>instance-attribute</code>","text":"<pre><code>vib_energies_raw: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibResults.vib_freqs","title":"vib_freqs  <code>instance-attribute</code>","text":"<pre><code>vib_freqs: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibResults.vib_freqs_raw","title":"vib_freqs_raw  <code>instance-attribute</code>","text":"<pre><code>vib_freqs_raw: list[float]\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibSchema","title":"VibSchema","text":"<p>               Bases: <code>AtomsSchema</code></p>"},{"location":"reference/quacc/types.html#quacc.types.VibSchema.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: Parameters | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibSchema.parameters_vib","title":"parameters_vib  <code>instance-attribute</code>","text":"<pre><code>parameters_vib: ParametersVib | None\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibSchema.results","title":"results  <code>instance-attribute</code>","text":"<pre><code>results: VibResults\n</code></pre>"},{"location":"reference/quacc/types.html#quacc.types.VibThermoSchema","title":"VibThermoSchema","text":"<p>               Bases: <code>VibSchema</code>, <code>ThermoSchema</code></p> <p>Combined Vibrations and Thermo schema</p>"},{"location":"reference/quacc/atoms/core.html","title":"core","text":"<p>Utility functions for dealing with Atoms.</p>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.check_is_metal","title":"check_is_metal","text":"<pre><code>check_is_metal(atoms: Atoms) -&gt; bool\n</code></pre> <p>Checks if a structure is a likely metal.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the structure is likely a metal; False otherwise</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def check_is_metal(atoms: Atoms) -&gt; bool:\n    \"\"\"\n    Checks if a structure is a likely metal.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    bool\n        True if the structure is likely a metal; False otherwise\n    \"\"\"\n    struct = (\n        AseAtomsAdaptor().get_structure(atoms)\n        if atoms.pbc.any()\n        else AseAtomsAdaptor().get_molecule(atoms, charge_spin_check=False)\n    )\n\n    return all(k.is_metal for k in struct.composition)\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.copy_atoms","title":"copy_atoms","text":"<pre><code>copy_atoms(atoms: Atoms) -&gt; Atoms\n</code></pre> <p>Simple function to copy an atoms object to prevent mutability.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code>           \u2013            <p>Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def copy_atoms(atoms: Atoms) -&gt; Atoms:\n    \"\"\"\n    Simple function to copy an atoms object to prevent mutability.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    atoms\n        Atoms object\n    \"\"\"\n    try:\n        atoms = deepcopy(atoms)\n    except Exception:\n        # Needed because of ASE issue #1084\n        calc = atoms.calc\n        atoms = atoms.copy()\n        atoms.calc = calc\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.get_atoms_id","title":"get_atoms_id","text":"<pre><code>get_atoms_id(atoms: Atoms) -&gt; str\n</code></pre> <p>Get a unique identifier for an Atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Unique identifier for the Atoms object in the form of a string</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def get_atoms_id(atoms: Atoms) -&gt; str:\n    \"\"\"\n    Get a unique identifier for an Atoms object.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    str\n        Unique identifier for the Atoms object in the form of a string\n    \"\"\"\n    return _encode_atoms(atoms).hexdigest()\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.get_atoms_id_parsl","title":"get_atoms_id_parsl","text":"<pre><code>get_atoms_id_parsl(\n    atoms: Atoms, output_ref: bool = False\n) -&gt; bytes\n</code></pre> <p>Get a Parsl compatible unique identifier for an Atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>output_ref</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Parsl specific parameter, needed for Parsl to work, unused.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>Unique identifier for the Atoms object in the form of bytes</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def get_atoms_id_parsl(atoms: Atoms, output_ref: bool = False) -&gt; bytes:  # noqa: ARG001\n    \"\"\"\n    Get a Parsl compatible unique identifier for an Atoms object.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    output_ref\n        Parsl specific parameter, needed for Parsl to work, unused.\n\n    Returns\n    -------\n    bytes\n        Unique identifier for the Atoms object in the form of bytes\n    \"\"\"\n    return _encode_atoms(atoms).digest()\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.get_final_atoms_from_dynamics","title":"get_final_atoms_from_dynamics","text":"<pre><code>get_final_atoms_from_dynamics(\n    dynamics: Dynamics | Filter,\n) -&gt; Atoms\n</code></pre> <p>Get the final atoms object from a dynamics run.</p> <p>Parameters:</p> <ul> <li> <code>dynamics</code>               (<code>Dynamics | Filter</code>)           \u2013            <p>ASE dynamics object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def get_final_atoms_from_dynamics(dynamics: Dynamics | Filter) -&gt; Atoms:\n    \"\"\"\n    Get the final atoms object from a dynamics run.\n\n    Parameters\n    ----------\n    dynamics\n        ASE dynamics object\n\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n    return (\n        dynamics.atoms.atoms if isinstance(dynamics.atoms, Filter) else dynamics.atoms\n    )\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.get_spin_multiplicity_attribute","title":"get_spin_multiplicity_attribute","text":"<pre><code>get_spin_multiplicity_attribute(atoms: Atoms) -&gt; int | None\n</code></pre> <p>Get the spin multiplicity of an Atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Spin multiplicity of the Atoms object</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def get_spin_multiplicity_attribute(atoms: Atoms) -&gt; int | None:\n    \"\"\"\n    Get the spin multiplicity of an Atoms object.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n\n    Returns\n    -------\n    int\n        Spin multiplicity of the Atoms object\n    \"\"\"\n    if getattr(atoms, \"spin_multiplicity\", None):\n        return atoms.spin_multiplicity  # type: ignore[attr-defined]\n\n    try:\n        results = atoms.calc.results  # type: ignore[attr-defined]\n    except AttributeError:\n        results = None\n    if results:\n        if results.get(\"magmom\", None) is not None:\n            return round(abs(results[\"magmom\"])) + 1\n        if results.get(\"magmoms\", None) is not None:\n            return round(np.abs(results[\"magmoms\"].sum())) + 1\n\n    if atoms.has(\"initial_magmoms\"):\n        return round(np.abs(atoms.get_initial_magnetic_moments().sum())) + 1\n\n    LOGGER.warning(\"Could not determine spin multiplicity. Assuming 1.\")\n    return 1\n</code></pre>"},{"location":"reference/quacc/atoms/core.html#quacc.atoms.core.perturb","title":"perturb","text":"<pre><code>perturb(\n    mol: Atoms,\n    matrix: list[list[float]] | NDArray,\n    scale: float,\n) -&gt; Atoms\n</code></pre> <p>Perturb each atom in a molecule by a (scaled) 1x3 vector, reflecting e.g. a vibrational normal mode.</p> <p>Parameters:</p> <ul> <li> <code>mol</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object representing a molecule</p> </li> <li> <code>matrix</code>               (<code>list[list[float]] | NDArray</code>)           \u2013            <p>N x 3 matrix, where N is the number of atoms. This means that there is potentially a different translation vector for each atom in the molecule.</p> </li> <li> <code>scale</code>               (<code>float</code>)           \u2013            <p>Scaling factor for perturbation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>The input molecule after perturbation</p> </li> </ul> Source code in <code>quacc/atoms/core.py</code> <pre><code>def perturb(mol: Atoms, matrix: list[list[float]] | NDArray, scale: float) -&gt; Atoms:\n    \"\"\"\n    Perturb each atom in a molecule by a (scaled) 1x3 vector, reflecting e.g. a vibrational normal mode.\n\n    Parameters\n    ----------\n    mol\n        ASE Atoms object representing a molecule\n    matrix\n        N x 3 matrix, where N is the number of atoms. This means that there is potentially a different translation\n        vector for each atom in the molecule.\n    scale\n        Scaling factor for perturbation\n\n    Returns\n    -------\n    Atoms\n        The input molecule after perturbation\n    \"\"\"\n\n    mol_copy = copy_atoms(mol)\n    mode = np.asarray(matrix)\n\n    orig_pos = mol_copy.get_positions()\n\n    pos = orig_pos + mode * scale\n    mol_copy.set_positions(pos)\n\n    return mol_copy\n</code></pre>"},{"location":"reference/quacc/atoms/defects.html","title":"defects","text":"<p>Utility functions for dealing with defects.</p>"},{"location":"reference/quacc/atoms/defects.html#quacc.atoms.defects.has_pmg_defects","title":"has_pmg_defects  <code>module-attribute</code>","text":"<pre><code>has_pmg_defects = bool(\n    find_spec(\"pymatgen.analysis.defects\")\n)\n</code></pre>"},{"location":"reference/quacc/atoms/defects.html#quacc.atoms.defects.has_shakenbreak","title":"has_shakenbreak  <code>module-attribute</code>","text":"<pre><code>has_shakenbreak = bool(find_spec('shakenbreak'))\n</code></pre>"},{"location":"reference/quacc/atoms/defects.html#quacc.atoms.defects.get_defect_entry_from_defect","title":"get_defect_entry_from_defect","text":"<pre><code>get_defect_entry_from_defect(\n    defect: Defect,\n    defect_supercell: Structure,\n    defect_charge: int,\n) -&gt; DefectEntry\n</code></pre> <p>Function to generate DefectEntry object from Defect object.</p> <p>Parameters:</p> <ul> <li> <code>defect</code>               (<code>Defect</code>)           \u2013            <p>defect object</p> </li> <li> <code>defect_supercell</code>               (<code>Structure</code>)           \u2013            <p>defect supercell</p> </li> <li> <code>defect_charge</code>               (<code>int</code>)           \u2013            <p>charge state of defect</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DefectEntry</code>           \u2013            <p>defect entry</p> </li> </ul> Source code in <code>quacc/atoms/defects.py</code> <pre><code>@requires(\n    has_pmg_defects,\n    \"Missing pymatgen-analysis-defects. Please run pip install quacc[defects]\",\n)\ndef get_defect_entry_from_defect(\n    defect: Defect, defect_supercell: Structure, defect_charge: int\n) -&gt; DefectEntry:\n    \"\"\"\n    Function to generate DefectEntry object from Defect object.\n\n    Parameters\n    ----------\n    defect\n        defect object\n    defect_supercell\n        defect supercell\n    defect_charge\n        charge state of defect\n\n    Returns\n    -------\n    DefectEntry\n        defect entry\n    \"\"\"\n    # Find defect's fractional coordinates and remove it from supercell\n    dummy_site = None\n    for site in defect_supercell:\n        if site.species.elements[0].symbol == DummySpecies().symbol:\n            dummy_site = site\n            break\n    if dummy_site is None:\n        raise ValueError(\"No dummy site found in defect supercell.\")\n    defect_supercell.remove(dummy_site)\n\n    computed_structure_entry = ComputedStructureEntry(\n        structure=defect_supercell,\n        energy=0.0,  # needs to be set, so set to 0.0\n    )\n\n    return DefectEntry(\n        defect=defect,\n        charge_state=defect_charge,\n        sc_entry=computed_structure_entry,\n        sc_defect_frac_coords=dummy_site.frac_coords,\n    )\n</code></pre>"},{"location":"reference/quacc/atoms/defects.html#quacc.atoms.defects.make_defects_from_bulk","title":"make_defects_from_bulk","text":"<pre><code>make_defects_from_bulk(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    sc_mat: NDArray | None = None,\n    min_atoms: int = 80,\n    max_atoms: int = 240,\n    min_length: float = 10.0,\n    force_diagonal: bool = False,\n    **defect_gen_kwargs\n) -&gt; list[Atoms]\n</code></pre> <p>Function to make defects from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>bulk atoms</p> </li> <li> <code>defect_gen</code>               (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                   <code>VacancyGenerator</code> )           \u2013            <p>defect generator</p> </li> <li> <code>defect_charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>charge state of defect</p> </li> <li> <code>sc_mat</code>               (<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>supercell matrix</p> </li> <li> <code>min_atoms</code>               (<code>int</code>, default:                   <code>80</code> )           \u2013            <p>minimum number of atoms in supercell</p> </li> <li> <code>max_atoms</code>               (<code>int</code>, default:                   <code>240</code> )           \u2013            <p>maximum number of atoms in supercell</p> </li> <li> <code>min_length</code>               (<code>float</code>, default:                   <code>10.0</code> )           \u2013            <p>minimum length of supercell</p> </li> <li> <code>force_diagonal</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>force supercell to be diagonal</p> </li> <li> <code>**defect_gen_kwargs</code>           \u2013            <p>keyword arguments to pass to the pymatgen.analysis.defects.generators get_defects() method</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>           \u2013            <p>All generated defects</p> </li> </ul> Source code in <code>quacc/atoms/defects.py</code> <pre><code>@requires(\n    has_pmg_defects,\n    \"Missing pymatgen-analysis-defects. Please run pip install quacc[defects]\",\n)\n@requires(has_shakenbreak, \"Missing shakenbreak. Please run pip install quacc[defects]\")\ndef make_defects_from_bulk(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    sc_mat: NDArray | None = None,\n    min_atoms: int = 80,\n    max_atoms: int = 240,\n    min_length: float = 10.0,\n    force_diagonal: bool = False,\n    **defect_gen_kwargs,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Function to make defects from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    defect_gen\n        defect generator\n    defect_charge\n        charge state of defect\n    sc_mat\n        supercell matrix\n    min_atoms\n        minimum number of atoms in supercell\n    max_atoms\n        maximum number of atoms in supercell\n    min_length\n        minimum length of supercell\n    force_diagonal\n        force supercell to be diagonal\n    **defect_gen_kwargs\n        keyword arguments to pass to the pymatgen.analysis.defects.generators\n        get_defects() method\n\n    Returns\n    -------\n    list[Atoms]\n        All generated defects\n    \"\"\"\n    from shakenbreak.input import Distortions\n\n    # Use pymatgen-analysis-defects and ShakeNBreak to generate defects\n    struct = AseAtomsAdaptor.get_structure(atoms)\n\n    # Make all the defects\n    defects = defect_gen().get_defects(struct, **defect_gen_kwargs)\n    final_defects = []\n    for defect in defects:\n        defect.user_charges = [defect_charge]\n\n        # Generate the supercell for a defect\n        defect_supercell = defect.get_supercell_structure(\n            sc_mat=sc_mat,\n            dummy_species=DummySpecies(),\n            min_atoms=min_atoms,\n            max_atoms=max_atoms,\n            min_length=min_length,\n            force_diagonal=force_diagonal,\n        )\n\n        # Generate DefectEntry object from Defect object\n        defect_entry = get_defect_entry_from_defect(\n            defect=defect,\n            defect_supercell=defect_supercell,\n            defect_charge=defect_charge,\n        )\n\n        # Instantiate class to apply rattle and bond distortion to all defects\n        dist = Distortions([defect_entry])\n\n        # Apply rattle and bond distortion to all defects\n        defect_dict, distortion_metadata = dist.apply_distortions()\n        defect_symbol = next(iter(distortion_metadata[\"defects\"].keys()))\n        distortion_dict = defect_dict[defect_symbol][\"charges\"][defect_charge][\n            \"structures\"\n        ][\"distortions\"]\n\n        # Make atoms objects and store defect stats\n        for distortions, defect_struct in distortion_dict.items():\n            final_defect = defect_struct.to_ase_atoms()\n            defect_stats = {\n                \"defect_symbol\": defect_symbol,\n                \"defect_charge\": defect_charge,\n                \"distortions\": distortions,\n                \"bulk\": atoms,\n                \"defect\": defect,\n            }\n            final_defect.info[\"defect_stats\"] = defect_stats\n            final_defects.append(final_defect)\n    return final_defects\n</code></pre>"},{"location":"reference/quacc/atoms/deformation.html","title":"deformation","text":"<p>Utility functions for dealing with deformations.</p>"},{"location":"reference/quacc/atoms/deformation.html#quacc.atoms.deformation.make_deformations_from_bulk","title":"make_deformations_from_bulk","text":"<pre><code>make_deformations_from_bulk(\n    atoms: Atoms,\n    norm_strains: Sequence[float] = (\n        -0.01,\n        -0.005,\n        0.005,\n        0.01,\n    ),\n    shear_strains: Sequence[float] = (\n        -0.06,\n        -0.03,\n        0.03,\n        0.06,\n    ),\n    symmetry: bool = False,\n) -&gt; DeformedStructureSet\n</code></pre> <p>Function to generate deformed structures from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>bulk atoms</p> </li> <li> <code>norm_strains</code>               (<code>Sequence[float]</code>, default:                   <code>(-0.01, -0.005, 0.005, 0.01)</code> )           \u2013            <p>strain values to apply to each normal mode.</p> </li> <li> <code>shear_strains</code>               (<code>Sequence[float]</code>, default:                   <code>(-0.06, -0.03, 0.03, 0.06)</code> )           \u2013            <p>strain values to apply to each shear mode.</p> </li> <li> <code>symmetry</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether or not to use symmetry reduction</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DeformedStructureSet</code>           \u2013            <p>A pymatgen DeformedStructureSet with information on the deformed structures and their strains, useful for fitting later.</p> </li> </ul> Source code in <code>quacc/atoms/deformation.py</code> <pre><code>def make_deformations_from_bulk(\n    atoms: Atoms,\n    norm_strains: Sequence[float] = (-0.01, -0.005, 0.005, 0.01),\n    shear_strains: Sequence[float] = (-0.06, -0.03, 0.03, 0.06),\n    symmetry: bool = False,\n) -&gt; DeformedStructureSet:\n    \"\"\"\n    Function to generate deformed structures from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    norm_strains\n        strain values to apply to each normal mode.\n    shear_strains\n        strain values to apply to each shear mode.\n    symmetry\n        whether or not to use symmetry reduction\n\n    Returns\n    -------\n    DeformedStructureSet\n        A pymatgen DeformedStructureSet with information on the deformed\n        structures and their strains, useful for fitting later.\n    \"\"\"\n    struct = AseAtomsAdaptor.get_structure(atoms)  # type: ignore\n\n    return DeformedStructureSet(\n        struct,\n        norm_strains=norm_strains,\n        shear_strains=shear_strains,\n        symmetry=symmetry,\n    )\n</code></pre>"},{"location":"reference/quacc/atoms/phonons.html","title":"phonons","text":"<p>Atoms handling with Phonopy.</p>"},{"location":"reference/quacc/atoms/phonons.html#quacc.atoms.phonons.has_phonopy","title":"has_phonopy  <code>module-attribute</code>","text":"<pre><code>has_phonopy = bool(find_spec('phonopy'))\n</code></pre>"},{"location":"reference/quacc/atoms/phonons.html#quacc.atoms.phonons.get_atoms_supercell_by_phonopy","title":"get_atoms_supercell_by_phonopy","text":"<pre><code>get_atoms_supercell_by_phonopy(\n    atoms: Atoms,\n    supercell_matrix: tuple[\n        tuple[int, int, int],\n        tuple[int, int, int],\n        tuple[int, int, int],\n    ],\n) -&gt; Atoms\n</code></pre> <p>Get the supercell of an ASE atoms object using a supercell matrix.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE atoms object.</p> </li> <li> <code>supercell_matrix</code>               (<code>tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]</code>)           \u2013            <p>The supercell matrix to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>ASE atoms object of the supercell.</p> </li> </ul> Source code in <code>quacc/atoms/phonons.py</code> <pre><code>@requires(has_phonopy, \"Phonopy not installed.\")\ndef get_atoms_supercell_by_phonopy(\n    atoms: Atoms,\n    supercell_matrix: tuple[\n        tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]\n    ],\n) -&gt; Atoms:\n    \"\"\"\n    Get the supercell of an ASE atoms object using a supercell matrix.\n\n    Parameters\n    ----------\n    atoms\n        ASE atoms object.\n    supercell_matrix\n        The supercell matrix to use.\n\n    Returns\n    -------\n    Atoms\n        ASE atoms object of the supercell.\n    \"\"\"\n    from phonopy.structure.cells import get_supercell\n\n    return phonopy_atoms_to_ase_atoms(\n        get_supercell(\n            get_phonopy_structure(Structure.from_ase_atoms(atoms)), supercell_matrix\n        )\n    )\n</code></pre>"},{"location":"reference/quacc/atoms/phonons.html#quacc.atoms.phonons.get_phonopy","title":"get_phonopy","text":"<pre><code>get_phonopy(\n    atoms: Atoms,\n    min_lengths: (\n        float | tuple[float, float, float] | None\n    ) = None,\n    supercell_matrix: (\n        NDArray\n        | tuple[\n            tuple[int, int, int],\n            tuple[int, int, int],\n            tuple[int, int, int],\n        ]\n        | None\n    ) = None,\n    symprec: float = 1e-05,\n    displacement: float = 0.01,\n    phonopy_kwargs: dict | None = None,\n) -&gt; Phonopy\n</code></pre> <p>Convert an ASE atoms object to a phonopy object with displacements generated.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE atoms object.</p> </li> <li> <code>min_lengths</code>               (<code>float | tuple[float, float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Minimum length of each lattice dimension (A).</p> </li> <li> <code>supercell_matrix</code>               (<code>NDArray | tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The supercell matrix to use. If specified, it will override any value specified by <code>min_lengths</code>.</p> </li> <li> <code>symprec</code>               (<code>float</code>, default:                   <code>1e-05</code> )           \u2013            <p>Precision for symmetry detection.</p> </li> <li> <code>displacement</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Atomic displacement (A).</p> </li> <li> <code>phonopy_kwargs</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional kwargs to pass to the Phonopy class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Phonopy</code>           \u2013            <p>Phonopy object</p> </li> </ul> Source code in <code>quacc/atoms/phonons.py</code> <pre><code>@requires(has_phonopy, \"Phonopy not installed.\")\ndef get_phonopy(\n    atoms: Atoms,\n    min_lengths: float | tuple[float, float, float] | None = None,\n    supercell_matrix: (\n        NDArray\n        | tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]\n        | None\n    ) = None,\n    symprec: float = 1e-5,\n    displacement: float = 0.01,\n    phonopy_kwargs: dict | None = None,\n) -&gt; Phonopy:\n    \"\"\"\n    Convert an ASE atoms object to a phonopy object with displacements generated.\n\n    Parameters\n    ----------\n    atoms\n        ASE atoms object.\n    min_lengths\n        Minimum length of each lattice dimension (A).\n    supercell_matrix\n        The supercell matrix to use. If specified, it will override any\n        value specified by `min_lengths`.\n    symprec\n        Precision for symmetry detection.\n    displacement\n        Atomic displacement (A).\n    phonopy_kwargs\n        Additional kwargs to pass to the Phonopy class.\n\n    Returns\n    -------\n    Phonopy\n        Phonopy object\n    \"\"\"\n    from phonopy import Phonopy\n\n    phonopy_kwargs = phonopy_kwargs or {}\n\n    if supercell_matrix is None and min_lengths is not None:\n        supercell_matrix = np.diag(\n            np.round(np.ceil(min_lengths / atoms.cell.lengths()))\n        )\n\n    phonon = Phonopy(\n        get_phonopy_structure(Structure.from_ase_atoms(atoms)),\n        symprec=symprec,\n        supercell_matrix=supercell_matrix,\n        **phonopy_kwargs,\n    )\n    phonon.generate_displacements(distance=displacement)\n\n    return phonon\n</code></pre>"},{"location":"reference/quacc/atoms/phonons.html#quacc.atoms.phonons.phonopy_atoms_to_ase_atoms","title":"phonopy_atoms_to_ase_atoms","text":"<pre><code>phonopy_atoms_to_ase_atoms(\n    phonopy_atoms: PhonopyAtoms,\n) -&gt; Atoms\n</code></pre> <p>Convert a phonopy atoms object to an ASE atoms object.</p> <p>Parameters:</p> <ul> <li> <code>phonopy_atoms</code>               (<code>PhonopyAtoms</code>)           \u2013            <p>Phonopy atoms object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>ASE atoms object</p> </li> </ul> Source code in <code>quacc/atoms/phonons.py</code> <pre><code>def phonopy_atoms_to_ase_atoms(phonopy_atoms: PhonopyAtoms) -&gt; Atoms:\n    \"\"\"\n    Convert a phonopy atoms object to an ASE atoms object.\n\n    Parameters\n    ----------\n    phonopy_atoms\n        Phonopy atoms object\n\n    Returns\n    -------\n    Atoms\n        ASE atoms object\n    \"\"\"\n    pmg_structure = get_pmg_structure(phonopy_atoms)\n    return pmg_structure.to_ase_atoms()\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html","title":"slabs","text":"<p>Utility functions for dealing with slabs.</p>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.flip_atoms","title":"flip_atoms","text":"<pre><code>flip_atoms(\n    atoms: Atoms, return_struct: bool = False\n) -&gt; Atoms\n</code></pre> <p>Convenience function for vertically flipping periodic atoms.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms to flip</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>Inverted slab</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def flip_atoms(atoms: Atoms, return_struct: bool = False) -&gt; Atoms:\n    \"\"\"\n    Convenience function for vertically flipping periodic atoms.\n\n    Parameters\n    ----------\n    atoms\n        Atoms to flip\n\n    Returns\n    -------\n    Atoms\n        Inverted slab\n    \"\"\"\n    new_atoms = (\n        atoms.to_ase_atoms() if isinstance(atoms, Structure) else copy_atoms(atoms)\n    )\n    new_atoms.rotate(180, \"x\")\n    new_atoms.wrap()\n\n    if return_struct:\n        new_atoms = AseAtomsAdaptor.get_structure(new_atoms)\n\n    return new_atoms\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.flip_structure","title":"flip_structure","text":"<pre><code>flip_structure(\n    struct: Structure | Slab,\n) -&gt; Structure | Slab\n</code></pre> <p>Convenience function for vertically flipping periodic structures.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Structure | Slab</code>)           \u2013            <p>Structure or Slab to flip</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Structure | Slab</code>           \u2013            <p>Inverted slab</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def flip_structure(struct: Structure | Slab) -&gt; Structure | Slab:\n    \"\"\"\n    Convenience function for vertically flipping periodic structures.\n\n    Parameters\n    ----------\n    struct\n        Structure or Slab to flip\n\n    Returns\n    -------\n    Structure | Slab\n        Inverted slab\n    \"\"\"\n    new_atoms = struct.to_ase_atoms()\n    new_atoms.rotate(180, \"x\")\n    new_atoms.wrap()\n\n    return AseAtomsAdaptor.get_structure(new_atoms)\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.get_surface_energy","title":"get_surface_energy","text":"<pre><code>get_surface_energy(\n    bulk: Atoms,\n    slab: Atoms,\n    bulk_energy: float,\n    slab_energy: float,\n) -&gt; float\n</code></pre> <p>Calculate the surface energy to form a given surface slab from a bulk structure. For asymmetric slabs, this is better thought of as the cleavage energy.</p> <p>Parameters:</p> <ul> <li> <code>bulk</code>               (<code>Atoms</code>)           \u2013            <p>The bulk structure.</p> </li> <li> <code>slab</code>               (<code>Atoms</code>)           \u2013            <p>The slab structure.</p> </li> <li> <code>bulk_energy</code>               (<code>float</code>)           \u2013            <p>The total energy of the bulk structure.</p> </li> <li> <code>slab_energy</code>               (<code>float</code>)           \u2013            <p>The total energy of the slab structure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The surface energy in eV/A^2.</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def get_surface_energy(\n    bulk: Atoms, slab: Atoms, bulk_energy: float, slab_energy: float\n) -&gt; float:\n    \"\"\"\n    Calculate the surface energy to form a given surface slab from a bulk structure. For\n    asymmetric slabs, this is better thought of as the cleavage energy.\n\n    Parameters\n    ----------\n    bulk\n        The bulk structure.\n    slab\n        The slab structure.\n    bulk_energy\n        The total energy of the bulk structure.\n    slab_energy\n        The total energy of the slab structure.\n\n    Returns\n    -------\n    float\n        The surface energy in eV/A^2.\n    \"\"\"\n    alpha = len(slab) / len(bulk)\n    cell = slab.get_cell()\n    area = float(np.linalg.norm(np.cross(cell[0], cell[1])))\n    return (slab_energy - alpha * bulk_energy) / (2 * area)\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.make_adsorbate_structures","title":"make_adsorbate_structures","text":"<pre><code>make_adsorbate_structures(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    min_distance: float = 2.0,\n    modes: (\n        list[\n            Literal[\n                \"ontop\", \"bridge\", \"hollow\", \"subsurface\"\n            ]\n        ]\n        | None\n    ) = None,\n    allowed_surface_symbols: list[str] | None = None,\n    allowed_surface_indices: list[int] | None = None,\n    ads_site_finder_kwargs: (\n        AdsSiteFinderKwargs | None\n    ) = None,\n    find_ads_sites_kwargs: FindAdsSitesKwargs | None = None,\n) -&gt; list[Atoms]\n</code></pre> <p>Add a single adsorbate to a structure for every requested adsorption mode.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms to add adsorbates to.</p> </li> <li> <code>adsorbate</code>               (<code>Atoms</code>)           \u2013            <p>The adsorbate to add. Note: It will be placed on the surface in the exact input orientation provided by the user (the adsorption mode is along the c axis and the coordinating atom is the one in the -z direction).</p> </li> <li> <code>min_distance</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The (minimum) distance to set between the adsorbate and the surface site.</p> </li> <li> <code>modes</code>               (<code>list[Literal['ontop', 'bridge', 'hollow', 'subsurface']] | None</code>, default:                   <code>None</code> )           \u2013            <p>The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\", \"hollow\", \"subsurface\".</p> </li> <li> <code>allowed_surface_symbols</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The symbols of surface atoms to consider. If None, will use all surface atoms. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> <code>allowed_surface_indices</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The indices of surface atoms to consider. If None, will use all surface atoms. Generally used if a specific site is to be excluded from the set. Note: This method could be improved for bridge/hollow sites.</p> </li> <li> <code>ads_site_finder_kwargs</code>               (<code>AdsSiteFinderKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>The keyword arguments to pass to the AdsorbateSiteFinder().</p> </li> <li> <code>find_ads_sites_kwargs</code>               (<code>FindAdsSitesKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>The keyword arguments to pass to AdsorbateSiteFinder.find_adsorption_sites().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>           \u2013            <p>The structures with adsorbates</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def make_adsorbate_structures(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    min_distance: float = 2.0,\n    modes: list[Literal[\"ontop\", \"bridge\", \"hollow\", \"subsurface\"]] | None = None,\n    allowed_surface_symbols: list[str] | None = None,\n    allowed_surface_indices: list[int] | None = None,\n    ads_site_finder_kwargs: AdsSiteFinderKwargs | None = None,\n    find_ads_sites_kwargs: FindAdsSitesKwargs | None = None,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Add a single adsorbate to a structure for every requested adsorption mode.\n\n    Parameters\n    ----------\n    atoms\n        The atoms to add adsorbates to.\n    adsorbate\n        The adsorbate to add. Note: It will be placed on the surface in the\n        exact input orientation provided by the user (the adsorption mode is\n        along the c axis and the coordinating atom is the one in the -z\n        direction).\n    min_distance\n        The (minimum) distance to set between the adsorbate and the surface\n        site.\n    modes\n        The adsorption mode(s) to consider. Options include: \"ontop\", \"bridge\",\n        \"hollow\", \"subsurface\".\n    allowed_surface_symbols\n        The symbols of surface atoms to consider. If None, will use all surface\n        atoms. Note: This method could be improved for bridge/hollow sites.\n    allowed_surface_indices\n        The indices of surface atoms to consider. If None, will use all surface\n        atoms. Generally used if a specific site is to be excluded from the set.\n        Note: This method could be improved for bridge/hollow sites.\n    ads_site_finder_kwargs\n        The keyword arguments to pass to the AdsorbateSiteFinder().\n    find_ads_sites_kwargs\n        The keyword arguments to pass to\n        AdsorbateSiteFinder.find_adsorption_sites().\n\n    Returns\n    -------\n    list[Atoms]\n        The structures with adsorbates\n    \"\"\"\n    atoms = copy_atoms(atoms)\n\n    if modes is None:\n        modes = [\"ontop\", \"bridge\", \"hollow\"]\n\n    ads_site_finder_kwargs = ads_site_finder_kwargs or {}\n    find_ads_sites_kwargs = find_ads_sites_kwargs or {}\n\n    # Check for double-used parameters\n    if min_distance and \"distance\" in find_ads_sites_kwargs:\n        msg = \"Cannot specify both min_distance and find_ads_sites_kwargs['distance']\"\n        raise ValueError(msg)\n    if modes and \"positions\" in find_ads_sites_kwargs:\n        msg = \"Cannot specify both modes and find_ads_sites_kwargs['positions']\"\n        raise ValueError(msg)\n    find_ads_sites_kwargs[\"distance\"] = min_distance\n    find_ads_sites_kwargs[\"positions\"] = modes\n\n    # Check the provided surface indices are reasonable\n    atom_indices = [atom.index for atom in atoms]\n    if allowed_surface_indices and any(\n        idx not in atom_indices for idx in allowed_surface_indices\n    ):\n        msg = \"All indices in allowed_surface_indices must be in atoms.\"\n        raise ValueError(msg, allowed_surface_indices, atom_indices)\n\n    # Add 0.0 initial magmoms to atoms/adsorbate if needed\n    if atoms.has(\"initial_magmoms\") and not adsorbate.has(\"initial_magmoms\"):\n        adsorbate.set_initial_magnetic_moments([0.0] * len(adsorbate))\n    if adsorbate.has(\"initial_magmoms\") and not atoms.has(\"initial_magmoms\"):\n        atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\n    # Make a Pymatgen structure and molecule\n    struct = AseAtomsAdaptor.get_structure(atoms)\n    mol = AseAtomsAdaptor.get_molecule(adsorbate, charge_spin_check=False)\n\n    # Get the adsorption sites\n    ads_finder = AdsorbateSiteFinder(struct, **ads_site_finder_kwargs)\n    ads_sites = ads_finder.find_adsorption_sites(**find_ads_sites_kwargs)\n\n    # Find and add the adsorbates\n    new_atoms = []\n    for mode, ads_coords in ads_sites.items():\n        # Check if mode is in desired list\n        if mode not in modes:\n            continue\n\n        for ads_coord in ads_coords:\n            # Place adsorbate\n            struct_with_adsorbate = ads_finder.add_adsorbate(mol, ads_coord)\n\n            # Convert back to Atoms object\n            atoms_with_adsorbate = struct_with_adsorbate.to_ase_atoms()\n\n            # Get distance matrix between adsorbate binding atom and surface\n            d = atoms_with_adsorbate.get_all_distances(mic=True)[\n                0 : len(atoms), len(atoms) :\n            ]\n\n            # Find closest surface atoms\n            min_d = np.min(d)\n            surface_atom_indices = np.where(\n                (d &gt;= min_d - min_d * 0.1) &amp; (d &lt;= min_d + min_d * 0.1)\n            )[0]\n\n            surface_atom_symbols = atoms_with_adsorbate[\n                surface_atom_indices\n            ].get_chemical_symbols()\n\n            # Check if surface binding site is not in the specified user list.\n            # If so, skip this one\n            if allowed_surface_symbols and all(\n                surface_atom_symbol not in allowed_surface_symbols\n                for surface_atom_symbol in surface_atom_symbols\n            ):\n                continue\n\n            if allowed_surface_indices and all(\n                surface_atom_idx not in allowed_surface_indices\n                for surface_atom_idx in surface_atom_indices\n            ):\n                continue\n\n            # Store adsorbate info\n            atoms_with_adsorbate.info = deepcopy(atoms.info)\n            ads_stats = {\n                \"adsorbate\": adsorbate,\n                \"initial_mode\": mode,\n                \"surface_atoms_symbols\": surface_atom_symbols,\n                \"surface_atoms_indices\": surface_atom_indices,\n            }\n            if atoms_with_adsorbate.info.get(\"adsorbates\", None) is None:\n                atoms_with_adsorbate.info[\"adsorbates\"] = [ads_stats]\n            else:\n                atoms_with_adsorbate.info[\"adsorbates\"].extend([ads_stats])\n\n            # Add slab+adsorbate to list\n            atoms_with_adsorbate.wrap()\n            new_atoms.append(atoms_with_adsorbate)\n\n    return new_atoms\n</code></pre>"},{"location":"reference/quacc/atoms/slabs.html#quacc.atoms.slabs.make_slabs_from_bulk","title":"make_slabs_from_bulk","text":"<pre><code>make_slabs_from_bulk(\n    atoms: Atoms,\n    max_index: int = 1,\n    min_slab_size: float = 10.0,\n    min_length_width: float = 8.0,\n    min_vacuum_size: float = 20.0,\n    z_fix: float | None = 2.0,\n    flip_asymmetric: bool = True,\n    allowed_surface_symbols: list[str] | None = None,\n    **slabgen_kwargs\n) -&gt; list[Atoms]\n</code></pre> <p>Function to make slabs from a bulk atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>bulk atoms</p> </li> <li> <code>max_index</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Maximum Miller index for slab generation</p> </li> <li> <code>min_slab_size</code>               (<code>float</code>, default:                   <code>10.0</code> )           \u2013            <p>Minimum slab size (depth) in angstroms</p> </li> <li> <code>min_length_width</code>               (<code>float</code>, default:                   <code>8.0</code> )           \u2013            <p>Minimum length and width of the slab in angstroms</p> </li> <li> <code>min_vacuum_size</code>               (<code>float</code>, default:                   <code>20.0</code> )           \u2013            <p>Minimum vacuum size in angstroms</p> </li> <li> <code>z_fix</code>               (<code>float | None</code>, default:                   <code>2.0</code> )           \u2013            <p>Distance (in angstroms) from top of slab for which atoms should be fixed</p> </li> <li> <code>flip_asymmetric</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If an asymmetric surface should be flipped and added to the list</p> </li> <li> <code>allowed_surface_symbols</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of chemical symbols that must be present on the surface of the slab otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]</p> </li> <li> <code>**slabgen_kwargs</code>           \u2013            <p><code>generate_all_slabs</code> function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>           \u2013            <p>All generated slabs</p> </li> </ul> Source code in <code>quacc/atoms/slabs.py</code> <pre><code>def make_slabs_from_bulk(\n    atoms: Atoms,\n    max_index: int = 1,\n    min_slab_size: float = 10.0,\n    min_length_width: float = 8.0,\n    min_vacuum_size: float = 20.0,\n    z_fix: float | None = 2.0,\n    flip_asymmetric: bool = True,\n    allowed_surface_symbols: list[str] | None = None,\n    **slabgen_kwargs,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Function to make slabs from a bulk atoms object.\n\n    Parameters\n    ----------\n    atoms\n        bulk atoms\n    max_index\n        Maximum Miller index for slab generation\n    min_slab_size\n        Minimum slab size (depth) in angstroms\n    min_length_width\n        Minimum length and width of the slab in angstroms\n    min_vacuum_size\n        Minimum vacuum size in angstroms\n    z_fix\n        Distance (in angstroms) from top of slab for which atoms should be fixed\n    flip_asymmetric\n        If an asymmetric surface should be flipped and added to the list\n    allowed_surface_symbols\n        List of chemical symbols that must be present on the surface of the slab\n        otherwise the slab will be discarded, e.g. [\"Cu\", \"Ni\"]\n    **slabgen_kwargs: keyword arguments to pass to the pymatgen\n        `generate_all_slabs` function\n\n    Returns\n    -------\n    list[Atoms]\n        All generated slabs\n    \"\"\"\n    # Note: This will not work properly for 2D structures. See Oxana/Martin's\n    # code for adjustments for 2D:\n    # https://github.com/oxana-a/atomate/blob/ads_wf/atomate/vasp/firetasks/adsorption_tasks.py\n\n    # Use pymatgen to generate slabs\n    struct = AseAtomsAdaptor.get_structure(atoms)\n\n    # Make all the slabs\n    slabs = generate_all_slabs(\n        struct,\n        max_index,\n        min_slab_size,\n        min_vacuum_size,\n        center_slab=True,\n        **slabgen_kwargs,\n    )\n\n    # If the two terminations are not equivalent, make new slab by inverting the\n    # original slab and add it to the list\n    if flip_asymmetric:\n        new_slabs = []\n        for slab in slabs:\n            if not slab.is_symmetric():\n                # Flip the slab and its oriented unit cell\n                new_slab = flip_structure(slab)\n                new_oriented_unit_cell = flip_structure(slab.oriented_unit_cell)\n\n                # Reconstruct the full slab object, noting the new shift and\n                # oriented unit cell\n                new_slab = Slab(\n                    new_slab.lattice,\n                    new_slab.species,\n                    coords=new_slab.frac_coords,\n                    miller_index=slab.miller_index,\n                    oriented_unit_cell=new_oriented_unit_cell,\n                    shift=-slab.shift,\n                    scale_factor=slab.scale_factor,\n                    site_properties=new_slab.site_properties,\n                )\n\n                # It looks better to center the inverted slab so we do that\n                # here.\n                new_slab = center_slab(new_slab)\n\n                # Add the new slab to the list\n                new_slabs.append(new_slab)\n\n        slabs.extend(new_slabs)\n\n    # For each slab, make sure the lengths and widths are large enough and fix\n    # atoms z_fix away from the top of the slab.\n    slabs_with_props = []\n    for slab in slabs:\n        # Make sure desired atoms are on surface\n        surface_species = []\n        if allowed_surface_symbols:\n            # Find atoms at surface\n            surf_sites = AdsorbateSiteFinder(deepcopy(slab)).surface_sites\n            surface_species = [s.specie.symbol for s in surf_sites]\n\n        if allowed_surface_symbols and all(\n            allowed_surface_atom not in surface_species\n            for allowed_surface_atom in allowed_surface_symbols\n        ):\n            continue\n\n        # Supercell creation (if necessary)\n        a_factor = round(np.ceil(min_length_width / slab.lattice.abc[0]))\n        b_factor = round(np.ceil(min_length_width / slab.lattice.abc[1]))\n        slab.make_supercell([a_factor, b_factor, 1])\n\n        # Add constraints. Note: This does not actually add an adsorbate\n        if z_fix:\n            sel_dyn = AdsorbateSiteFinder(\n                deepcopy(slab), selective_dynamics=True, height=z_fix\n            ).slab.site_properties[\"selective_dynamics\"]\n            slab.add_site_property(\"selective_dynamics\", sel_dyn)\n\n        # Add slab to list\n        slabs_with_props.append(slab)\n\n    final_slabs: list[Atoms] = []\n    if not slabs_with_props:\n        return final_slabs\n\n    # Make atoms objects and store slab stats\n    for slab_with_props in slabs_with_props:\n        final_slab = slab_with_props.to_ase_atoms()\n        slab_stats = {\n            \"bulk\": atoms,\n            \"miller_index\": slab_with_props.miller_index,\n            \"shift\": round(slab_with_props.shift, 3),\n            \"scale_factor\": slab_with_props.scale_factor,\n        }\n        final_slab.info[\"slab_stats\"] = slab_stats\n        final_slabs.append(final_slab)\n\n    return final_slabs\n</code></pre>"},{"location":"reference/quacc/atoms/ts.html","title":"ts","text":""},{"location":"reference/quacc/atoms/ts.html#quacc.atoms.ts.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/atoms/ts.html#quacc.atoms.ts.has_geodesic_interpolate","title":"has_geodesic_interpolate  <code>module-attribute</code>","text":"<pre><code>has_geodesic_interpolate = bool(\n    find_spec(\"geodesic_interpolate\")\n)\n</code></pre>"},{"location":"reference/quacc/atoms/ts.html#quacc.atoms.ts.geodesic_interpolate_wrapper","title":"geodesic_interpolate_wrapper","text":"<pre><code>geodesic_interpolate_wrapper(\n    reactant: Atoms,\n    product: Atoms,\n    n_images: int = 10,\n    perform_sweep: bool | Literal[\"auto\"] = \"auto\",\n    redistribute_tol: float = 0.01,\n    smoother_tol: float = 0.002,\n    max_iterations: int = 15,\n    max_micro_iterations: int = 20,\n    morse_scaling: float = 1.7,\n    geometry_friction: float = 0.01,\n    distance_cutoff: float = 3.0,\n    sweep_cutoff_size: int = 35,\n) -&gt; list[Atoms]\n</code></pre> <p>Interpolates between two geometries and optimizes the path with the geodesic method.</p> <p>Parameters:</p> <ul> <li> <code>reactant</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object representing the initial geometry.</p> </li> <li> <code>product</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object representing the final geometry.</p> </li> <li> <code>n_images</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of images for interpolation. Default is 10.</p> </li> <li> <code>perform_sweep</code>               (<code>bool | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>Whether to sweep across the path optimizing one image at a time. Default is to perform sweeping updates if there are more than 35 atoms.</p> </li> <li> <code>redistribute_tol</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>the value passed to the tol keyword argument of  geodesic_interpolate.interpolation.redistribute. Default is 1e-2.</p> </li> <li> <code>smoother_tol</code>               (<code>float</code>, default:                   <code>0.002</code> )           \u2013            <p>the value passed to the tol keyword argument of geodesic_smoother.smooth or geodesic_smoother.sweep. Default is 2e-3.</p> </li> <li> <code>max_iterations</code>               (<code>int</code>, default:                   <code>15</code> )           \u2013            <p>Maximum number of minimization iterations. Default is 15.</p> </li> <li> <code>max_micro_iterations</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Maximum number of micro iterations for the sweeping algorithm. Default is 20.</p> </li> <li> <code>morse_scaling</code>               (<code>float</code>, default:                   <code>1.7</code> )           \u2013            <p>Exponential parameter for the Morse potential. Default is 1.7.</p> </li> <li> <code>geometry_friction</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Size of friction term used to prevent very large changes in geometry. Default is 1e-2.</p> </li> <li> <code>distance_cutoff</code>               (<code>float</code>, default:                   <code>3.0</code> )           \u2013            <p>Cut-off value for the distance between a pair of atoms to be included in the coordinate system. Default is 3.0.</p> </li> <li> <code>sweep_cutoff_size</code>               (<code>int</code>, default:                   <code>35</code> )           \u2013            <p>Cut off system size that above which sweep function will be called instead of smooth in Geodesic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>           \u2013            <p>A list of ASE Atoms objects representing the smoothed path between the reactant and product geometries.</p> </li> </ul> Source code in <code>quacc/atoms/ts.py</code> <pre><code>@requires(\n    has_geodesic_interpolate,\n    \"geodesic-interpolate must be installed. Refer to the quacc documentation.\",\n)\ndef geodesic_interpolate_wrapper(\n    reactant: Atoms,\n    product: Atoms,\n    n_images: int = 10,\n    perform_sweep: bool | Literal[\"auto\"] = \"auto\",\n    redistribute_tol: float = 1e-2,\n    smoother_tol: float = 2e-3,\n    max_iterations: int = 15,\n    max_micro_iterations: int = 20,\n    morse_scaling: float = 1.7,\n    geometry_friction: float = 1e-2,\n    distance_cutoff: float = 3.0,\n    sweep_cutoff_size: int = 35,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Interpolates between two geometries and optimizes the path with the geodesic method.\n\n    Parameters\n    ----------\n    reactant\n        The ASE Atoms object representing the initial geometry.\n    product\n        The ASE Atoms object representing the final geometry.\n    n_images\n        Number of images for interpolation. Default is 10.\n    perform_sweep\n        Whether to sweep across the path optimizing one image at a time.\n        Default is to perform sweeping updates if there are more than 35 atoms.\n    redistribute_tol\n        the value passed to the tol keyword argument of\n         geodesic_interpolate.interpolation.redistribute. Default is 1e-2.\n    smoother_tol\n        the value passed to the tol keyword argument of geodesic_smoother.smooth\n        or geodesic_smoother.sweep. Default is 2e-3.\n    max_iterations\n        Maximum number of minimization iterations. Default is 15.\n    max_micro_iterations\n        Maximum number of micro iterations for the sweeping algorithm. Default is 20.\n    morse_scaling\n        Exponential parameter for the Morse potential. Default is 1.7.\n    geometry_friction\n        Size of friction term used to prevent very large changes in geometry. Default is 1e-2.\n    distance_cutoff\n        Cut-off value for the distance between a pair of atoms to be included in the coordinate system. Default is 3.0.\n    sweep_cutoff_size\n        Cut off system size that above which sweep function will be called instead of smooth\n        in Geodesic.\n\n    Returns\n    -------\n    list[Atoms]\n        A list of ASE Atoms objects representing the smoothed path between the reactant and product geometries.\n    \"\"\"\n    from geodesic_interpolate.geodesic import Geodesic\n    from geodesic_interpolate.interpolation import redistribute\n\n    reactant = copy_atoms(reactant)\n    product = copy_atoms(product)\n\n    # Read the initial geometries.\n    chemical_symbols = reactant.get_chemical_symbols()\n\n    # First redistribute number of images. Perform interpolation if too few and subsampling if too many images are given\n    raw_interpolated_positions = redistribute(\n        chemical_symbols,\n        [reactant.positions, product.positions],\n        n_images,\n        tol=redistribute_tol,\n    )\n\n    # Perform smoothing by minimizing distance in Cartesian coordinates with redundant internal metric\n    # to find the appropriate geodesic curve on the hyperspace.\n    geodesic_smoother = Geodesic(\n        chemical_symbols,\n        raw_interpolated_positions,\n        morse_scaling,\n        threshold=distance_cutoff,\n        friction=geometry_friction,\n    )\n    if perform_sweep == \"auto\":\n        perform_sweep = len(chemical_symbols) &gt; sweep_cutoff_size\n    if perform_sweep:\n        geodesic_smoother.sweep(\n            tol=smoother_tol, max_iter=max_iterations, micro_iter=max_micro_iterations\n        )\n    else:\n        geodesic_smoother.smooth(tol=smoother_tol, max_iter=max_iterations)\n    return [\n        Atoms(symbols=chemical_symbols, positions=geom)\n        for geom in geodesic_smoother.path\n    ]\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html","title":"espresso","text":"<p>Custom Espresso calculator and template.</p>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.Espresso","title":"Espresso","text":"<pre><code>Espresso(\n    input_atoms: Atoms | None = None,\n    preset: str | Path | None = None,\n    template: EspressoTemplate | None = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>GenericFileIOCalculator</code></p> <p>A wrapper around the ASE Espresso calculator that adjusts input_data parameters and allows for the use of presets. Templates are used to set the binary and input/output file names.</p> <p>Parameters:</p> <ul> <li> <code>input_atoms</code>               (<code>Atoms | None</code>, default:                   <code>None</code> )           \u2013            <p>The input Atoms object to be used for the calculation.</p> </li> <li> <code>preset</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>A YAML file containing a list of parameters to use as a \"preset\" for the calculator. If <code>preset</code> has a .yml or .yaml file extension, the path to this file will be used directly. If <code>preset</code> is a string without an extension, the corresponding YAML file will be assumed to be in the <code>ESPRESSO_PRESET_DIR</code>. Any user-supplied calculator **kwargs will override any corresponding preset values.</p> </li> <li> <code>template</code>               (<code>EspressoTemplate | None</code>, default:                   <code>None</code> )           \u2013            <p>ASE calculator templace which can be used to specify which espresso binary will be used in the calculation. This is taken care of by recipe in most cases.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments to be passed to the Espresso calculator. Takes all valid ASE calculator arguments, such as <code>input_data</code> and <code>kpts</code>. Refer to ase.calculators.espresso.Espresso for details. Note that the full input must be described; use <code>{\"system\":{\"ecutwfc\": 60}}</code> and not the <code>{\"ecutwfc\": 60}</code> short-hand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/espresso/espresso.py</code> <pre><code>def __init__(\n    self,\n    input_atoms: Atoms | None = None,\n    preset: str | Path | None = None,\n    template: EspressoTemplate | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize the Espresso calculator.\n\n    Parameters\n    ----------\n    input_atoms\n        The input Atoms object to be used for the calculation.\n    preset\n        A YAML file containing a list of parameters to use as a \"preset\"\n        for the calculator. If `preset` has a .yml or .yaml file extension, the\n        path to this file will be used directly. If `preset` is a string without\n        an extension, the corresponding YAML file will be assumed to be in the\n        `ESPRESSO_PRESET_DIR`. Any user-supplied calculator **kwargs will\n        override any corresponding preset values.\n    template\n        ASE calculator templace which can be used to specify which espresso\n        binary will be used in the calculation. This is taken care of by recipe\n        in most cases.\n    **kwargs\n        Additional arguments to be passed to the Espresso calculator. Takes all valid\n        ASE calculator arguments, such as `input_data` and `kpts`. Refer to\n        [ase.calculators.espresso.Espresso][] for details. Note that the full input\n        must be described; use `{\"system\":{\"ecutwfc\": 60}}` and not the `{\"ecutwfc\": 60}`\n        short-hand.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.input_atoms = input_atoms or Atoms()\n    self.preset = preset\n    self.kwargs = kwargs\n    self.user_calc_params = {}\n    self._settings = get_settings()\n    template = template or EspressoTemplate(\"pw\")\n    self._binary = template.binary\n    full_path = Path(\n        self._settings.ESPRESSO_BIN_DIR,\n        self._settings.ESPRESSO_BINARIES[self._binary],\n    )\n    self._bin_path = str(full_path)\n\n    if template._ase_known_binary:\n        self._cleanup_params()\n    else:\n        LOGGER.warning(\n            f\"The binary you requested, `{self._binary}`, is not supported by ASE. This means that presets and usual checks will not be carried out, your `input_data` must be provided in nested format.\"\n        )\n\n        self.kwargs[\"input_data\"] = Namelist(self.kwargs.get(\"input_data\"))\n        self.user_calc_params = self.kwargs\n\n    self._pseudo_path = (\n        self.user_calc_params.get(\"input_data\", {})\n        .get(\"control\", {})\n        .get(\"pseudo_dir\", str(self._settings.ESPRESSO_PSEUDO))\n    )\n\n    cmd_prefix = os.environ.get(\n        \"PARSL_MPI_PREFIX\", self._settings.ESPRESSO_PARALLEL_CMD[0]\n    )\n    cmd_suffix = self._settings.ESPRESSO_PARALLEL_CMD[1]\n\n    profile = EspressoProfile(\n        f\"{cmd_prefix} {self._bin_path} {cmd_suffix}\", self._pseudo_path\n    )\n\n    super().__init__(\n        template=template,\n        profile=profile,\n        directory=\".\",\n        parameters=self.user_calc_params,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.Espresso.input_atoms","title":"input_atoms  <code>instance-attribute</code>","text":"<pre><code>input_atoms = input_atoms or Atoms()\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.Espresso.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs = kwargs\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.Espresso.preset","title":"preset  <code>instance-attribute</code>","text":"<pre><code>preset = preset\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.Espresso.user_calc_params","title":"user_calc_params  <code>instance-attribute</code>","text":"<pre><code>user_calc_params = {}\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate","title":"EspressoTemplate","text":"<pre><code>EspressoTemplate(\n    binary: str = \"pw\",\n    test_run: bool = False,\n    autorestart: bool = False,\n    outdir: str | Path | None = None,\n)\n</code></pre> <p>               Bases: <code>EspressoTemplate</code></p> <p>A wrapper around the ASE Espresso template that allows for the use of other binaries such as pw.x, ph.x, cp.x, etc.</p> <p>Parameters:</p> <ul> <li> <code>binary</code>               (<code>str</code>, default:                   <code>'pw'</code> )           \u2013            <p>The name of the espresso binary to use. This is used to set the input/output file names. By default we fall back to \"pw\".</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>autorestart</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the calculation will automatically switch to 'restart' if this calculator performs more than one run. (ASE-relax/MD/NEB)</p> </li> <li> <code>outdir</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The directory that will be used as <code>outdir</code> in the input_data. If None, the directory will be set to the current working directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/espresso/espresso.py</code> <pre><code>def __init__(\n    self,\n    binary: str = \"pw\",\n    test_run: bool = False,\n    autorestart: bool = False,\n    outdir: str | Path | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Espresso template.\n\n    Parameters\n    ----------\n    binary\n        The name of the espresso binary to use. This is used to set the\n        input/output file names. By default we fall back to \"pw\".\n    test_run\n        If True, a test run is performed to check that the calculation\n        input_data is correct or to generate some files/info if needed.\n    autorestart\n        If True, the calculation will automatically switch to 'restart'\n        if this calculator performs more than one run. (ASE-relax/MD/NEB)\n    outdir\n        The directory that will be used as `outdir` in the input_data. If\n        None, the directory will be set to the current working directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__()\n\n    self.inputname = f\"{binary}.in\"\n    self.outputname = f\"{binary}.out\"\n    self.errorname = f\"{binary}.err\"\n    self.binary = binary\n    self._ase_known_binary = self.binary in ALL_KEYS\n    self.test_run = test_run\n    self.nruns = 0\n    self.autorestart = autorestart\n    self.outdir = outdir\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.autorestart","title":"autorestart  <code>instance-attribute</code>","text":"<pre><code>autorestart = autorestart\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.binary","title":"binary  <code>instance-attribute</code>","text":"<pre><code>binary = binary\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.errorname","title":"errorname  <code>instance-attribute</code>","text":"<pre><code>errorname = f'{binary}.err'\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.inputname","title":"inputname  <code>instance-attribute</code>","text":"<pre><code>inputname = f'{binary}.in'\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.nruns","title":"nruns  <code>instance-attribute</code>","text":"<pre><code>nruns = 0\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.outdir","title":"outdir  <code>instance-attribute</code>","text":"<pre><code>outdir = outdir\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.outputname","title":"outputname  <code>instance-attribute</code>","text":"<pre><code>outputname = f'{binary}.out'\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.test_run","title":"test_run  <code>instance-attribute</code>","text":"<pre><code>test_run = test_run\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.execute","title":"execute","text":"<pre><code>execute(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>quacc/calculators/espresso/espresso.py</code> <pre><code>def execute(self, *args: Any, **kwargs: Any) -&gt; None:\n    super().execute(*args, **kwargs)\n    self.nruns += 1\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.read_results","title":"read_results","text":"<pre><code>read_results(directory: PathLike) -&gt; dict[str, Any]\n</code></pre> <p>The function that should be used instead of the one in ASE EspressoTemplate to read the output file. It calls a customly defined read function. It also adds the \"energy\" key to the results dictionnary if it is not present. This is needed if the calculation is not made with pw.x.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>PathLike</code>)           \u2013            <p>The directory in which to read the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The results dictionnary</p> </li> </ul> Source code in <code>quacc/calculators/espresso/espresso.py</code> <pre><code>def read_results(self, directory: os.PathLike) -&gt; dict[str, Any]:\n    \"\"\"\n    The function that should be used instead of the one in ASE EspressoTemplate to\n    read the output file. It calls a customly defined read function. It also adds\n    the \"energy\" key to the results dictionnary if it is not present. This is needed\n    if the calculation is not made with pw.x.\n\n    Parameters\n    ----------\n    directory\n        The directory in which to read the output file.\n\n    Returns\n    -------\n    dict\n        The results dictionnary\n    \"\"\"\n    results = {}\n    if self.binary == \"pw\":\n        atoms = read(Path(directory) / self.outputname, format=\"espresso-out\")\n        results = dict(atoms.calc.properties())\n    elif self.binary in [\"ph\", \"phcg\"]:\n        with Path(directory, self.outputname).open() as fd:\n            results = read_espresso_ph(fd)\n    elif self.binary == \"dos\":\n        with Path(directory, \"pwscf.dos\").open() as fd:\n            lines = fd.readlines()\n            match = re.search(r\"-?\\d+\\.?\\d*\", lines[0])\n            fermi = float(match.group(0)) if match else None\n            dos = np.loadtxt(lines[1:])\n        results = {\"dos_results\": {\"dos\": dos, \"fermi\": fermi}}\n    elif self.binary == \"projwfc\":\n        with Path(directory, \"pwscf.pdos_tot\").open() as fd:\n            lines = np.loadtxt(fd.readlines())\n            energy = lines[1:, 0]\n            dos = lines[1:, 1]\n            pdos = lines[1:, 2]\n        results = {\"projwfc_results\": {\"energy\": energy, \"dos\": dos, \"pdos\": pdos}}\n    elif self.binary == \"matdyn\":\n        fldos = Path(directory, \"matdyn.dos\")\n        if fldos.exists():\n            phonon_dos = np.loadtxt(fldos)\n            results = {\"matdyn_results\": {\"phonon_dos\": phonon_dos}}\n\n    if \"energy\" not in results:\n        results[\"energy\"] = None\n\n    return results\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/espresso.html#quacc.calculators.espresso.espresso.EspressoTemplate.write_input","title":"write_input","text":"<pre><code>write_input(\n    profile: EspressoProfile,\n    directory: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, Any],\n    properties: Any,\n) -&gt; None\n</code></pre> <p>The function that should be used instead of the one in ASE EspressoTemplate to write the input file. It calls a customly defined write function.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>EspressoProfile</code>)           \u2013            <p>The profile to use.</p> </li> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which to write the input file.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to use.</p> </li> <li> <code>parameters</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The parameters to use.</p> </li> <li> <code>properties</code>               (<code>Any</code>)           \u2013            <p>Special ASE properties</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/espresso/espresso.py</code> <pre><code>def write_input(\n    self,\n    profile: EspressoProfile,\n    directory: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, Any],\n    properties: Any,\n) -&gt; None:\n    \"\"\"\n    The function that should be used instead of the one in ASE EspressoTemplate to\n    write the input file. It calls a customly defined write function.\n\n    Parameters\n    ----------\n    profile\n        The profile to use.\n    directory\n        The directory in which to write the input file.\n    atoms\n        The atoms object to use.\n    parameters\n        The parameters to use.\n    properties\n        Special ASE properties\n\n    Returns\n    -------\n    None\n    \"\"\"\n    directory = Path(directory)\n    self._output_handler(parameters, directory)\n    parameters = self._sanity_checks(parameters)\n\n    if self.outdir:\n        safe_decompress_dir(self.outdir)\n\n    if self.test_run:\n        self._test_run(parameters, directory)\n\n    if self.binary == \"pw\":\n        if self.autorestart and self.nruns &gt; 0:\n            parameters[\"input_data\"][\"electrons\"][\"startingpot\"] = \"file\"\n            parameters[\"input_data\"][\"electrons\"][\"startingwfc\"] = \"file\"\n        write(\n            directory / self.inputname,\n            atoms,\n            format=\"espresso-in\",\n            pseudo_dir=str(profile.pseudo_dir),\n            properties=properties,\n            **parameters,\n        )\n    elif self.binary in [\"ph\", \"phcg\"]:\n        with Path(directory, self.inputname).open(mode=\"w\") as fd:\n            write_espresso_ph(fd, properties=properties, **parameters)\n    else:\n        with Path(directory, self.inputname).open(mode=\"w\") as fd:\n            write_fortran_namelist(\n                fd,\n                binary=self.binary if self._ase_known_binary else None,\n                properties=properties,\n                **parameters,\n            )\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html","title":"utils","text":""},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.espresso_prepare_dir","title":"espresso_prepare_dir","text":"<pre><code>espresso_prepare_dir(\n    outdir: str | Path, binary: str = \"pw\"\n) -&gt; dict[str, Any]\n</code></pre> <p>Function that prepares the espresso dictionary for the calculation.</p> <p>Parameters:</p> <ul> <li> <code>outdir</code>               (<code>str | Path</code>)           \u2013            <p>The output to be used for the espresso calculation</p> </li> <li> <code>binary</code>               (<code>str</code>, default:                   <code>'pw'</code> )           \u2013            <p>The binary to be used for the espresso calculation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Input data for the espresso calculation</p> </li> </ul> Source code in <code>quacc/calculators/espresso/utils.py</code> <pre><code>def espresso_prepare_dir(outdir: str | Path, binary: str = \"pw\") -&gt; dict[str, Any]:\n    \"\"\"\n    Function that prepares the espresso dictionary for the calculation.\n\n    Parameters\n    ----------\n    outdir\n        The output to be used for the espresso calculation\n    binary\n        The binary to be used for the espresso calculation\n\n    Returns\n    -------\n    dict[str, Any]\n        Input data for the espresso calculation\n    \"\"\"\n    outkeys = {\n        \"pw\": {\"control\": {\"prefix\": \"pwscf\", \"outdir\": outdir, \"wfcdir\": Remove}},\n        \"ph\": {\n            \"inputph\": {\n                \"prefix\": \"pwscf\",\n                \"fildyn\": \"matdyn\",\n                \"outdir\": outdir,\n                \"ahc_dir\": Remove,\n                \"wpot_dir\": Remove,\n                \"dvscf_star%dir\": Remove,\n                \"drho_star%dir\": Remove,\n            }\n        },\n        \"pp\": {\"inputpp\": {\"prefix\": \"pwscf\", \"filplot\": \"tmp.pp\", \"outdir\": outdir}},\n        \"dos\": {\"dos\": {\"prefix\": \"pwscf\", \"fildos\": \"pwscf.dos\", \"outdir\": outdir}},\n        \"projwfc\": {\n            \"projwfc\": {\"prefix\": \"pwscf\", \"filpdos\": \"pwscf\", \"outdir\": outdir}\n        },\n        \"matdyn\": {\n            \"input\": {\n                \"flfrc\": \"q2r.fc\",\n                \"fldos\": \"matdyn.dos\",\n                \"flfrq\": \"matdyn.freq\",\n                \"flvec\": \"matdyn.modes\",\n                \"fleig\": \"matdyn.eig\",\n            }\n        },\n        \"q2r\": {\"input\": {\"fildyn\": \"matdyn\", \"flfrc\": \"q2r.fc\"}},\n        \"bands\": {\n            \"bands\": {\"prefix\": \"pwscf\", \"filband\": \"bands.dat\", \"outdir\": outdir}\n        },\n        \"fs\": {\n            \"fermi\": {\n                \"prefix\": \"pwscf\",\n                \"file_fs\": \"fermi_surface.bxsf\",\n                \"outdir\": outdir,\n            }\n        },\n        \"dvscf_q2r\": {\n            \"input\": {\n                \"prefix\": \"pwscf\",\n                \"fildyn\": \"matdyn\",\n                \"outdir\": outdir,\n                \"wpot_dir\": Remove,\n            }\n        },\n        \"postahc\": {\"input\": {\"ahc_dir\": \"ahc_dir/\", \"flvec\": \"matdyn.modes\"}},\n    }\n\n    return outkeys.get(binary, {})\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.get_pseudopotential_info","title":"get_pseudopotential_info","text":"<pre><code>get_pseudopotential_info(\n    pp_dict: dict[str, Any], atoms: Atoms\n) -&gt; tuple[float, float, dict[str, str]]\n</code></pre> <p>Function that parses the pseudopotentials and cutoffs from a preset file. The cutoffs are taken from the largest value of the cutoffs among the elements present.</p> <p>Parameters:</p> <ul> <li> <code>pp_dict</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The \"pseudopotential\" parameters returned by load_yaml_calc</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object to get the elements from</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The max(ecutwfc) value</p> </li> <li> <code>float</code>           \u2013            <p>The max(ecutrho) value</p> </li> <li> <code>dict[str, str]</code>           \u2013            <p>The pseudopotentials dictionary, e.g. {\"O\": \"O.pbe-n-kjpaw_psl.0.1.UPF\"}</p> </li> </ul> Source code in <code>quacc/calculators/espresso/utils.py</code> <pre><code>def get_pseudopotential_info(\n    pp_dict: dict[str, Any], atoms: Atoms\n) -&gt; tuple[float, float, dict[str, str]]:\n    \"\"\"\n    Function that parses the pseudopotentials and cutoffs from a preset file. The\n    cutoffs are taken from the largest value of the cutoffs among the elements present.\n\n    Parameters\n    ----------\n    pp_dict\n        The \"pseudopotential\" parameters returned by load_yaml_calc\n    atoms\n        The atoms object to get the elements from\n\n    Returns\n    -------\n    float\n        The max(ecutwfc) value\n    float\n        The max(ecutrho) value\n    dict[str, str]\n        The pseudopotentials dictionary, e.g. {\"O\": \"O.pbe-n-kjpaw_psl.0.1.UPF\"}\n    \"\"\"\n    unique_elements = list(set(atoms.get_chemical_symbols()))\n    ecutwfc, ecutrho = 0, 0\n    pseudopotentials = {}\n    for element in unique_elements:\n        if pp_dict[element][\"cutoff_wfc\"] &gt; ecutwfc:\n            ecutwfc = pp_dict[element][\"cutoff_wfc\"]\n        if pp_dict[element][\"cutoff_rho\"] &gt; ecutrho:\n            ecutrho = pp_dict[element][\"cutoff_rho\"]\n        pseudopotentials[element] = pp_dict[element][\"filename\"]\n    return ecutwfc, ecutrho, pseudopotentials\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.grid_copy_files","title":"grid_copy_files","text":"<pre><code>grid_copy_files(\n    ph_input_data: dict[str, Any],\n    directory: str | Path,\n    qnum: int,\n    qpt: tuple[float, float, float],\n) -&gt; dict[SourceDirectory, Filenames]\n</code></pre> <p>Function that returns a dictionary of files to copy for the grid calculation.</p> <p>Parameters:</p> <ul> <li> <code>ph_input_data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The input data for the ph calculation</p> </li> <li> <code>directory</code>               (<code>str | Path</code>)           \u2013            <p>The directory name to copy the files from</p> </li> <li> <code>qnum</code>               (<code>int</code>)           \u2013            <p>The q-point number</p> </li> <li> <code>qpt</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The q-point coordinates in QE units</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[SourceDirectory, Filenames]</code>           \u2013            <p>The dictionary of files to copy</p> </li> </ul> Source code in <code>quacc/calculators/espresso/utils.py</code> <pre><code>def grid_copy_files(\n    ph_input_data: dict[str, Any],\n    directory: str | Path,\n    qnum: int,\n    qpt: tuple[float, float, float],\n) -&gt; dict[SourceDirectory, Filenames]:\n    \"\"\"\n    Function that returns a dictionary of files to copy for the grid calculation.\n\n    Parameters\n    ----------\n    ph_input_data\n        The input data for the ph calculation\n    directory\n        The directory name to copy the files from\n    qnum\n        The q-point number\n    qpt\n        The q-point coordinates in QE units\n\n    Returns\n    -------\n    dict[SourceDirectory, Filenames]\n        The dictionary of files to copy\n    \"\"\"\n    lqdir = ph_input_data[\"inputph\"].get(\"lqdir\", False)\n\n    files_to_copy = {\n        directory: [\n            Path(\"_ph0\", \"pwscf.phsave\", \"control_ph.xml*\"),\n            Path(\"_ph0\", \"pwscf.phsave\", \"status_run.xml*\"),\n            Path(\"_ph0\", \"pwscf.phsave\", \"patterns.*.xml*\"),\n            Path(\"_ph0\", \"pwscf.phsave\", \"tensors.xml*\"),\n        ]\n    }\n\n    if lqdir or qpt == (0.0, 0.0, 0.0):\n        files_to_copy[directory].extend(\n            [\n                Path(\"pwscf.save\", \"charge-density.*\"),\n                Path(\"pwscf.save\", \"data-file-schema.xml*\"),\n                Path(\"pwscf.save\", \"paw.txt*\"),\n                Path(\"pwscf.save\", \"wfc*.*\"),\n            ]\n        )\n        if qpt != (0.0, 0.0, 0.0):\n            files_to_copy[directory].extend(\n                [\n                    Path(\"_ph0\", f\"pwscf.q_{qnum}\", \"pwscf.save\", \"*\"),\n                    Path(\"_ph0\", f\"pwscf.q_{qnum}\", \"pwscf.wfc*\"),\n                ]\n            )\n    else:\n        files_to_copy[directory].extend(\n            [Path(\"_ph0\", \"pwscf.wfc*\"), Path(\"_ph0\", \"pwscf.save\", \"*\")]\n        )\n\n    return files_to_copy\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.grid_prepare_repr","title":"grid_prepare_repr","text":"<pre><code>grid_prepare_repr(\n    patterns: dict[str, Any], nblocks: int\n) -&gt; list\n</code></pre> <p>Function that prepares the representations for the grid calculation.</p> <p>Parameters:</p> <ul> <li> <code>patterns</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The representation patterns dictionary from the ph_init_job_results</p> </li> <li> <code>nblocks</code>               (<code>int</code>)           \u2013            <p>The number of blocks to group the representations in. See quacc.recipes.espresso.phonons.grid_phonon_flow.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>The list of representations to do grouped in blocks if nblocks &gt; 1</p> </li> </ul> Source code in <code>quacc/calculators/espresso/utils.py</code> <pre><code>def grid_prepare_repr(patterns: dict[str, Any], nblocks: int) -&gt; list:\n    \"\"\"\n    Function that prepares the representations for the grid calculation.\n\n    Parameters\n    ----------\n    patterns\n        The representation patterns dictionary from the ph_init_job_results\n    nblocks\n        The number of blocks to group the representations in. See\n        [quacc.recipes.espresso.phonons.grid_phonon_flow][].\n\n    Returns\n    -------\n    list\n        The list of representations to do grouped in blocks if nblocks &gt; 1\n    \"\"\"\n    this_block = nblocks if nblocks &gt; 0 else len(patterns)\n    repr_to_do = [rep for rep in patterns if not patterns[rep][\"done\"]]\n    return np.array_split(repr_to_do, np.ceil(len(repr_to_do) / this_block))\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.prepare_copy_files","title":"prepare_copy_files","text":"<pre><code>prepare_copy_files(\n    parameters: dict[str, Any], binary: str = \"pw\"\n) -&gt; list[Path]\n</code></pre> <p>Function that prepares the copy files for the espresso calculation.</p> <p>Parameters:</p> <ul> <li> <code>parameters</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The input data for the espresso calculation</p> </li> <li> <code>binary</code>               (<code>str</code>, default:                   <code>'pw'</code> )           \u2013            <p>The binary to use for the espresso calculation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Path]</code>           \u2013            <p>Paths to copy for the espresso calculation</p> </li> </ul> Source code in <code>quacc/calculators/espresso/utils.py</code> <pre><code>def prepare_copy_files(parameters: dict[str, Any], binary: str = \"pw\") -&gt; list[Path]:\n    \"\"\"\n    Function that prepares the copy files for the espresso calculation.\n\n    Parameters\n    ----------\n    parameters\n        The input data for the espresso calculation\n    binary\n        The binary to use for the espresso calculation\n\n    Returns\n    -------\n    list[Path]\n        Paths to copy for the espresso calculation\n    \"\"\"\n    to_copy = []\n\n    pw_base = [\n        Path(\"pwscf.save\", \"charge-density.*\"),\n        Path(\"pwscf.save\", \"data-file-schema.*\"),\n        Path(\"pwscf.save\", \"paw.*\"),\n    ]\n\n    input_data = parameters.get(\"input_data\", {})\n\n    if binary == \"pw\":\n        control = input_data.get(\"control\", {})\n        restart_mode = control.get(\"restart_mode\", \"from_scratch\")\n        electrons = input_data.get(\"electrons\", {})\n        startingpot = electrons.get(\"startingpot\", \"atomic\")\n        startingwfc = electrons.get(\"startingwfc\", \"atomic+random\")\n        calculation = control.get(\"calculation\", \"scf\")\n\n        if restart_mode == \"restart\":\n            to_copy.extend(\n                [\n                    Path(\"pwscf.wfc*\"),\n                    Path(\"pwscf.mix*\"),\n                    Path(\"pwscf.restart_k*\"),\n                    Path(\"pwscf.restart_scf*\"),\n                ]\n            )\n\n        need_chg_dens = (\n            startingpot == \"file\"\n            or calculation in [\"bands\", \"nscf\"]\n            or restart_mode == \"restart\"\n        )\n\n        need_wfc = startingwfc == \"file\" or restart_mode == \"restart\"\n\n        if need_chg_dens:\n            to_copy.append(Path(\"pwscf.save\", \"charge-density.*\"))\n\n        if need_wfc:\n            to_copy.append(Path(\"pwscf.save\", \"wfc*.*\"))\n\n        to_copy.extend(\n            [Path(\"pwscf.save\", \"data-file-schema.*\"), Path(\"pwscf.save\", \"paw.*\")]\n        )\n\n    elif binary in {\"ph\", \"phcg\"}:\n        to_copy.extend(pw_base)\n        to_copy.append(Path(\"pwscf.save\", \"wfc*.*\"))\n\n        inputph = input_data.get(\"inputph\", {})\n        ldisp = inputph.get(\"ldisp\", False)\n        fildvscf = inputph.get(\"fildvscf\", \"\")\n        recover = inputph.get(\"recover\", False)\n        lqdir = inputph.get(\"lqdir\", False) or (ldisp and fildvscf)\n        ldvscf_interpolate = inputph.get(\"ldvscf_interpolate\", False)\n\n        if lqdir:\n            to_copy.extend(\n                [Path(\"_ph*\", \"pwscf.q_*\", \"pwscf.save\", \"data-file-schema.*\")]\n            )\n\n            if recover:\n                to_copy.extend(\n                    [Path(\"_ph*\", \"pwscf.q_*\", \"pwscf.save\", \"charge-density.*\")]\n                )\n\n        if recover:\n            to_copy.append(Path(\"_ph*\", \"pwscf.phsave\"))\n\n        if ldvscf_interpolate:\n            to_copy.extend((Path(\"_ph*\", \"pwscf.dvscf*\"), Path(\"w_pot\")))\n            if lqdir:\n                to_copy.append(Path(\"_ph*\", \"pwscf.q_*\", \"pwscf.dvscf*\"))\n\n    elif binary in {\"dos\", \"fs\"}:\n        to_copy.extend(pw_base)\n\n    elif binary in {\"projwfc\", \"bands\"}:\n        to_copy.extend(pw_base)\n        to_copy.append(Path(\"pwscf.save\", \"wfc*.*\"))\n\n    elif binary == \"pp\":\n        plotnum = input_data.get(\"plot_num\", 0)\n        wfc_needed = [3, 7, 10]\n\n        to_copy.extend(pw_base)\n\n        if plotnum in wfc_needed:\n            to_copy.append(Path(\"pwscf.save\", \"wfc*.*\"))\n\n    elif binary == \"matdyn\":\n        to_copy.append(Path(\"q2r.fc*\"))\n\n    elif binary == \"q2r\":\n        to_copy.append(Path(\"matdyn*\"))\n\n    elif binary == \"dvscf_q2r\":\n        to_copy.extend(pw_base)\n        to_copy.extend(\n            [\n                Path(\"matdyn0*\"),\n                Path(\"_ph*\", \"pwscf.phsave\"),\n                Path(\"_ph*\", \"pwscf.dvscf*\"),\n                Path(\"_ph*\", \"pwscf.q_*\", \"pwscf.dvscf*\"),\n            ]\n        )\n\n    elif binary == \"postahc\":\n        to_copy.extend([Path(\"ahc_dir\"), Path(\"matdyn.modes*\")])\n\n    return to_copy\n</code></pre>"},{"location":"reference/quacc/calculators/espresso/utils.html#quacc.calculators.espresso.utils.remove_conflicting_kpts_kspacing","title":"remove_conflicting_kpts_kspacing","text":"<pre><code>remove_conflicting_kpts_kspacing(\n    to_change_dict: dict[str, Any],\n    reference_dict: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>to_change_dict</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary that will be changed</p> </li> <li> <code>reference_dict</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The reference dictionary that will remain intact</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The modified dictionary</p> </li> </ul> Source code in <code>quacc/calculators/espresso/utils.py</code> <pre><code>def remove_conflicting_kpts_kspacing(\n    to_change_dict: dict[str, Any], reference_dict: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Parameters\n    ----------\n    to_change_dict\n        The dictionary that will be changed\n    reference_dict\n        The reference dictionary that will remain intact\n\n    Returns\n    -------\n    dict[str, Any]\n        The modified dictionary\n    \"\"\"\n    if \"kpts\" in reference_dict:\n        to_change_dict.pop(\"kspacing\", None)\n    if \"kspacing\" in reference_dict:\n        to_change_dict.pop(\"kpts\", None)\n\n    return to_change_dict\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/io.html","title":"io","text":""},{"location":"reference/quacc/calculators/mrcc/io.html#quacc.calculators.mrcc.io.read_energy","title":"read_energy","text":"<pre><code>read_energy(lines: list[str]) -&gt; MRCCEnergyInfo\n</code></pre> <p>Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the MRCC output file where available.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>list[str]</code>)           \u2013            <p>List of lines read from the MRCC output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MRCCEnergyInfo</code>           \u2013            <p>Dictionary with the energy components. The keys are the following: - energy : float \u2190 Total energy which will not be computed in this function. - scf_energy : float \u2190 SCF energy. - mp2_corr_energy : float \u2190 MP2 correlation energy. - ccsd_corr_energy : float \u2190 CCSD correlation energy. - ccsdt_corr_energy : float \u2190 CCSD(T) correlation energy.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/io.py</code> <pre><code>def read_energy(lines: list[str]) -&gt; MRCCEnergyInfo:\n    \"\"\"\n    Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the MRCC output file where available.\n\n    Parameters\n    ----------\n    lines : list[str]\n        List of lines read from the MRCC output file.\n\n    Returns\n    -------\n    MRCCEnergyInfo\n        Dictionary with the energy components. The keys are the following:\n        - energy : float &lt;-- Total energy which will not be computed in this function.\n        - scf_energy : float &lt;-- SCF energy.\n        - mp2_corr_energy : float &lt;-- MP2 correlation energy.\n        - ccsd_corr_energy : float &lt;-- CCSD correlation energy.\n        - ccsdt_corr_energy : float &lt;-- CCSD(T) correlation energy.\n    \"\"\"\n\n    energy_dict = {\n        \"energy\": None,\n        \"scf_energy\": None,\n        \"mp2_corr_energy\": None,\n        \"ccsd_corr_energy\": None,\n        \"ccsdt_corr_energy\": None,\n    }\n\n    for line in lines:\n        if \"FINAL HARTREE-FOCK ENERGY\" in line or \"FINAL KOHN-SHAM ENERGY\" in line:\n            energy_dict[\"scf_energy\"] = float(line.split()[-2]) * Hartree\n        elif \"MP2 correlation energy\" in line:\n            energy_dict[\"mp2_corr_energy\"] = float(line.split()[-1]) * Hartree\n        elif \"CCSD correlation energy\" in line:\n            energy_dict[\"ccsd_corr_energy\"] = float(line.split()[-1]) * Hartree\n        elif \"CCSD(T) correlation energy\" in line:\n            energy_dict[\"ccsdt_corr_energy\"] = float(line.split()[-1]) * Hartree\n\n    return energy_dict\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/io.html#quacc.calculators.mrcc.io.read_geom_mrccinp","title":"read_geom_mrccinp","text":"<pre><code>read_geom_mrccinp(file_path: Path | str) -&gt; Atoms\n</code></pre> <p>Read geometry from an MRCC input file.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>Path | str</code>)           \u2013            <p>The path to the MRCC input file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>Atoms object with the geometry.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/io.py</code> <pre><code>def read_geom_mrccinp(file_path: Path | str) -&gt; Atoms:\n    \"\"\"\n    Read geometry from an MRCC input file.\n\n    Parameters\n    ----------\n    file_path: Path | str\n        The path to the MRCC input file.\n\n    Returns\n    -------\n    Atoms\n        Atoms object with the geometry.\n    \"\"\"\n\n    # Get the lines as a list\n    with Path.open(file_path) as fd:\n        lines = fd.readlines()\n    xyz_line_index = [index for index, line in enumerate(lines) if \"xyz\" in line]\n\n    if len(xyz_line_index) != 1:\n        raise ValueError(\"Geometry incorrectly provided in MRCC input file\")\n\n    xyz_line_index = xyz_line_index[0]\n\n    # Get the number of atoms\n    atoms_length = int(lines[xyz_line_index + 1])\n\n    # Format and send the string to be read by ase.io.read()\n    xyz_text = f\"{atoms_length}\\n geometry\\n\"\n    for line in lines[xyz_line_index + 3 : xyz_line_index + 3 + atoms_length]:\n        xyz_text += line\n    atoms = read(StringIO(xyz_text), format=\"xyz\")\n\n    # Remove PBC and set the unit cell to zero as MRCC is a molecular code.\n    atoms.pbc = False\n    atoms.set_cell([0.0, 0.0, 0.0])\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/io.html#quacc.calculators.mrcc.io.read_mrcc_outputs","title":"read_mrcc_outputs","text":"<pre><code>read_mrcc_outputs(\n    output_file_path: Path | str,\n) -&gt; MRCCEnergyInfo\n</code></pre> <p>Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the MRCC output file where available and calculates the total energy (based on the highest level of theory)</p> <p>Parameters:</p> <ul> <li> <code>output_file_path</code>               (<code>Path | str</code>)           \u2013            <p>Path to the MRCC output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MRCCEnergyInfo</code>           \u2013            <p>Dictionary with the energy components. The keys are the following: - energy : float | None \u2190 Total energy of highest available level. - scf_energy : float | None \u2190 SCF energy. - mp2_corr_energy : float | None \u2190 MP2 correlation energy. - ccsd_corr_energy : float | None \u2190 CCSD correlation energy. - ccsdt_corr_energy : float | None \u2190 CCSD(T) correlation energy.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/io.py</code> <pre><code>def read_mrcc_outputs(output_file_path: Path | str) -&gt; MRCCEnergyInfo:\n    \"\"\"\n    Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the MRCC output file where available and calculates the total energy (based on the highest level of theory)\n\n    Parameters\n    ----------\n    output_file_path : Path | str\n        Path to the MRCC output file.\n\n    Returns\n    -------\n    MRCCEnergyInfo\n        Dictionary with the energy components. The keys are the following:\n        - energy : float | None &lt;-- Total energy of highest available level.\n        - scf_energy : float | None &lt;-- SCF energy.\n        - mp2_corr_energy : float | None &lt;-- MP2 correlation energy.\n        - ccsd_corr_energy : float | None &lt;-- CCSD correlation energy.\n        - ccsdt_corr_energy : float | None &lt;-- CCSD(T) correlation energy.\n    \"\"\"\n    with Path.open(output_file_path) as output_textio:\n        lines = output_textio.readlines()\n\n    energy_dict = read_energy(lines)\n\n    # Raise error if scf_energy is None\n    if energy_dict[\"scf_energy\"] is None:\n        raise ValueError(\"SCF energy not found in MRCC output file\")\n\n    if energy_dict[\"ccsdt_corr_energy\"] is not None:\n        energy_dict[\"energy\"] = (\n            energy_dict[\"scf_energy\"] + energy_dict[\"ccsdt_corr_energy\"]\n        )\n    elif energy_dict[\"ccsd_corr_energy\"] is not None:\n        energy_dict[\"energy\"] = (\n            energy_dict[\"scf_energy\"] + energy_dict[\"ccsd_corr_energy\"]\n        )\n    elif energy_dict[\"mp2_corr_energy\"] is not None:\n        energy_dict[\"energy\"] = (\n            energy_dict[\"scf_energy\"] + energy_dict[\"mp2_corr_energy\"]\n        )\n    else:\n        energy_dict[\"energy\"] = energy_dict[\"scf_energy\"]\n\n    return energy_dict\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/io.html#quacc.calculators.mrcc.io.write_mrcc","title":"write_mrcc","text":"<pre><code>write_mrcc(\n    file_path: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, str],\n) -&gt; None\n</code></pre> <p>Write MRCC input file given the Atoms object and the parameters.</p> <p>Parameters:</p> <ul> <li> <code>file_path</code>               (<code>Path | str</code>)           \u2013            <p>File path to write the MRCC input file.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object with the geometry.</p> </li> <li> <code>parameters</code>               (<code>dict[str, str]</code>)           \u2013            <p>Dictionary with the parameters to be written in the MRCC input file. The keys are the input keyword and the values are the input values.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/io.py</code> <pre><code>def write_mrcc(file_path: Path | str, atoms: Atoms, parameters: dict[str, str]) -&gt; None:\n    \"\"\"\n    Write MRCC input file given the Atoms object and the parameters.\n\n    Parameters\n    ----------\n    file_path : Path | str\n        File path to write the MRCC input file.\n    atoms : Atoms\n        Atoms object with the geometry.\n    parameters : dict[str,str]\n        Dictionary with the parameters to be written in the MRCC input file. The keys are the input keyword and the values are the input values.\n    \"\"\"\n\n    with Path.open(file_path, \"w\") as file_path:\n        # Write the MRCC input file\n        for key, value in parameters.items():\n            file_path.write(f\"{key}={value}\\n\")\n\n        if \"geom\" not in parameters:\n            # If the geometry is not provided in the MRCC blocks, write it here.\n            ghost_list = []  # List of indices of the ghost atoms.\n            file_path.write(f\"geom=xyz\\n{len(atoms)}\\n\\n\")\n            for atom_idx, atom in enumerate(atoms):\n                if atom.tag == 71:  # 71 is ascii G (Ghost)\n                    ghost_list += [atom_idx + 1]\n\n                symbol = atom.symbol\n                position = atom.position\n                file_path.write(\n                    f\"{symbol.ljust(3)} {position[0]:-16.11f} {position[1]:-16.11f} {position[2]:-16.11f}\\n\"\n                )\n\n            if ghost_list and \"ghost\" not in parameters:\n                file_path.write(\"\\nghost=serialno\\n\")\n                file_path.write(\",\".join([str(atom_idx) for atom_idx in ghost_list]))\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html","title":"mrcc","text":""},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MRCC","title":"MRCC","text":"<pre><code>MRCC(\n    *,\n    profile: MrccProfile = None,\n    directory: str | Path = \".\",\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>GenericFileIOCalculator</code></p> <p>Class for performing MRCC calculations.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>MrccProfile</code>, default:                   <code>None</code> )           \u2013            <p>The MRCC profile to use.</p> </li> <li> <code>directory</code>               (<code>str | Path</code>, default:                   <code>'.'</code> )           \u2013            <p>The directory in which to run the calculation.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>The parameters for the MRCC calculation.</p> </li> </ul> <p>Examples:</p> <p>Use default values:</p> <pre><code>&gt;&gt;&gt; from quacc.calculators.mrcc.mrcc import MRCC, MrccProfile\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from quacc import get_settings\n</code></pre> <pre><code>&gt;&gt;&gt; calc = MRCC(\n...     profile=MrccProfile(command=get_settings().MRCC_CMD),\n...     charge=0,\n...     mult=1,\n...     basis=\"def2-SVP\",\n...     calc=\"PBE\",\n... )\n&gt;&gt;&gt; h = molecule(\"H2\")\n&gt;&gt;&gt; h.set_calculator(calc)\n&gt;&gt;&gt; h.get_total_energy()\n</code></pre> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def __init__(\n    self, *, profile: MrccProfile = None, directory: str | Path = \".\", **kwargs\n) -&gt; None:\n    \"\"\"\n    Construct MRCC-calculator object.\n\n    Parameters\n    ----------\n    profile: MrccProfile\n        The MRCC profile to use.\n    directory: str\n        The directory in which to run the calculation.\n    **kwargs\n        The parameters for the MRCC calculation.\n\n    Examples\n    --------\n    Use default values:\n\n    &gt;&gt;&gt; from quacc.calculators.mrcc.mrcc import MRCC, MrccProfile\n    &gt;&gt;&gt; from ase.build import molecule\n    &gt;&gt;&gt; from quacc import get_settings\n\n    &gt;&gt;&gt; calc = MRCC(\n    ...     profile=MrccProfile(command=get_settings().MRCC_CMD),\n    ...     charge=0,\n    ...     mult=1,\n    ...     basis=\"def2-SVP\",\n    ...     calc=\"PBE\",\n    ... )\n    &gt;&gt;&gt; h = molecule(\"H2\")\n    &gt;&gt;&gt; h.set_calculator(calc)\n    &gt;&gt;&gt; h.get_total_energy()\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    super().__init__(\n        template=MrccTemplate(),\n        profile=profile,\n        directory=directory,\n        parameters=kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccProfile","title":"MrccProfile","text":"<p>               Bases: <code>BaseProfile</code></p> <p>The MRCC calculator profile</p>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccProfile.get_calculator_command","title":"get_calculator_command","text":"<pre><code>get_calculator_command(inputfile: str) -&gt; list[str]\n</code></pre> <p>Get the command to run the MRCC calculation.</p> <p>Parameters:</p> <ul> <li> <code>inputfile</code>               (<code>str</code>)           \u2013            <p>The input file to run the calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The command to run the MRCC calculation.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def get_calculator_command(self, inputfile: str) -&gt; list[str]:\n    \"\"\"\n    Get the command to run the MRCC calculation.\n\n    Parameters\n    ----------\n    inputfile\n        The input file to run the calculation.\n\n    Returns\n    -------\n    list[str]\n        The command to run the MRCC calculation.\n    \"\"\"\n    return [inputfile]\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccProfile.version","title":"version","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Gives the version of the MRCC executable.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The version of the MRCC executable normally in Month DD, YYYY.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"\n    Gives the version of the MRCC executable.\n\n    Returns\n    -------\n    str\n        The version of the MRCC executable normally in Month DD, YYYY.\n    \"\"\"\n    stdout = read_stdout([self.command, \"does_not_exist\"])\n    return _get_version_from_mrcc_header(stdout)\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate","title":"MrccTemplate","text":"<pre><code>MrccTemplate()\n</code></pre> <p>               Bases: <code>CalculatorTemplate</code></p> <p>The MRCC calculator template class.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the MRCC calculator template class.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__(\n        \"mrcc\",\n        implemented_properties=[\n            \"energy\",\n            \"scf_energy\",\n            \"mp2_corr_energy\",\n            \"ccsd_corr_energy\",\n            \"ccsdt_corr_energy\",\n        ],\n    )\n    self.inputname = \"MINP\"\n    self.outputname = f\"{self._label}.out\"\n    self.errorname = f\"{self._label}.err\"\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.errorname","title":"errorname  <code>instance-attribute</code>","text":"<pre><code>errorname = f'{_label}.err'\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.inputname","title":"inputname  <code>instance-attribute</code>","text":"<pre><code>inputname = 'MINP'\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.outputname","title":"outputname  <code>instance-attribute</code>","text":"<pre><code>outputname = f'{_label}.out'\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.execute","title":"execute","text":"<pre><code>execute(\n    directory: Path | str, profile: MrccProfile\n) -&gt; None\n</code></pre> <p>Execute the MRCC calculation.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which to run the calculation.</p> </li> <li> <code>profile</code>               (<code>MrccProfile</code>)           \u2013            <p>The MRCCProfile class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def execute(self, directory: Path | str, profile: MrccProfile) -&gt; None:\n    \"\"\"\n    Execute the MRCC calculation.\n\n    Parameters\n    ----------\n    directory\n        The directory in which to run the calculation.\n    profile\n        The MRCCProfile class.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    profile.run(\n        directory, self.inputname, self.outputname, errorfile=self.errorname\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.load_profile","title":"load_profile","text":"<pre><code>load_profile(cfg: Config, **kwargs) -&gt; MrccProfile\n</code></pre> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def load_profile(self, cfg: Config, **kwargs) -&gt; MrccProfile:\n    return MrccProfile.from_config(cfg, self.name, **kwargs)\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.read_results","title":"read_results","text":"<pre><code>read_results(directory: Path | str) -&gt; MRCCEnergyInfo\n</code></pre> <p>Reads the MRCC output files.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which the calculation was run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MRCCEnergyInfo</code>           \u2013            <p>Dictionary with the energy components. The keys are the following: - energy : float \u2190 Total energy which will not be computed in this function. - scf_energy : float \u2190 SCF energy. - mp2_corr_energy : float \u2190 MP2 correlation energy. - ccsd_corr_energy : float \u2190 CCSD correlation energy. - ccsdt_corr_energy : float \u2190 CCSD(T) correlation energy.</p> </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def read_results(self, directory: Path | str) -&gt; MRCCEnergyInfo:\n    \"\"\"\n    Reads the MRCC output files.\n\n    Parameters\n    ----------\n    directory\n        The directory in which the calculation was run.\n\n    Returns\n    -------\n    MRCCEnergyInfo\n        Dictionary with the energy components. The keys are the following:\n        - energy : float &lt;-- Total energy which will not be computed in this function.\n        - scf_energy : float &lt;-- SCF energy.\n        - mp2_corr_energy : float &lt;-- MP2 correlation energy.\n        - ccsd_corr_energy : float &lt;-- CCSD correlation energy.\n        - ccsdt_corr_energy : float &lt;-- CCSD(T) correlation energy.\n    \"\"\"\n    return read_mrcc_outputs(output_file_path=directory / self.outputname)\n</code></pre>"},{"location":"reference/quacc/calculators/mrcc/mrcc.html#quacc.calculators.mrcc.mrcc.MrccTemplate.write_input","title":"write_input","text":"<pre><code>write_input(\n    profile: MrccProfile,\n    directory: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, str],\n    properties: dict[str, Any],\n) -&gt; None\n</code></pre> <p>Write the MRCC input file.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>MrccProfile</code>)           \u2013            <p>The MRCCProfile class.</p> </li> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which to write the input file.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>parameters</code>               (<code>dict[str, str]</code>)           \u2013            <p>The parameters for the calculation.</p> </li> <li> <code>properties</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The properties to calculate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/mrcc/mrcc.py</code> <pre><code>def write_input(\n    self,\n    profile: MrccProfile,  # noqa: ARG002\n    directory: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, str],\n    properties: dict[str, Any],  # noqa: ARG002\n) -&gt; None:\n    \"\"\"\n    Write the MRCC input file.\n\n    Parameters\n    ----------\n    profile\n        The MRCCProfile class.\n    directory\n        The directory in which to write the input file.\n    atoms\n        The Atoms object.\n    parameters\n        The parameters for the calculation.\n    properties\n        The properties to calculate.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    parameters = dict(parameters)\n\n    kw = {\"charge\": 0, \"mult\": 1, \"calc\": \"PBE\", \"basis\": \"def2-SVP\"}\n    kw |= parameters\n\n    write_mrcc(directory / self.inputname, atoms, kw)\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/io.html","title":"io","text":"<p>Q-Chem calculator IO.</p>"},{"location":"reference/quacc/calculators/qchem/io.html#quacc.calculators.qchem.io.read_qchem","title":"read_qchem","text":"<pre><code>read_qchem(\n    directory: Path | str,\n) -&gt; tuple[QchemResults, NDArray | None]\n</code></pre> <p>Read Q-Chem log files.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which the Q-Chem calculation was run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Results, NDArray | None]</code>           \u2013            <p>The results of the calculation and the orbital coefficients from a previous calculation.</p> </li> </ul> Source code in <code>quacc/calculators/qchem/io.py</code> <pre><code>def read_qchem(directory: Path | str) -&gt; tuple[QchemResults, NDArray | None]:\n    \"\"\"\n    Read Q-Chem log files.\n\n    Parameters\n    ----------\n    directory\n        The directory in which the Q-Chem calculation was run.\n\n    Returns\n    -------\n    tuple[Results, NDArray | None]\n        The results of the calculation and the orbital coefficients from a previous\n        calculation.\n    \"\"\"\n    directory = Path(directory)\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", category=UserWarning)\n        task_doc = TaskDoc.from_directory(directory, validate_lot=False).model_dump()\n\n    results: QchemResults = {\n        \"energy\": task_doc[\"output\"][\"final_energy\"] * units.Hartree,\n        \"taskdoc\": task_doc,\n    }\n\n    # Read the gradient scratch file in 8 byte chunks\n    grad_scratch = directory / \"131.0\"\n    if grad_scratch.exists() and grad_scratch.stat().st_size &gt; 0:\n        gradient = gradient_parser(directory / \"131.0\")\n\n        results[\"forces\"] = gradient * (-units.Hartree / units.Bohr)\n\n    # Read Hessian scratch file in 8 byte chunks\n    hessian_scratch = directory / \"132.0\"\n    if hessian_scratch.exists() and hessian_scratch.stat().st_size &gt; 0:\n        reshaped_hess = hessian_parser(hessian_scratch, n_atoms=task_doc[\"natoms\"])\n        results[\"hessian\"] = reshaped_hess * (units.Hartree / units.Bohr**2)\n\n    # Read orbital coefficients scratch file in 8 byte chunks\n    orb_scratch = directory / \"53.0\"\n    prev_orbital_coeffs = None\n    if orb_scratch.exists() and orb_scratch.stat().st_size &gt; 0:\n        prev_orbital_coeffs = orbital_coeffs_parser(orb_scratch).tolist()\n\n    return results, prev_orbital_coeffs\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/io.html#quacc.calculators.qchem.io.write_qchem","title":"write_qchem","text":"<pre><code>write_qchem(\n    qc_input: QCInput,\n    directory: Path | str,\n    prev_orbital_coeffs: list[float] | None = None,\n) -&gt; None\n</code></pre> <p>Write the Q-Chem input files.</p> <p>Parameters:</p> <ul> <li> <code>qc_input</code>               (<code>QCInput</code>)           \u2013            <p>The QCInput object.</p> </li> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which to write the files.</p> </li> <li> <code>prev_orbital_coeffs</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The orbital coefficients from a previous calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/qchem/io.py</code> <pre><code>def write_qchem(\n    qc_input: QCInput,\n    directory: Path | str,\n    prev_orbital_coeffs: list[float] | None = None,\n) -&gt; None:\n    \"\"\"\n    Write the Q-Chem input files.\n\n    Parameters\n    ----------\n    qc_input\n        The QCInput object.\n    directory\n        The directory in which to write the files.\n    prev_orbital_coeffs\n        The orbital coefficients from a previous calculation.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    directory = Path(directory)\n\n    if prev_orbital_coeffs:\n        with Path(directory / \"53.0\").open(mode=\"wb\") as file:\n            for val in prev_orbital_coeffs:\n                data = struct.pack(\"d\", val)\n                file.write(data)\n\n    qc_input.write_file(directory / \"mol.qin\")\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/params.html","title":"params","text":"<p>Parameter-related utilities for the Q-Chem calculator.</p>"},{"location":"reference/quacc/calculators/qchem/params.html#quacc.calculators.qchem.params.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/params.html#quacc.calculators.qchem.params.cleanup_attrs","title":"cleanup_attrs","text":"<pre><code>cleanup_attrs(qchem: QChem) -&gt; None\n</code></pre> <p>Clean up self attribute parameters in place.</p> <p>Parameters:</p> <ul> <li> <code>qchem</code>               (<code>QChem</code>)           \u2013            <p>The QChem object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/qchem/params.py</code> <pre><code>def cleanup_attrs(qchem: QChem) -&gt; None:\n    \"\"\"\n    Clean up self attribute parameters in place.\n\n    Parameters\n    ----------\n    qchem\n        The QChem object\n\n    Returns\n    -------\n    None\n    \"\"\"\n    for attr in [\n        \"rem\",\n        \"pcm\",\n        \"solvent\",\n        \"smx\",\n        \"scan\",\n        \"van_der_waals\",\n        \"plots\",\n        \"nbo\",\n        \"geom_opt\",\n        \"svp\",\n        \"pcm_nonels\",\n    ]:\n        attr_val = lower_and_check_unique(getattr(qchem, attr))\n        setattr(qchem, attr, attr_val)\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/params.html#quacc.calculators.qchem.params.get_rem_swaps","title":"get_rem_swaps","text":"<pre><code>get_rem_swaps(\n    rem: dict[str, Any], restart: bool = False\n) -&gt; dict[str, Any]\n</code></pre> <p>Automatic swaps for the rem dictionary.</p> <p>Parameters:</p> <ul> <li> <code>rem</code>               (<code>dict[str, Any]</code>)           \u2013            <p>rem dictionary</p> </li> <li> <code>restart</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not this is a restart calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>rem dictionary with swaps</p> </li> </ul> Source code in <code>quacc/calculators/qchem/params.py</code> <pre><code>def get_rem_swaps(rem: dict[str, Any], restart: bool = False) -&gt; dict[str, Any]:\n    \"\"\"\n    Automatic swaps for the rem dictionary.\n\n    Parameters\n    ----------\n    rem\n        rem dictionary\n    restart\n        Whether or not this is a restart calculation.\n\n    Returns\n    -------\n    dict[str, Any]\n        rem dictionary with swaps\n    \"\"\"\n    if restart and \"scf_guess\" not in rem:\n        LOGGER.info(\"Copilot: Setting scf_guess in `rem` to 'read'\")\n        rem[\"scf_guess\"] = \"read\"\n    if \"max_scf_cycles\" not in rem:\n        rem[\"max_scf_cycles\"] = 200 if rem.get(\"scf_algorithm\") == \"gdm\" else 100\n        LOGGER.info(\n            f\"Copilot: Setting max_scf_cycles in `rem` to {rem['max_scf_cycles']}\"\n        )\n\n    return rem\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/params.html#quacc.calculators.qchem.params.make_qc_input","title":"make_qc_input","text":"<pre><code>make_qc_input(qchem: QChem, atoms: Atoms) -&gt; QCInput\n</code></pre> <p>Make a QCInput object. It will, by default, create a QCInput from the QChem calculator kwargs. If <code>qchem.qchem_dict_set_params</code> is specified, it will create a QCInput from a QChemDictSet, merging the two QCInput objects and taking the latter as higher priority.</p> <p>Parameters:</p> <ul> <li> <code>qchem</code>               (<code>QChem</code>)           \u2013            <p>The QChem object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QCInput</code>           \u2013            <p>The QCInput object.</p> </li> </ul> Source code in <code>quacc/calculators/qchem/params.py</code> <pre><code>def make_qc_input(qchem: QChem, atoms: Atoms) -&gt; QCInput:\n    \"\"\"\n    Make a QCInput object. It will, by default, create a QCInput from the QChem\n    calculator kwargs. If `qchem.qchem_dict_set_params` is specified, it will create a\n    QCInput from a QChemDictSet, merging the two QCInput objects and taking the latter\n    as higher priority.\n\n    Parameters\n    ----------\n    qchem\n        The QChem object.\n\n    Returns\n    -------\n    QCInput\n        The QCInput object.\n    \"\"\"\n    atoms.charge = qchem.charge  # type: ignore[attr-defined]\n    atoms.spin_multiplicity = qchem.spin_multiplicity  # type: ignore[attr-defined]\n    molecule = AseAtomsAdaptor().get_molecule(atoms)\n\n    if qchem.qchem_dict_set_params:\n        # Get minimal parameters needed to instantiate a QChemDictSet\n        if \"molecule\" in qchem.qchem_dict_set_params:\n            msg = \"Do not specify `molecule` in `qchem_dict_set_params`\"\n            raise NotImplementedError(msg)\n        if \"job_type\" not in qchem.qchem_dict_set_params and qchem.rem.get(\"job_type\"):\n            qchem.qchem_dict_set_params[\"job_type\"] = qchem.rem[\"job_type\"]\n        if \"basis_set\" not in qchem.qchem_dict_set_params and qchem.rem.get(\"basis\"):\n            qchem.qchem_dict_set_params[\"basis_set\"] = qchem.rem[\"basis\"]\n        if \"scf_algorithm\" not in qchem.qchem_dict_set_params and qchem.rem.get(\n            \"scf_algorithm\"\n        ):\n            qchem.qchem_dict_set_params[\"scf_algorithm\"] = qchem.rem[\"scf_algorithm\"]\n        if \"qchem_version\" not in qchem.qchem_dict_set_params:\n            qchem.qchem_dict_set_params[\"qchem_version\"] = 6\n\n        # Make QChemDictSet\n        qc_dict_set = QChemDictSet(molecule, **qchem.qchem_dict_set_params)\n        for prop in [\n            \"rem\",\n            \"opt\",\n            \"pcm\",\n            \"solvent\",\n            \"smx\",\n            \"scan\",\n            \"van_der_waals\",\n            \"plots\",\n            \"nbo\",\n            \"geom_opt\",\n            \"svp\",\n            \"pcm_nonels\",\n        ]:\n            prop1 = getattr(qchem, prop)\n            if prop2 := getattr(qc_dict_set, prop):\n                setattr(qchem, prop, recursive_dict_merge(prop2, prop1))\n        for prop in [\"vdw_mode\", \"cdft\", \"almo_coupling\"]:\n            prop2 = getattr(qc_dict_set, prop)\n            if prop2 and not prop1:\n                setattr(qchem, prop, prop2)\n\n    qchem.rem = sort_dict(\n        get_rem_swaps(qchem.rem, restart=qchem.prev_orbital_coeffs is not None)\n    )\n\n    return QCInput(\n        molecule,\n        qchem.rem,\n        opt=qchem.opt,\n        pcm=qchem.pcm,\n        solvent=qchem.solvent,\n        smx=qchem.smx,\n        scan=qchem.scan,\n        van_der_waals=qchem.van_der_waals,\n        vdw_mode=qchem.vdw_mode,\n        plots=qchem.plots,\n        nbo=qchem.nbo,\n        geom_opt=qchem.geom_opt,\n        cdft=qchem.cdft,\n        almo_coupling=qchem.almo_coupling,\n        svp=qchem.svp,\n        pcm_nonels=qchem.pcm_nonels,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html","title":"qchem","text":"<p>A Q-Chem calculator built on Pymatgen and Custodian functionality.</p>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem","title":"QChem","text":"<pre><code>QChem(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    rem: dict | None = None,\n    opt: dict[str, list[str]] | None = None,\n    pcm: dict | None = None,\n    solvent: dict | None = None,\n    smx: dict | None = None,\n    scan: dict[str, list] | None = None,\n    van_der_waals: dict[str, float] | None = None,\n    vdw_mode: Literal[\"atomic\", \"sequential\"] = \"atomic\",\n    plots: dict | None = None,\n    nbo: dict | None = None,\n    geom_opt: dict | None = None,\n    cdft: list[list[dict]] | None = None,\n    almo_coupling: (\n        list[list[tuple[int, int]]] | None\n    ) = None,\n    svp: dict | None = None,\n    pcm_nonels: dict | None = None,\n    qchem_dict_set_params: dict[str, Any] | None = None,\n    **fileiocalculator_kwargs\n)\n</code></pre> <p>               Bases: <code>FileIOCalculator</code></p> <p>Custom Q-Chem calculator built on Pymatgen and Custodian.</p> <p>that class for more information.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object to be used for the calculation.</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The total charge of the molecular system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The spin multiplicity of the molecular system.</p> </li> <li> <code>rem</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of all the input parameters for the rem section of QChem input file. e.g. rem = {'method': 'rimp2', 'basis': '6-31*G++'}</p> </li> <li> <code>opt</code>               (<code>dict[str, list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of opt sections, where each opt section is a key and the corresponding values are a list of strings. Strings must be formatted as instructed by the QChem manual. The different opt sections are: CONSTRAINT, FIXED, DUMMY, and CONNECT e.g. opt = {\"CONSTRAINT\": [\"tors 2 3 4 5 25.0\", \"tors 2 5 7 9 80.0\"], \"FIXED\": [\"2 XY\"]}</p> </li> <li> <code>pcm</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of the PCM section, defining behavior for use of the polarizable continuum model. e.g. pcm = {\"theory\": \"cpcm\", \"hpoints\": 194}</p> </li> <li> <code>solvent</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary defining the solvent parameters used with PCM. e.g. solvent = {\"dielectric\": 78.39, \"temperature\": 298.15}</p> </li> <li> <code>smx</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary defining solvent parameters used with the SMD method, a solvent method that adds short-range terms to PCM. e.g. smx =</p> </li> <li> <code>scan</code>               (<code>dict[str, list] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of scan variables. Because two constraints of the same type are allowed (for instance, two torsions or two bond stretches), each TYPE of variable (stre, bend, tors) should be its own key in the dict, rather than each variable. Note that the total number of variable (sum of lengths of all lists) CANNOT be more than two. e.g. scan = {\"stre\": [\"3 6 1.5 1.9 0.1\"], \"tors\": [\"1 2 3 4 -180 180 15\"]}</p> </li> <li> <code>van_der_waals</code>               (<code>dict[str, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of custom van der Waals radii to be used when constructing cavities for the PCM model or when computing, e.g. Mulliken charges. They keys are strs whose meaning depends on the value of vdw_mode, and the values are the custom radii in angstroms.</p> </li> <li> <code>vdw_mode</code>               (<code>Literal['atomic', 'sequential']</code>, default:                   <code>'atomic'</code> )           \u2013            <p>Method of specifying custom van der Waals radii - 'atomic' or 'sequential'. In 'atomic' mode (default), dict keys represent the atomic number associated with each radius (e.g., 12 = carbon). In 'sequential' mode, dict keys represent the sequential position of a single specific atom in the input structure.</p> </li> <li> <code>plots</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of all the input parameters for the plots section of the QChem input file.</p> </li> <li> <code>nbo</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of all the input parameters for the nbo section of the QChem input file.</p> </li> <li> <code>geom_opt</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of input parameters for the geom_opt section of the QChem input file. This section is required when using the libopt3 geometry optimizer.</p> </li> <li> <code>cdft</code>               (<code>list[list[dict]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of lists of dictionaries, where each dictionary represents a charge constraint in the cdft section of the QChem input file. Each entry in the main list represents one state (allowing for multi-configuration calculations using constrained density functional theory - configuration interaction (CDFT-CI). Each state is represented by a list, which itself contains some number of constraints (dictionaries).</p> <ol> <li>For a single-state calculation with two constraints: cdft=[[     {\"value\": 1.0, \"coefficients\": [1.0], \"first_atoms\": [1],     \"last_atoms\": [2], \"types\": [None]}, {\"value\": 2.0,     \"coefficients\": [1.0, -1.0], \"first_atoms\": [1, 17],     \"last_atoms\": [3, 19],         \"types\": [\"s\"]} ]]</li> </ol> <p>Note that a type of None will default to a charge constraint (which can also be accessed by requesting a type of \"c\" or \"charge\".</p> <ol> <li>For a multi-reference calculation: cdft=[     [         {\"value\": 1.0, \"coefficients\": [1.0], \"first_atoms\": [1],         \"last_atoms\": [27],             \"types\": [\"c\"]},         {\"value\": 0.0, \"coefficients\": [1.0], \"first_atoms\": [1],         \"last_atoms\": [27],             \"types\": [\"s\"]},     ], [         {\"value\": 0.0, \"coefficients\": [1.0], \"first_atoms\": [1],         \"last_atoms\": [27],             \"types\": [\"c\"]},         {\"value\": -1.0, \"coefficients\": [1.0], \"first_atoms\": [1],         \"last_atoms\": [27],             \"types\": [\"s\"]},     ] ]</li> </ol> </li> <li> <code>almo_coupling</code>               (<code>list[list[tuple[int, int]]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of lists of int 2-tuples used for calculations of diabatization and state coupling calculations relying on the absolutely localized molecular orbitals (ALMO) methodology. Each entry in the main list represents a single state (two states are included in an ALMO calculation). Within a single state, each 2-tuple represents the charge and spin multiplicity of a single fragment. e.g. almo=[[(1, 2), (0, 1)], [(0, 1), (1, 2)]]</p> </li> <li> <code>svp</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>of the Q-Chem input file, which is formatted as a FORTRAN namelist. Note that in pymatgen, these parameters are typically not set by the user, but rather are populated automatically by an InputSet.</p> <p>An example for water may look like:     {         \"RHOISO\": \"0.001\",         \"DIELST\": \"78.36\",         \"NPTLEB\": \"1202\",         \"ITRNGR\": \"2\",         \"IROTGR\": \"2\",         \"IPNRF\": \"1\",         \"IDEFESR\": \"1\",     }</p> <p>See https://manual.q-chem.com/6.0/subsec_SS(V)PE.html in the Q-Chem manual for more details.</p> </li> <li> <code>pcm_nonels</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>model, corresponding to the $pcm_nonels section of the Q-Chem input file/ Note that in pymatgen, these parameters are typically not set by the user, but rather are populated automatically by an InputSet.</p> <p>An example for water may look like:     {         \"a\": \"-0.006496\",         \"b\": \"0.050833\",         \"c\": \"-566.7\",         \"d\": \"-30.503\",         \"gamma\": \"3.2\",         \"solvrho\": \"0.05\",         \"delta\": 7,         \"gaulag_n\": 40,     }</p> <p>See https://manual.q-chem.com/6.0/example_CMIRS-water.html in the Q-Chem manual for more details.</p> </li> <li> <code>qchem_dict_set_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to be passed to <code>pymatgen.io.qchem.sets.QChemDictSet</code>, which will generate a <code>QCInput</code>. If <code>qchem_dict_set_params</code> is specified, the resulting <code>QCInput</code> will be merged with the <code>QCInput</code> generated from the <code>QChem</code> calculator kwargs, with the former taking priority. Accepts all arguments that <code>pymatgen.io.qchem.sets.QChemDictSet</code> accepts, except for <code>molecule</code>, which will always be generated from <code>atoms</code>. By default, <code>job_type</code>, <code>basis_set</code>, and <code>scf_algorithm</code> will be pulled from the <code>rem</code> kwarg if not specified in <code>qchem_dict_set_params</code>. <code>qchem_version</code> will default to 6 if not specified in <code>qchem_dict_set_params</code>.</p> </li> <li> <code>**fileiocalculator_kwargs</code>           \u2013            <p>Additional arguments to be passed to ase.calculators.calculator.FileIOCalculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    rem: dict | None = None,\n    opt: dict[str, list[str]] | None = None,\n    pcm: dict | None = None,\n    solvent: dict | None = None,\n    smx: dict | None = None,\n    scan: dict[str, list] | None = None,\n    van_der_waals: dict[str, float] | None = None,\n    vdw_mode: Literal[\"atomic\", \"sequential\"] = \"atomic\",\n    plots: dict | None = None,\n    nbo: dict | None = None,\n    geom_opt: dict | None = None,\n    cdft: list[list[dict]] | None = None,\n    almo_coupling: list[list[tuple[int, int]]] | None = None,\n    svp: dict | None = None,\n    pcm_nonels: dict | None = None,\n    qchem_dict_set_params: dict[str, Any] | None = None,\n    **fileiocalculator_kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize the Q-Chem calculator. Most of the input parameters here are used to\n    create a `pymatgen.io.qchem.inputs.QCInput` object. See the documentation for\n    that class for more information.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to be used for the calculation.\n    charge\n        The total charge of the molecular system.\n    spin_multiplicity\n        The spin multiplicity of the molecular system.\n    rem\n        A dictionary of all the input parameters for the rem section of\n        QChem input file. e.g. rem = {'method': 'rimp2', 'basis': '6-31*G++'}\n    opt\n        A dictionary of opt sections, where each opt section is a key and\n        the corresponding values are a list of strings. Strings must be\n        formatted as instructed by the QChem manual. The different opt\n        sections are: CONSTRAINT, FIXED, DUMMY, and CONNECT e.g. opt =\n        {\"CONSTRAINT\": [\"tors 2 3 4 5 25.0\", \"tors 2 5 7 9 80.0\"], \"FIXED\":\n        [\"2 XY\"]}\n    pcm\n        A dictionary of the PCM section, defining behavior for use of the\n        polarizable continuum model. e.g. pcm = {\"theory\": \"cpcm\",\n        \"hpoints\": 194}\n    solvent\n        A dictionary defining the solvent parameters used with PCM. e.g.\n        solvent = {\"dielectric\": 78.39, \"temperature\": 298.15}\n    smx\n        A dictionary defining solvent parameters used with the SMD method, a\n        solvent method that adds short-range terms to PCM. e.g. smx =\n        {\"solvent\": \"water\"}\n    scan\n        A dictionary of scan variables. Because two constraints of the same\n        type are allowed (for instance, two torsions or two bond stretches),\n        each TYPE of variable (stre, bend, tors) should be its own key in\n        the dict, rather than each variable. Note that the total number of\n        variable (sum of lengths of all lists) CANNOT be more than two. e.g.\n        scan = {\"stre\": [\"3 6 1.5 1.9 0.1\"], \"tors\": [\"1 2 3 4 -180 180\n        15\"]}\n    van_der_waals\n        A dictionary of custom van der Waals radii to be used when\n        constructing cavities for the PCM model or when computing, e.g.\n        Mulliken charges. They keys are strs whose meaning depends on the\n        value of vdw_mode, and the values are the custom radii in angstroms.\n    vdw_mode\n        Method of specifying custom van der Waals radii - 'atomic' or\n        'sequential'. In 'atomic' mode (default), dict keys represent the\n        atomic number associated with each radius (e.g., 12 = carbon). In\n        'sequential' mode, dict keys represent the sequential position of a\n        single specific atom in the input structure.\n    plots\n        A dictionary of all the input parameters for the plots section of\n        the QChem input file.\n    nbo\n        A dictionary of all the input parameters for the nbo section of the\n        QChem input file.\n    geom_opt\n        A dictionary of input parameters for the geom_opt section of the\n        QChem input file. This section is required when using the libopt3\n        geometry optimizer.\n    cdft\n        A list of lists of dictionaries, where each dictionary represents a\n        charge constraint in the cdft section of the QChem input file. Each\n        entry in the main list represents one state (allowing for\n        multi-configuration calculations using constrained density\n        functional theory - configuration interaction (CDFT-CI). Each state\n        is represented by a list, which itself contains some number of\n        constraints (dictionaries).\n\n        1. For a single-state calculation with two constraints:\n        cdft=[[\n            {\"value\": 1.0, \"coefficients\": [1.0], \"first_atoms\": [1],\n            \"last_atoms\": [2], \"types\": [None]}, {\"value\": 2.0,\n            \"coefficients\": [1.0, -1.0], \"first_atoms\": [1, 17],\n            \"last_atoms\": [3, 19],\n                \"types\": [\"s\"]}\n        ]]\n\n        Note that a type of None will default to a charge constraint (which\n        can also be accessed by requesting a type of \"c\" or \"charge\".\n\n        2. For a multi-reference calculation:\n        cdft=[\n            [\n                {\"value\": 1.0, \"coefficients\": [1.0], \"first_atoms\": [1],\n                \"last_atoms\": [27],\n                    \"types\": [\"c\"]},\n                {\"value\": 0.0, \"coefficients\": [1.0], \"first_atoms\": [1],\n                \"last_atoms\": [27],\n                    \"types\": [\"s\"]},\n            ], [\n                {\"value\": 0.0, \"coefficients\": [1.0], \"first_atoms\": [1],\n                \"last_atoms\": [27],\n                    \"types\": [\"c\"]},\n                {\"value\": -1.0, \"coefficients\": [1.0], \"first_atoms\": [1],\n                \"last_atoms\": [27],\n                    \"types\": [\"s\"]},\n            ]\n        ]\n    almo_coupling\n        A list of lists of int 2-tuples used for calculations of\n        diabatization and state coupling calculations\n        relying on the absolutely localized molecular orbitals (ALMO)\n        methodology. Each entry in the main list represents a single\n        state (two states are included in an ALMO calculation). Within a\n        single state, each 2-tuple represents the charge and spin\n        multiplicity of a single fragment.\n        e.g. almo=[[(1, 2), (0, 1)], [(0, 1), (1, 2)]]\n    svp: Settings for the ISOSVP solvent model, corresponding to the $svp section\n        of the Q-Chem input file, which is formatted as a FORTRAN namelist. Note that in pymatgen, these\n        parameters are typically not set by the user, but rather are populated automatically by an InputSet.\n\n        An example for water may look like:\n            {\n                \"RHOISO\": \"0.001\",\n                \"DIELST\": \"78.36\",\n                \"NPTLEB\": \"1202\",\n                \"ITRNGR\": \"2\",\n                \"IROTGR\": \"2\",\n                \"IPNRF\": \"1\",\n                \"IDEFESR\": \"1\",\n            }\n\n        See https://manual.q-chem.com/6.0/subsec_SS(V)PE.html in the Q-Chem manual for more\n        details.\n    pcm_nonels: Settings for the non-electrostatic part of the CMIRS solvation\n        model, corresponding to the $pcm_nonels section of the Q-Chem input file/ Note that in pymatgen,\n        these parameters are typically not set by the user, but rather are populated automatically by an\n        InputSet.\n\n        An example for water may look like:\n            {\n                \"a\": \"-0.006496\",\n                \"b\": \"0.050833\",\n                \"c\": \"-566.7\",\n                \"d\": \"-30.503\",\n                \"gamma\": \"3.2\",\n                \"solvrho\": \"0.05\",\n                \"delta\": 7,\n                \"gaulag_n\": 40,\n            }\n\n        See https://manual.q-chem.com/6.0/example_CMIRS-water.html in the Q-Chem manual for more details.\n    qchem_dict_set_params\n        Keyword arguments to be passed to `pymatgen.io.qchem.sets.QChemDictSet`,\n        which will generate a `QCInput`. If `qchem_dict_set_params` is specified,\n        the resulting `QCInput` will be merged with the `QCInput` generated from\n        the `QChem` calculator kwargs, with the former taking priority. Accepts\n        all arguments that `pymatgen.io.qchem.sets.QChemDictSet` accepts, except\n        for `molecule`, which will always be generated from `atoms`. By default,\n        `job_type`, `basis_set`, and `scf_algorithm` will be pulled from the `rem`\n        kwarg if not specified in `qchem_dict_set_params`. `qchem_version` will\n        default to 6 if not specified in `qchem_dict_set_params`.\n    **fileiocalculator_kwargs\n        Additional arguments to be passed to\n        [ase.calculators.calculator.FileIOCalculator][].\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Assign variables to self\n    self.atoms = atoms\n    self.charge = charge\n    self.spin_multiplicity = spin_multiplicity\n    self.rem = rem or {}\n    self.opt = opt\n    self.pcm = pcm\n    self.solvent = solvent\n    self.smx = smx\n    self.scan = scan\n    self.van_der_waals = van_der_waals\n    self.vdw_mode = vdw_mode\n    self.plots = plots\n    self.nbo = nbo\n    self.geom_opt = geom_opt\n    self.cdft = cdft\n    self.almo_coupling = almo_coupling\n    self.svp = svp\n    self.pcm_nonels = pcm_nonels\n    self.qchem_dict_set_params = qchem_dict_set_params or {}\n    self.fileiocalculator_kwargs = fileiocalculator_kwargs\n\n    # Instantiate previous orbital coefficients\n    self.prev_orbital_coeffs = None\n\n    # Clean up parameters\n    cleanup_attrs(self)\n\n    # Set default params\n    self._set_default_params()\n\n    # Instantiate the calculator\n    super().__init__(\n        restart=None,\n        label=None,\n        command=\"\",\n        atoms=self.atoms,\n        profile=None,\n        **self.fileiocalculator_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.almo_coupling","title":"almo_coupling  <code>instance-attribute</code>","text":"<pre><code>almo_coupling = almo_coupling\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = atoms\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.cdft","title":"cdft  <code>instance-attribute</code>","text":"<pre><code>cdft = cdft\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge = charge\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.fileiocalculator_kwargs","title":"fileiocalculator_kwargs  <code>instance-attribute</code>","text":"<pre><code>fileiocalculator_kwargs = fileiocalculator_kwargs\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.geom_opt","title":"geom_opt  <code>instance-attribute</code>","text":"<pre><code>geom_opt = geom_opt\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.implemented_properties","title":"implemented_properties  <code>class-attribute</code>","text":"<pre><code>implemented_properties: list[str] = [\n    \"energy\",\n    \"forces\",\n    \"hessian\",\n    \"taskdoc\",\n]\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.nbo","title":"nbo  <code>instance-attribute</code>","text":"<pre><code>nbo = nbo\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.opt","title":"opt  <code>instance-attribute</code>","text":"<pre><code>opt = opt\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.pcm","title":"pcm  <code>instance-attribute</code>","text":"<pre><code>pcm = pcm\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.pcm_nonels","title":"pcm_nonels  <code>instance-attribute</code>","text":"<pre><code>pcm_nonels = pcm_nonels\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.plots","title":"plots  <code>instance-attribute</code>","text":"<pre><code>plots = plots\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.prev_orbital_coeffs","title":"prev_orbital_coeffs  <code>instance-attribute</code>","text":"<pre><code>prev_orbital_coeffs = None\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.qchem_dict_set_params","title":"qchem_dict_set_params  <code>instance-attribute</code>","text":"<pre><code>qchem_dict_set_params = qchem_dict_set_params or {}\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.rem","title":"rem  <code>instance-attribute</code>","text":"<pre><code>rem = rem or {}\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.results","title":"results  <code>class-attribute</code>","text":"<pre><code>results: QchemResults = {}\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.scan","title":"scan  <code>instance-attribute</code>","text":"<pre><code>scan = scan\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.smx","title":"smx  <code>instance-attribute</code>","text":"<pre><code>smx = smx\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.solvent","title":"solvent  <code>instance-attribute</code>","text":"<pre><code>solvent = solvent\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.spin_multiplicity","title":"spin_multiplicity  <code>instance-attribute</code>","text":"<pre><code>spin_multiplicity = spin_multiplicity\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.svp","title":"svp  <code>instance-attribute</code>","text":"<pre><code>svp = svp\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.van_der_waals","title":"van_der_waals  <code>instance-attribute</code>","text":"<pre><code>van_der_waals = van_der_waals\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.vdw_mode","title":"vdw_mode  <code>instance-attribute</code>","text":"<pre><code>vdw_mode = vdw_mode\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.execute","title":"execute","text":"<pre><code>execute() -&gt; int\n</code></pre> <p>Execute Q-Chem.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The return code.</p> </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def execute(self) -&gt; int:\n    \"\"\"\n    Execute Q-Chem.\n\n    Returns\n    -------\n    int\n        The return code.\n    \"\"\"\n    run_custodian(directory=self.directory)\n    return 0\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.read_results","title":"read_results","text":"<pre><code>read_results() -&gt; None\n</code></pre> <p>Read the Q-Chem output files. Update the .results and .prev_orbital_coeffs attributes.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def read_results(self) -&gt; None:\n    \"\"\"\n    Read the Q-Chem output files. Update the .results and .prev_orbital_coeffs\n    attributes.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    results, prev_orbital_coeffs = read_qchem(self.directory)\n    self.results = results\n    self.prev_orbital_coeffs = prev_orbital_coeffs\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem.html#quacc.calculators.qchem.qchem.QChem.write_input","title":"write_input","text":"<pre><code>write_input(\n    atoms: Atoms,\n    properties: list[str] | None = None,\n    system_changes: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Write the Q-Chem input files.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object to be used for the calculation.</p> </li> <li> <code>properties</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of properties to calculate.</p> </li> <li> <code>system_changes</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of changes to the system since last calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/qchem/qchem.py</code> <pre><code>def write_input(\n    self,\n    atoms: Atoms,\n    properties: list[str] | None = None,\n    system_changes: list[str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Write the Q-Chem input files.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to be used for the calculation.\n    properties\n        List of properties to calculate.\n    system_changes\n        List of changes to the system since last calculation.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    FileIOCalculator.write_input(self, atoms, properties, system_changes)\n\n    qc_input = make_qc_input(self, atoms)\n\n    write_qchem(\n        qc_input, self.directory, prev_orbital_coeffs=self.prev_orbital_coeffs\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem_custodian.html","title":"qchem_custodian","text":"<p>Custodian handlers for QChem.</p>"},{"location":"reference/quacc/calculators/qchem/qchem_custodian.html#quacc.calculators.qchem.qchem_custodian.has_ob","title":"has_ob  <code>module-attribute</code>","text":"<pre><code>has_ob = bool(find_spec('openbabel'))\n</code></pre>"},{"location":"reference/quacc/calculators/qchem/qchem_custodian.html#quacc.calculators.qchem.qchem_custodian.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\n    qchem_cmd: str | DefaultSetting = QuaccDefault,\n    qchem_cores: int | DefaultSetting = QuaccDefault,\n    qchem_local_scratch: (\n        str | Path | DefaultSetting\n    ) = QuaccDefault,\n    qchem_use_error_handlers: (\n        bool | DefaultSetting\n    ) = QuaccDefault,\n    qchem_custodian_max_errors: (\n        int | DefaultSetting\n    ) = QuaccDefault,\n    qchem_nbo_exe: (\n        str | Path | DefaultSetting\n    ) = QuaccDefault,\n    directory: str | Path | None = None,\n) -&gt; list[list[dict]]\n</code></pre> <p>Function to run QChem Custodian.</p> <p>Parameters:</p> <ul> <li> <code>qchem_cmd</code>               (<code>str | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Q-Chem command. Defaults to \"qchem\" in settings.</p> </li> <li> <code>qchem_cores</code>               (<code>int | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Number of cores to use for the Q-Chem calculation.</p> </li> <li> <code>qchem_local_scratch</code>               (<code>str | Path | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Compute-node local scratch directory in which Q-Chem should perform IO. Defaults to /tmp in settings.</p> </li> <li> <code>qchem_use_error_handlers</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether or not to employ error handlers. Defaults to True in settings.</p> </li> <li> <code>qchem_custodian_max_errors</code>               (<code>int | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> <code>qchem_nbo_exe</code>               (<code>str | Path | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>The full path to the NBO executable.</p> </li> <li> <code>directory</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[list[dict]]</code>           \u2013            <p>Lists of lists of errors.</p> </li> </ul> Source code in <code>quacc/calculators/qchem/qchem_custodian.py</code> <pre><code>@requires(\n    has_ob, \"Openbabel must be installed. Try conda install -c conda-forge openbabel\"\n)\ndef run_custodian(\n    qchem_cmd: str | DefaultSetting = QuaccDefault,\n    qchem_cores: int | DefaultSetting = QuaccDefault,\n    qchem_local_scratch: str | Path | DefaultSetting = QuaccDefault,\n    qchem_use_error_handlers: bool | DefaultSetting = QuaccDefault,\n    qchem_custodian_max_errors: int | DefaultSetting = QuaccDefault,\n    qchem_nbo_exe: str | Path | DefaultSetting = QuaccDefault,\n    directory: str | Path | None = None,\n) -&gt; list[list[dict]]:\n    \"\"\"\n    Function to run QChem Custodian.\n\n    Parameters\n    ----------\n    qchem_cmd\n        Q-Chem command. Defaults to \"qchem\" in settings.\n    qchem_cores\n        Number of cores to use for the Q-Chem calculation.\n    qchem_local_scratch\n        Compute-node local scratch directory in which Q-Chem should perform IO.\n        Defaults to /tmp in settings.\n    qchem_use_error_handlers\n        Whether or not to employ error handlers. Defaults to True in settings.\n    qchem_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5\n        in settings.\n    qchem_nbo_exe\n        The full path to the NBO executable.\n    directory\n        The runtime directory.\n\n    Returns\n    -------\n    list[list[dict]]\n        Lists of lists of errors.\n    \"\"\"\n    # Adapted from atomate.qchem.firetasks.run_calc\n    from custodian.custodian import Custodian\n    from custodian.qchem.handlers import QChemErrorHandler\n    from custodian.qchem.jobs import QCJob\n\n    settings = get_settings()\n\n    # Set defaults\n    qchem_cores = (\n        settings.QCHEM_NUM_CORES if qchem_cores == QuaccDefault else qchem_cores\n    )\n    qchem_cmd = settings.QCHEM_CMD if qchem_cmd == QuaccDefault else qchem_cmd\n    qchem_local_scratch = (\n        settings.QCHEM_LOCAL_SCRATCH\n        if qchem_local_scratch == QuaccDefault\n        else qchem_local_scratch\n    )\n    qchem_use_error_handlers = (\n        settings.QCHEM_USE_ERROR_HANDLERS\n        if qchem_use_error_handlers == QuaccDefault\n        else qchem_use_error_handlers\n    )\n    qchem_custodian_max_errors = (\n        settings.QCHEM_CUSTODIAN_MAX_ERRORS\n        if qchem_custodian_max_errors == QuaccDefault\n        else qchem_custodian_max_errors\n    )\n    qchem_nbo_exe = (\n        settings.QCHEM_NBO_EXE if qchem_nbo_exe == QuaccDefault else qchem_nbo_exe\n    )\n\n    # Error handlers for Q-Chem\n    handlers = [QChemErrorHandler()] if qchem_use_error_handlers else []\n\n    # Run Q-Chem\n    jobs = [\n        QCJob(\n            qchem_command=qchem_cmd,\n            max_cores=qchem_cores,\n            calc_loc=str(qchem_local_scratch),\n            nboexe=str(qchem_nbo_exe),\n        )\n    ]\n\n    c = Custodian(\n        handlers,\n        jobs,\n        max_errors=qchem_custodian_max_errors,\n        terminate_on_nonzero_returncode=False,\n        directory=directory,\n    )\n\n    return c.run()\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/io.html","title":"io","text":"<p>I/O utilities for the Vasp calculator.</p>"},{"location":"reference/quacc/calculators/vasp/io.html#quacc.calculators.vasp.io.load_vasp_yaml_calc","title":"load_vasp_yaml_calc","text":"<pre><code>load_vasp_yaml_calc(\n    yaml_path: str | Path,\n) -&gt; dict[str, Any]\n</code></pre> <p>Loads a YAML file containing calculator settings. Used for VASP calculations and can read quacc-formatted YAMLs that are of the following format: <pre><code>inputs:\n  xc: pbe\n  algo: all\n  setups:\n    Cu: Cu_pv\n  elemental_magmoms:\n    Fe: 5\n    Cu: 1\n</code></pre> where <code>inputs</code> is a dictionary of ASE-style input parameters, <code>setups</code> is a dictionary of ASE-style pseudopotentials, and and <code>elemental_magmoms</code> is a dictionary of element-wise initial magmoms.</p> <p>Parameters:</p> <ul> <li> <code>yaml_path</code>               (<code>str | Path</code>)           \u2013            <p>Path to the YAML file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>quacc/calculators/vasp/io.py</code> <pre><code>def load_vasp_yaml_calc(yaml_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Loads a YAML file containing calculator settings. Used for VASP calculations\n    and can read quacc-formatted YAMLs that are of the following format:\n    ```yaml\n    inputs:\n      xc: pbe\n      algo: all\n      setups:\n        Cu: Cu_pv\n      elemental_magmoms:\n        Fe: 5\n        Cu: 1\n    ```\n    where `inputs` is a dictionary of ASE-style input parameters, `setups` is a\n    dictionary of ASE-style pseudopotentials, and and `elemental_magmoms` is a\n    dictionary of element-wise initial magmoms.\n\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file.\n\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n    config = load_yaml_calc(yaml_path)\n\n    # Allow for either \"Cu_pv\" and \"_pv\" style setups\n    if \"inputs\" in config:\n        config[\"inputs\"] = {\n            k.lower(): v.lower() if isinstance(v, str) else v\n            for k, v in config[\"inputs\"].items()\n        }\n        for k, v in config[\"inputs\"].get(\"setups\", {}).items():\n            if k in v:\n                config[\"inputs\"][\"setups\"][k] = v.split(k)[-1]\n\n    return config\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html","title":"params","text":"<p>Parameter-related utilities for the Vasp calculator.</p>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.has_atomate2","title":"has_atomate2  <code>module-attribute</code>","text":"<pre><code>has_atomate2 = bool(find_spec('atomate2'))\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter","title":"MPtoASEConverter","text":"<pre><code>MPtoASEConverter(\n    atoms: Atoms | None = None,\n    prev_dir: SourceDirectory | None = None,\n)\n</code></pre> <p>Convert an MP-formatted input set to an ASE-formatted input set.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | None</code>, default:                   <code>None</code> )           \u2013            <p>The ASE atoms object.</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The previous directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def __init__(\n    self, atoms: Atoms | None = None, prev_dir: SourceDirectory | None = None\n) -&gt; None:\n    \"\"\"\n    Initialize the converter.\n\n    Parameters\n    ----------\n    atoms\n        The ASE atoms object.\n    prev_dir\n        The previous directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if atoms is None and prev_dir is None:\n        raise ValueError(\"Either atoms or prev_dir must be provided.\")\n    self.atoms = atoms\n    self.prev_dir = prev_dir\n    if self.atoms:\n        self.ase_sort, self.ase_resort = Vasp_()._make_sort(self.atoms)\n        self.structure = AseAtomsAdaptor.get_structure(self.atoms[self.ase_sort])\n    else:\n        self.structure = None\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = atoms\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter.prev_dir","title":"prev_dir  <code>instance-attribute</code>","text":"<pre><code>prev_dir = prev_dir\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure = get_structure(atoms[ase_sort])\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter.convert_input_generator","title":"convert_input_generator","text":"<pre><code>convert_input_generator(\n    input_generator: VaspInputGenerator,\n) -&gt; dict\n</code></pre> <p>Convert a VaspInputGenerator to a dictionary of ASE VASP parameters.</p> <p>Parameters:</p> <ul> <li> <code>input_generator</code>               (<code>VaspInputGenerator</code>)           \u2013            <p>The instantiated VaspInputGenerator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The ASE VASP parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>@requires(has_atomate2, \"atomate2 is not installed.\")\ndef convert_input_generator(self, input_generator: VaspInputGenerator) -&gt; dict:\n    \"\"\"\n    Convert a VaspInputGenerator to a dictionary of ASE VASP parameters.\n\n    Parameters\n    ----------\n    input_generator\n        The instantiated VaspInputGenerator.\n\n    Returns\n    -------\n    dict\n        The ASE VASP parameters.\n    \"\"\"\n    assert hasattr(input_generator, \"sort_structure\")\n    input_generator.sort_structure = False\n    input_set = input_generator.get_input_set(\n        structure=self.structure, potcar_spec=True, prev_dir=self.prev_dir\n    )\n    self.incar_dict = input_set.incar\n    self.pmg_kpts = input_set.kpoints\n    self.potcar_symbols = (\n        input_set.potcar.split(\"\\n\")\n        if isinstance(input_set.potcar, str)\n        else input_set.potcar\n    )\n    self.potcar_functional = input_generator.potcar_functional\n    self.poscar = input_set.poscar\n    return self._convert()\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter.convert_input_set","title":"convert_input_set","text":"<pre><code>convert_input_set(input_set: VaspInputSet) -&gt; dict\n</code></pre> <p>Convert a Pymatgen VaspInputSet to a dictionary of ASE VASP parameters.</p> <p>Parameters:</p> <ul> <li> <code>input_set</code>               (<code>VaspInputSet</code>)           \u2013            <p>The instantiated Pymatgen VaspInputSet.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The ASE VASP parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def convert_input_set(self, input_set: VaspInputSet) -&gt; dict:\n    \"\"\"\n    Convert a Pymatgen VaspInputSet to a dictionary of ASE VASP parameters.\n\n    Parameters\n    ----------\n    input_set\n        The instantiated Pymatgen VaspInputSet.\n\n    Returns\n    -------\n    dict\n        The ASE VASP parameters.\n    \"\"\"\n    assert hasattr(input_set, \"sort_structure\")\n    input_set.sort_structure = False\n    vasp_input = input_set.get_input_set(\n        structure=self.structure, potcar_spec=True, prev_dir=self.prev_dir\n    )\n    self.incar_dict = vasp_input[\"INCAR\"]\n    self.pmg_kpts = vasp_input.get(\"KPOINTS\")\n    self.potcar_symbols = vasp_input[\"POTCAR.spec\"].split(\"\\n\")\n    self.potcar_functional = input_set.potcar_functional\n    self.poscar = vasp_input[\"POSCAR\"]\n    return self._convert()\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.MPtoASEConverter.convert_maker","title":"convert_maker","text":"<pre><code>convert_maker(VaspMaker: BaseVaspMaker) -&gt; dict\n</code></pre> <p>Convert an atomate2 VaspMaker to a dictionary of ASE VASP parameters.</p> <p>Parameters:</p> <ul> <li> <code>VaspMaker</code>               (<code>BaseVaspMaker</code>)           \u2013            <p>The instantiated atomate2 VaspMaker.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The ASE VASP parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>@requires(has_atomate2, \"atomate2 is not installed.\")\ndef convert_maker(self, VaspMaker: BaseVaspMaker) -&gt; dict:\n    \"\"\"\n    Convert an atomate2 VaspMaker to a dictionary of ASE VASP parameters.\n\n    Parameters\n    ----------\n    VaspMaker\n        The instantiated atomate2 VaspMaker.\n\n    Returns\n    -------\n    dict\n        The ASE VASP parameters.\n    \"\"\"\n    return self.convert_input_generator(VaspMaker.input_set_generator)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.get_param_swaps","title":"get_param_swaps","text":"<pre><code>get_param_swaps(\n    user_calc_params: dict[str, Any],\n    input_atoms: Atoms,\n    pmg_kpts: (\n        dict[\n            Literal[\"line_density\", \"kppvol\", \"kppa\"], float\n        ]\n        | None\n    ) = None,\n    incar_copilot_mode: Literal[\n        \"off\", \"on\", \"aggressive\", \"ncore\"\n    ] = \"on\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Swaps out bad INCAR flags.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The user-provided calculator parameters.</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input atoms.</p> </li> <li> <code>pmg_kpts</code>               (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pmg_kpts kwarg.</p> </li> <li> <code>incar_copilot_mode</code>               (<code>Literal['off', 'on', 'aggressive', 'ncore']</code>, default:                   <code>'on'</code> )           \u2013            <p>INCAR copilot mode. See <code>quacc.calculators.vasp.vasp.Vasp</code> for more info.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def get_param_swaps(\n    user_calc_params: dict[str, Any],\n    input_atoms: Atoms,\n    pmg_kpts: dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float] | None = None,\n    incar_copilot_mode: Literal[\"off\", \"on\", \"aggressive\", \"ncore\"] = \"on\",\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Swaps out bad INCAR flags.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n    input_atoms\n        The input atoms.\n    pmg_kpts\n        The pmg_kpts kwarg.\n    incar_copilot_mode\n        INCAR copilot mode. See `quacc.calculators.vasp.vasp.Vasp` for more info.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n    is_metal = check_is_metal(input_atoms)\n    calc = Vasp_(**remove_unused_flags(user_calc_params))\n    max_Z = input_atoms.get_atomic_numbers().max()\n\n    if calc.parameters.get(\"lmaxmix\", 2) &lt; 6 and max_Z &gt; 56:\n        LOGGER.info(\"Recommending LMAXMIX = 6 because you have f electrons.\")\n        calc.set(lmaxmix=6)\n    elif calc.parameters.get(\"lmaxmix\", 2) &lt; 4 and max_Z &gt; 20:\n        LOGGER.info(\"Recommending LMAXMIX = 4 because you have d electrons.\")\n        calc.set(lmaxmix=4)\n\n    if (\n        calc.parameters.get(\"luse_vdw\", False)\n        or calc.parameters.get(\"lhfcalc\", False)\n        or calc.parameters.get(\"ldau\", False)\n        or calc.parameters.get(\"ldau_luj\", {})\n        or calc.parameters.get(\"metagga\", \"\")\n    ) and not calc.parameters.get(\"lasph\"):\n        LOGGER.info(\n            \"Recommending LASPH = True because you have a +U, vdW, meta-GGA, or hybrid calculation.\"\n        )\n        calc.set(lasph=True)\n\n    if calc.parameters.get(\"metagga\", \"\") and (\n        calc.parameters.get(\"algo\", \"normal\").lower() != \"all\"\n    ):\n        LOGGER.info(\"Recommending ALGO = All because you have a meta-GGA calculation.\")\n        calc.set(algo=\"all\", isearch=1)\n\n    if calc.parameters.get(\"lhfcalc\", False) and (\n        calc.parameters.get(\"algo\", \"normal\").lower() != \"normal\"\n    ):\n        LOGGER.info(\"Recommending ALGO = Normal because you have a hybrid calculation.\")\n        calc.set(algo=\"normal\")\n\n    if (\n        is_metal\n        and (calc.parameters.get(\"ismear\", 1) &lt; 0)\n        and (calc.parameters.get(\"nsw\", 0) &gt; 0)\n    ):\n        LOGGER.info(\n            \"Recommending ISMEAR = 1 and SIGMA = 0.1 because you are likely relaxing a metal.\"\n        )\n        calc.set(ismear=1, sigma=0.1)\n\n    if (\n        calc.parameters.get(\"ismear\", 1) != -5\n        and calc.parameters.get(\"nsw\", 0) == 0\n        and (\n            (calc.kpts is not None and np.prod(calc.kpts) &gt;= 4)\n            or (calc.float_params[\"kspacing\"] and calc.float_params[\"kspacing\"] &lt;= 0.5)\n        )\n    ):\n        LOGGER.info(\"Recommending ISMEAR = -5 because you have a static calculation.\")\n        calc.set(ismear=-5)\n\n    if (\n        calc.parameters.get(\"ismear\", 1) == -5\n        and (calc.kpts is not None and np.prod(calc.kpts) &lt; 4)\n        and calc.parameters.get(\"kspacing\", None) is None\n    ):\n        LOGGER.info(\n            \"Recommending ISMEAR = 0 because you don't have enough k-points for ISMEAR = -5.\"\n        )\n        calc.set(ismear=0)\n\n    if (\n        calc.parameters.get(\"kspacing\", 0.5) &gt; 0.5\n        and calc.parameters.get(\"ismear\", 1) == -5\n    ):\n        LOGGER.info(\n            \"Recommending ISMEAR = 0 because KSPACING is likely too large for ISMEAR = -5.\"\n        )\n        calc.set(ismear=0)\n\n    if (\n        pmg_kpts\n        and pmg_kpts.get(\"line_density\")\n        and calc.parameters.get(\"ismear\", 1) != 0\n    ):\n        LOGGER.info(\n            \"Recommending ISMEAR = 0 and SIGMA = 0.01 because you are doing a line mode calculation.\"\n        )\n        calc.set(ismear=0, sigma=0.01)\n\n    if calc.parameters.get(\"ismear\", 1) == 0 and (\n        calc.parameters.get(\"sigma\", 0.2) &gt; 0.05\n    ):\n        LOGGER.info(\n            \"Recommending SIGMA = 0.05 because ISMEAR = 0 was requested with SIGMA &gt; 0.05.\"\n        )\n        calc.set(sigma=0.05)\n\n    if calc.parameters.get(\"nsw\", 0) &gt; 0 and calc.parameters.get(\"laechg\", False):\n        LOGGER.info(\n            \"Recommending LAECHG = False because you have NSW &gt; 0. LAECHG is not compatible with NSW &gt; 0.\"\n        )\n        calc.set(laechg=False)\n\n    if calc.parameters.get(\"ldauprint\", 0) == 0 and (\n        calc.parameters.get(\"ldau\", False) or calc.parameters.get(\"ldau_luj\", {})\n    ):\n        LOGGER.info(\"Recommending LDAUPRINT = 1 because LDAU = True.\")\n        calc.set(ldauprint=1)\n\n    if calc.parameters.get(\"lreal\", False) and len(input_atoms) &lt; 30:\n        LOGGER.info(\n            \"Recommending LREAL = False because you have a small system (&lt; 30 atoms/cell).\"\n        )\n        calc.set(lreal=False)\n\n    if not calc.parameters.get(\"lorbit\", False) and (\n        calc.parameters.get(\"ispin\", 1) == 2\n        or np.any(input_atoms.get_initial_magnetic_moments() != 0)\n    ):\n        LOGGER.info(\n            \"Recommending LORBIT = 11 because you have a spin-polarized calculation.\"\n        )\n        calc.set(lorbit=11)\n\n    if not calc.parameters.get(\"npar\") and not calc.parameters.get(\"ncore\"):\n        ncores = psutil.cpu_count(logical=False) or 1\n        for ncore in range(int(np.sqrt(ncores)), ncores):\n            if ncores % ncore == 0:\n                LOGGER.info(\n                    f\"Recommending NCORE = {ncore} per the sqrt(# cores) suggestion by VASP.\"\n                )\n                calc.set(ncore=ncore, npar=None)\n                break\n\n    if (\n        calc.parameters.get(\"ncore\", 1) &gt; 1\n        or (calc.parameters.get(\"npar\") and calc.parameters.get(\"npar\", 1) &gt; 1)\n    ) and (\n        calc.parameters.get(\"lhfcalc\", False) is True\n        or calc.parameters.get(\"lrpa\", False) is True\n        or calc.parameters.get(\"lepsilon\", False) is True\n        or calc.parameters.get(\"ibrion\", 0) in [5, 6, 7, 8]\n    ):\n        LOGGER.info(\n            \"Recommending NCORE = 1 because NCORE/NPAR is not compatible with this job type.\"\n        )\n        calc.set(ncore=1, npar=None)\n\n    if (\n        calc.parameters.get(\"kpar\")\n        and (\n            calc.kpts is not None\n            and calc.parameters.get(\"kpar\", 1) &gt; np.prod(calc.kpts)\n        )\n        and calc.float_params[\"kspacing\"] is None\n    ):\n        LOGGER.info(\n            \"Recommending KPAR = 1 because you have too few k-points to parallelize.\"\n        )\n        calc.set(kpar=1)\n\n    if (\n        calc.parameters.get(\"lhfcalc\", False) is True\n        and calc.parameters.get(\"isym\", 3) &lt; 3\n    ):\n        LOGGER.info(\n            \"Recommending ISYM = 3 because you are running a hybrid calculation.\"\n        )\n        calc.set(isym=3)\n\n    if calc.parameters.get(\"lsorbit\", False):\n        LOGGER.info(\n            \"Recommending ISYM = -1 because you are running an SOC calculation.\"\n        )\n        calc.set(isym=-1)\n\n    if (\n        calc.parameters.get(\"algo\", \"normal\") in (\"all\", \"conjugate\")\n        and calc.parameters.get(\"isearch\", 0) != 1\n    ):\n        LOGGER.info(\"Recommending ISEARCH = 1 because you have ALGO = All.\")\n        calc.set(isearch=1)\n\n    if (\n        calc.parameters.get(\"isif\", 2) in (3, 6, 7, 8)\n        and calc.parameters.get(\"nsw\", 0) &gt; 0\n    ):\n        if calc.encut is None:\n            LOGGER.warning(\n                \"Be careful of Pulay stresses. At the end of your run, re-relax your structure with your current ENCUT or set ENCUT=1.3*max(ENMAX).\"\n            )\n        if \"He\" in input_atoms.get_chemical_symbols() and (\n            calc.encut is None or calc.encut &lt; 478.896 * 1.3\n        ):\n            LOGGER.warning(\n                \"Be careful of Pulay stresses. At the end of your run, re-relax your structure with your current ENCUT or set ENCUT&gt;=623.\"\n            )\n\n        if (\n            \"Li\" in input_atoms.get_chemical_symbols()\n            and calc.parameters.get(\"setups\", {})\n            and isinstance(calc.parameters[\"setups\"], dict)\n            and calc.parameters[\"setups\"].get(\"Li\", \"\") in (\"Li_sv\", \"_sv\")\n            and (calc.encut is None or calc.encut &lt; 499.034 * 1.3)\n        ):\n            LOGGER.warning(\n                \"Be careful of Pulay stresses. At the end of your run, re-relax your structure with your current ENCUT or set ENCUT&gt;=650.\"\n            )\n\n    if (\n        calc.parameters.get(\"metagga\", \"\").lower() == \"r2scan\"\n        and calc.parameters.get(\"ivdw\", 0) == 13\n        and not calc.parameters.get(\"vdw_s6\")\n        and not calc.parameters.get(\"vdw_s8\")\n        and not calc.parameters.get(\"vdw_a1\")\n        and not calc.parameters.get(\"vdw_a2\")\n    ):\n        LOGGER.info(\"Setting VDW_S6, VDW_S8, VDW_A1, VDW_A2 parameters for r2SCAN-D4.\")\n        calc.set(vdw_s6=1.0, vdw_s8=0.60187490, vdw_a1=0.51559235, vdw_a2=5.77342911)\n\n    if (\n        calc.parameters.get(\"lhfcalc\", False)\n        and calc.parameters.get(\"hfscreen\", 0) == 0.2\n        and calc.parameters.get(\"ivdw\", 1) == 12\n        and not calc.parameters.get(\"vdw_s6\")\n        and not calc.parameters.get(\"vdw_s8\")\n        and not calc.parameters.get(\"vdw_a1\")\n        and not calc.parameters.get(\"vdw_a2\")\n    ):\n        LOGGER.info(\n            \"Setting VDW_S6, VDW_S8, VDW_A1, VDW_A2 parameters for HSE06-D3(BJ).\"\n        )\n        calc.set(vdw_s6=1.0, vdw_s8=2.310, vdw_a1=0.383, vdw_a2=5.685)\n\n    if input_atoms.get_chemical_formula() == \"O2\" and all(\n        input_atoms.get_initial_magnetic_moments() == 0\n    ):\n        LOGGER.warning(\n            \"You are running O2 without magnetic moments, but its ground state should have 2 unpaired electrons!\"\n        )\n\n    if incar_copilot_mode == \"aggressive\":\n        new_parameters = calc.parameters\n    elif incar_copilot_mode == \"on\":\n        new_parameters = calc.parameters | user_calc_params\n    elif incar_copilot_mode == \"ncore\":\n        new_parameters = {\n            \"ncore\": calc.parameters.get(\"ncore\"),\n            \"npar\": calc.parameters.get(\"npar\"),\n        } | user_calc_params\n    else:\n        new_parameters = user_calc_params\n\n    if changed_parameters := {\n        k: new_parameters[k] for k in set(new_parameters) - set(user_calc_params)\n    }:\n        LOGGER.info(\n            f\"The following parameters were changed: {sort_dict(changed_parameters)}\"\n        )\n\n    return new_parameters\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.normalize_params","title":"normalize_params","text":"<pre><code>normalize_params(\n    user_calc_params: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Normalizes the user-provided calculator parameters.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The user-provided calculator parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def normalize_params(user_calc_params: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Normalizes the user-provided calculator parameters.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n    return {\n        (k.lower() if isinstance(k, str) else k): (\n            v.lower() if isinstance(v, str) else v\n        )\n        for k, v in user_calc_params.items()\n    }\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.remove_unused_flags","title":"remove_unused_flags","text":"<pre><code>remove_unused_flags(\n    user_calc_params: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Removes unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The updated user-provided calculator parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def remove_unused_flags(user_calc_params: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Removes unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.\n\n    Parameters\n    ----------\n    user_calc_params\n        The updated user-provided calculator parameters.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n    new_user_calc_params = user_calc_params.copy()\n    if new_user_calc_params.get(\"nsw\", 0) == 0:\n        # Turn off opt flags if NSW = 0\n        opt_flags = (\"ediffg\", \"ibrion\", \"potim\", \"iopt\")\n        for opt_flag in opt_flags:\n            new_user_calc_params.pop(opt_flag, None)\n\n    if not new_user_calc_params.get(\"ldau\", False) and not new_user_calc_params.get(\n        \"ldau_luj\"\n    ):\n        # Turn off +U flags if +U is not even used\n        ldau_flags = (\n            \"ldau\",\n            \"ldauu\",\n            \"ldauj\",\n            \"ldaul\",\n            \"ldautype\",\n            \"ldauprint\",\n            \"ldau_luj\",\n        )\n        for ldau_flag in ldau_flags:\n            new_user_calc_params.pop(ldau_flag, None)\n\n    # Handle kspacing flags\n    if new_user_calc_params.get(\"kspacing\"):\n        new_user_calc_params[\"gamma\"] = None\n        new_user_calc_params[\"kpts\"] = None\n    else:\n        new_user_calc_params.pop(\"kgamma\", None)\n\n    # Remove None keys\n    none_keys = [\n        k\n        for k, v in new_user_calc_params.items()\n        if v is None and k not in Vasp_().input_params\n    ]\n    for none_key in none_keys:\n        del new_user_calc_params[none_key]\n\n    return new_user_calc_params\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.set_auto_dipole","title":"set_auto_dipole","text":"<pre><code>set_auto_dipole(\n    user_calc_params: dict[str, Any], input_atoms: Atoms\n) -&gt; dict[str, Any]\n</code></pre> <p>Sets flags related to the auto_dipole kwarg.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The user-provided calculator parameters.</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input atoms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def set_auto_dipole(\n    user_calc_params: dict[str, Any], input_atoms: Atoms\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Sets flags related to the auto_dipole kwarg.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n    input_atoms\n        The input atoms.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n    com = input_atoms.get_center_of_mass(scaled=True)\n    if \"dipol\" not in user_calc_params:\n        user_calc_params[\"dipol\"] = com\n    if \"idipol\" not in user_calc_params:\n        user_calc_params[\"idipol\"] = 3\n    if \"ldipol\" not in user_calc_params:\n        user_calc_params[\"ldipol\"] = True\n\n    return user_calc_params\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/params.html#quacc.calculators.vasp.params.set_pmg_kpts","title":"set_pmg_kpts","text":"<pre><code>set_pmg_kpts(\n    user_calc_params: PmgKpts,\n    pmg_kpts: dict[\n        Literal[\"line_density\", \"kppvol\", \"kppa\"], float\n    ],\n    input_atoms: Atoms,\n) -&gt; dict[str, Any]\n</code></pre> <p>Shortcuts for pymatgen k-point generation schemes.</p> <p>Parameters:</p> <ul> <li> <code>user_calc_params</code>               (<code>PmgKpts</code>)           \u2013            <p>The user-provided calculator parameters.</p> </li> <li> <code>pmg_kpts</code>               (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float]</code>)           \u2013            <p>The pmg_kpts kwarg.</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input atoms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The updated user-provided calculator parameters.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/params.py</code> <pre><code>def set_pmg_kpts(\n    user_calc_params: PmgKpts,\n    pmg_kpts: dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float],\n    input_atoms: Atoms,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Shortcuts for pymatgen k-point generation schemes.\n\n    Parameters\n    ----------\n    user_calc_params\n        The user-provided calculator parameters.\n    pmg_kpts\n        The pmg_kpts kwarg.\n    input_atoms\n        The input atoms.\n\n    Returns\n    -------\n    dict\n        The updated user-provided calculator parameters.\n    \"\"\"\n    kpts, gamma = convert_pmg_kpts(\n        pmg_kpts, input_atoms, force_gamma=user_calc_params.get(\"gamma\", False)\n    )\n    reciprocal = bool(pmg_kpts.get(\"line_density\"))\n\n    user_calc_params[\"kpts\"] = kpts\n    if reciprocal and user_calc_params.get(\"reciprocal\") is None:\n        user_calc_params[\"reciprocal\"] = reciprocal\n    if user_calc_params.get(\"gamma\") is None:\n        user_calc_params[\"gamma\"] = gamma\n\n    return user_calc_params\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html","title":"vasp","text":"<p>A wrapper around ASE's Vasp calculator that makes it better suited for high-throughput DFT.</p>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp","title":"Vasp","text":"<pre><code>Vasp(\n    input_atoms: Atoms,\n    preset: None | str | Path = None,\n    use_custodian: bool | DefaultSetting = QuaccDefault,\n    incar_copilot: (\n        Literal[\"off\", \"on\", \"aggressive\", \"ncore\"]\n        | DefaultSetting\n    ) = QuaccDefault,\n    copy_magmoms: bool | DefaultSetting = QuaccDefault,\n    preset_mag_default: (\n        float | DefaultSetting\n    ) = QuaccDefault,\n    mag_cutoff: float | DefaultSetting = QuaccDefault,\n    elemental_magmoms: dict[str, float] | None = None,\n    pmg_kpts: (\n        dict[\n            Literal[\"line_density\", \"kppvol\", \"kppa\"], float\n        ]\n        | dict[Literal[\"length_densities\"], list[float]]\n        | None\n    ) = None,\n    auto_dipole: bool | None = None,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Vasp</code></p> <p>This is a wrapper around the ASE Vasp calculator that adjusts INCAR parameters on-the-fly, allows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes from Pymatgen.</p> <p>Parameters:</p> <ul> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input Atoms object to be used for the calculation.</p> </li> <li> <code>preset</code>               (<code>None | str | Path</code>, default:                   <code>None</code> )           \u2013            <p>A YAML file containing a list of INCAR parameters to use as a \"preset\" for the calculator. If <code>preset</code> has a .yml or .yaml file extension, the path to this file will be used directly. If <code>preset</code> is a string without an extension, the corresponding YAML file will be assumed to be in the <code>VASP_PRESET_DIR</code>. Any user-supplied calculator **kwargs will override any corresponding preset values.</p> </li> <li> <code>use_custodian</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether to use Custodian to run VASP. Default is True in settings.</p> </li> <li> <code>incar_copilot</code>               (<code>Literal['off', 'on', 'aggressive', 'ncore'] | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Controls VASP co-pilot mode for automated INCAR parameter handling.</p> <p>Options include:     off: Do not use co-pilot mode. INCAR parameters will be unmodified.     on: Use co-pilot mode. This will only modify INCAR flags not already set         by the user.     aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR         flags even if they are already set by the user.     ncore: Only automatically set NCORE based on the number of available cores.</p> </li> <li> <code>copy_magmoms</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>If True, any pre-existing <code>atoms.get_magnetic_moments()</code> will be set in <code>atoms.set_initial_magnetic_moments()</code>. Set this to False if you want to use a preset's magnetic moments every time. Default is True in settings.</p> </li> <li> <code>preset_mag_default</code>               (<code>float | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Default magmom value for sites without one explicitly specified in the preset. Only used if a preset is specified with an elemental_mags_dict key-value pair. Default is 1.0 in settings.</p> </li> <li> <code>mag_cutoff</code>               (<code>float | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Set all initial magmoms to 0 if all have a magnitude below this value. Default is 0.05 in settings.</p> </li> <li> <code>elemental_magmoms</code>               (<code>dict[str, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of elemental initial magnetic moments to pass to quacc.schemas.prep.set_magmoms, e.g. <code>{\"Fe\": 5, \"Ni\": 4}</code>.</p> </li> <li> <code>pmg_kpts</code>               (<code>dict[Literal['line_density', 'kppvol', 'kppa'], float] | dict[Literal['length_densities'], list[float]] | None</code>, default:                   <code>None</code> )           \u2013            <p>An automatic k-point generation scheme from Pymatgen. See quacc.utils.kpts.convert_pmg_kpts for details.</p> </li> <li> <code>auto_dipole</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>If True, will automatically set dipole moment correction parameters based on the center of mass (in the c dimension by default).</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional arguments to be passed to the VASP calculator, e.g. <code>xc='PBE'</code>, <code>encut=520</code>. Takes all valid ASE calculator arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/calculators/vasp/vasp.py</code> <pre><code>def __init__(\n    self,\n    input_atoms: Atoms,\n    preset: None | str | Path = None,\n    use_custodian: bool | DefaultSetting = QuaccDefault,\n    incar_copilot: Literal[\"off\", \"on\", \"aggressive\", \"ncore\"]\n    | DefaultSetting = QuaccDefault,\n    copy_magmoms: bool | DefaultSetting = QuaccDefault,\n    preset_mag_default: float | DefaultSetting = QuaccDefault,\n    mag_cutoff: float | DefaultSetting = QuaccDefault,\n    elemental_magmoms: dict[str, float] | None = None,\n    pmg_kpts: (\n        dict[Literal[\"line_density\", \"kppvol\", \"kppa\"], float]\n        | dict[Literal[\"length_densities\"], list[float]]\n        | None\n    ) = None,\n    auto_dipole: bool | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initialize the VASP calculator.\n\n    Parameters\n    ----------\n    input_atoms\n        The input Atoms object to be used for the calculation.\n    preset\n        A YAML file containing a list of INCAR parameters to use as a \"preset\"\n        for the calculator. If `preset` has a .yml or .yaml file extension, the\n        path to this file will be used directly. If `preset` is a string without\n        an extension, the corresponding YAML file will be assumed to be in the\n        `VASP_PRESET_DIR`. Any user-supplied calculator **kwargs will\n        override any corresponding preset values.\n    use_custodian\n        Whether to use Custodian to run VASP. Default is True in settings.\n    incar_copilot\n        Controls VASP co-pilot mode for automated INCAR parameter handling.\n\n        Options include:\n            off: Do not use co-pilot mode. INCAR parameters will be unmodified.\n            on: Use co-pilot mode. This will only modify INCAR flags not already set\n                by the user.\n            aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR\n                flags even if they are already set by the user.\n            ncore: Only automatically set NCORE based on the number of available cores.\n    copy_magmoms\n        If True, any pre-existing `atoms.get_magnetic_moments()` will be set in\n        `atoms.set_initial_magnetic_moments()`. Set this to False if you want to\n        use a preset's magnetic moments every time. Default is True in settings.\n    preset_mag_default\n        Default magmom value for sites without one explicitly specified in the\n        preset. Only used if a preset is specified with an elemental_mags_dict\n        key-value pair. Default is 1.0 in settings.\n    mag_cutoff\n        Set all initial magmoms to 0 if all have a magnitude below this value.\n        Default is 0.05 in settings.\n    elemental_magmoms\n        A dictionary of elemental initial magnetic moments to pass to\n        [quacc.schemas.prep.set_magmoms][], e.g. `{\"Fe\": 5, \"Ni\": 4}`.\n    pmg_kpts\n        An automatic k-point generation scheme from Pymatgen. See\n        [quacc.utils.kpts.convert_pmg_kpts][] for details.\n    auto_dipole\n        If True, will automatically set dipole moment correction parameters\n        based on the center of mass (in the c dimension by default).\n    **kwargs\n        Additional arguments to be passed to the VASP calculator, e.g.\n        `xc='PBE'`, `encut=520`. Takes all valid ASE calculator arguments.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._settings = get_settings()\n\n    # Set defaults\n    use_custodian = (\n        self._settings.VASP_USE_CUSTODIAN\n        if use_custodian == QuaccDefault\n        else use_custodian\n    )\n    incar_copilot = (\n        self._settings.VASP_INCAR_COPILOT\n        if incar_copilot == QuaccDefault\n        else incar_copilot\n    )\n    copy_magmoms = (\n        self._settings.VASP_COPY_MAGMOMS\n        if copy_magmoms == QuaccDefault\n        else copy_magmoms\n    )\n    preset_mag_default = (\n        self._settings.VASP_PRESET_MAG_DEFAULT\n        if preset_mag_default == QuaccDefault\n        else preset_mag_default\n    )\n    mag_cutoff = (\n        self._settings.VASP_MAG_CUTOFF if mag_cutoff == QuaccDefault else mag_cutoff\n    )\n\n    # Assign variables to self\n    self.input_atoms = input_atoms\n    self.preset = preset\n    self.use_custodian = use_custodian\n    self.incar_copilot = incar_copilot\n    self.copy_magmoms = copy_magmoms\n    self.preset_mag_default = preset_mag_default\n    self.mag_cutoff = mag_cutoff\n    self.elemental_magmoms = elemental_magmoms\n    self.pmg_kpts = pmg_kpts\n    self.auto_dipole = auto_dipole\n    self.kwargs = normalize_params(kwargs)\n\n    # Initialize for later\n    self.user_calc_params: dict[str, Any] = {}\n\n    # Cleanup parameters\n    self._cleanup_params()\n\n    # Get VASP executable command, if necessary, and specify child\n    # environment variables\n    self.command = self._manage_environment()\n\n    # Instantiate the calculator!\n    super().__init__(\n        atoms=self.input_atoms, command=self.command, **self.user_calc_params\n    )\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.auto_dipole","title":"auto_dipole  <code>instance-attribute</code>","text":"<pre><code>auto_dipole = auto_dipole\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command = _manage_environment()\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.copy_magmoms","title":"copy_magmoms  <code>instance-attribute</code>","text":"<pre><code>copy_magmoms = copy_magmoms\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.elemental_magmoms","title":"elemental_magmoms  <code>instance-attribute</code>","text":"<pre><code>elemental_magmoms = elemental_magmoms\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.incar_copilot","title":"incar_copilot  <code>instance-attribute</code>","text":"<pre><code>incar_copilot = incar_copilot\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.input_atoms","title":"input_atoms  <code>instance-attribute</code>","text":"<pre><code>input_atoms = input_atoms\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs = normalize_params(kwargs)\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.mag_cutoff","title":"mag_cutoff  <code>instance-attribute</code>","text":"<pre><code>mag_cutoff = mag_cutoff\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.pmg_kpts","title":"pmg_kpts  <code>instance-attribute</code>","text":"<pre><code>pmg_kpts = pmg_kpts\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.preset","title":"preset  <code>instance-attribute</code>","text":"<pre><code>preset = preset\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.preset_mag_default","title":"preset_mag_default  <code>instance-attribute</code>","text":"<pre><code>preset_mag_default = preset_mag_default\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.use_custodian","title":"use_custodian  <code>instance-attribute</code>","text":"<pre><code>use_custodian = use_custodian\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp.user_calc_params","title":"user_calc_params  <code>instance-attribute</code>","text":"<pre><code>user_calc_params: dict[str, Any] = {}\n</code></pre>"},{"location":"reference/quacc/calculators/vasp/vasp_custodian.html","title":"vasp_custodian","text":"<p>Custodian handlers for VASP.</p>"},{"location":"reference/quacc/calculators/vasp/vasp_custodian.html#quacc.calculators.vasp.vasp_custodian.run_custodian","title":"run_custodian","text":"<pre><code>run_custodian(\n    vasp_parallel_cmd: str | DefaultSetting = QuaccDefault,\n    vasp_cmd: str | DefaultSetting = QuaccDefault,\n    vasp_gamma_cmd: str | DefaultSetting = QuaccDefault,\n    vasp_custodian_max_errors: (\n        int | DefaultSetting\n    ) = QuaccDefault,\n    vasp_custodian_wall_time: (\n        float | DefaultSetting\n    ) = QuaccDefault,\n    vtst_fixes: bool | DefaultSetting = QuaccDefault,\n    vasp_custodian_handlers: (\n        list[str] | None | DefaultSetting\n    ) = QuaccDefault,\n    vasp_custodian_validators: (\n        list[str] | None | DefaultSetting\n    ) = QuaccDefault,\n    scratch_dir: str | None = None,\n    directory: str | Path | None = None,\n    vasp_job_kwargs: VaspJobKwargs | None = None,\n    custodian_kwargs: VaspCustodianKwargs | None = None,\n) -&gt; list[list[dict]]\n</code></pre> <p>Function to run VASP Custodian.</p> <p>Parameters:</p> <ul> <li> <code>vasp_parallel_cmd</code>               (<code>str | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults to the $VASP_PARALLEL_CMD environment variable in settings.</p> </li> <li> <code>vasp_cmd</code>               (<code>str | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>VASP command. Defaults to \"vasp_std\" in settings.</p> </li> <li> <code>vasp_gamma_cmd</code>               (<code>str | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>VASP gamma command. Defaults to \"vasp_gam\" in settings.</p> </li> <li> <code>vasp_custodian_max_errors</code>               (<code>int | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maximum number of errors to allow before stopping the run. Defaults to 5 in settings.</p> </li> <li> <code>vasp_custodian_wall_time</code>               (<code>float | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maximum wall time to allow before creating a STOPCAR. Defaults to infinity in settings.</p> </li> <li> <code>vtst_fixes</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether to apply VTST input swaps. Defaults to False in settings.</p> </li> <li> <code>vasp_custodian_handlers</code>               (<code>list[str] | None | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>List of handlers to use in Custodian. See settings for list.</p> </li> <li> <code>vasp_custodian_validators</code>               (<code>list[str] | None | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>List of validators to use in Custodian. See settings for list.</p> </li> <li> <code>scratch_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Scratch directory to use. Defaults to None.</p> </li> <li> <code>directory</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory to run the calculation in. Defaults to None.</p> </li> <li> <code>vasp_job_kwargs</code>               (<code>VaspJobKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to pass to the Custodian VaspJob. Defaults to None.</p> </li> <li> <code>custodian_kwargs</code>               (<code>VaspCustodianKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Any remaining keyword arguments to pass to Custodian. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[list[dict]]</code>           \u2013            <p>List of errors from each Custodian job.</p> </li> </ul> Source code in <code>quacc/calculators/vasp/vasp_custodian.py</code> <pre><code>def run_custodian(\n    vasp_parallel_cmd: str | DefaultSetting = QuaccDefault,\n    vasp_cmd: str | DefaultSetting = QuaccDefault,\n    vasp_gamma_cmd: str | DefaultSetting = QuaccDefault,\n    vasp_custodian_max_errors: int | DefaultSetting = QuaccDefault,\n    vasp_custodian_wall_time: float | DefaultSetting = QuaccDefault,\n    vtst_fixes: bool | DefaultSetting = QuaccDefault,\n    vasp_custodian_handlers: list[str] | None | DefaultSetting = QuaccDefault,\n    vasp_custodian_validators: list[str] | None | DefaultSetting = QuaccDefault,\n    scratch_dir: str | None = None,\n    directory: str | Path | None = None,\n    vasp_job_kwargs: VaspJobKwargs | None = None,\n    custodian_kwargs: VaspCustodianKwargs | None = None,\n) -&gt; list[list[dict]]:\n    \"\"\"\n    Function to run VASP Custodian.\n\n    Parameters\n    ----------\n    vasp_parallel_cmd\n        VASP parallel command, e.g. \"srun -N 2 --ntasks-per-node=24\". Defaults\n        to the $VASP_PARALLEL_CMD environment variable in settings.\n    vasp_cmd\n        VASP command. Defaults to \"vasp_std\" in settings.\n    vasp_gamma_cmd\n        VASP gamma command. Defaults to \"vasp_gam\" in settings.\n    vasp_custodian_max_errors\n        Maximum number of errors to allow before stopping the run. Defaults to 5\n        in settings.\n    vasp_custodian_wall_time\n        Maximum wall time to allow before creating a STOPCAR. Defaults to\n        infinity in settings.\n    vtst_fixes\n        Whether to apply VTST input swaps. Defaults to False in settings.\n    vasp_custodian_handlers\n        List of handlers to use in Custodian. See settings for list.\n    vasp_custodian_validators\n        List of validators to use in Custodian. See settings for list.\n    scratch_dir\n        Scratch directory to use. Defaults to None.\n    directory\n        Directory to run the calculation in. Defaults to None.\n    vasp_job_kwargs\n        Keyword arguments to pass to the Custodian VaspJob. Defaults to None.\n    custodian_kwargs\n        Any remaining keyword arguments to pass to Custodian. Defaults to None.\n\n    Returns\n    -------\n    list[list[dict]]\n        List of errors from each Custodian job.\n    \"\"\"\n    # Adapted from atomate2.vasp.run.run_vasp\n    settings: QuaccSettings = get_settings()\n\n    # Set defaults\n    vasp_parallel_cmd = os.path.expandvars(\n        settings.VASP_PARALLEL_CMD\n        if vasp_parallel_cmd == QuaccDefault\n        else vasp_parallel_cmd\n    )\n    vasp_cmd = settings.VASP_CMD if vasp_cmd == QuaccDefault else vasp_cmd\n    vasp_gamma_cmd = (\n        settings.VASP_GAMMA_CMD if vasp_gamma_cmd == QuaccDefault else vasp_gamma_cmd\n    )\n    vasp_custodian_max_errors = (\n        settings.VASP_CUSTODIAN_MAX_ERRORS\n        if vasp_custodian_max_errors == QuaccDefault\n        else vasp_custodian_max_errors\n    )\n    vasp_custodian_wall_time = (\n        settings.VASP_CUSTODIAN_WALL_TIME\n        if vasp_custodian_wall_time == QuaccDefault\n        else vasp_custodian_wall_time\n    )\n    vtst_fixes = (\n        settings.VASP_CUSTODIAN_VTST if vtst_fixes == QuaccDefault else vtst_fixes\n    )\n    vasp_custodian_handlers = (\n        settings.VASP_CUSTODIAN_HANDLERS\n        if vasp_custodian_handlers == QuaccDefault\n        else vasp_custodian_handlers\n    )\n\n    vasp_custodian_validators = (\n        settings.VASP_CUSTODIAN_VALIDATORS\n        if vasp_custodian_validators == QuaccDefault\n        else vasp_custodian_validators\n    )\n\n    # Handlers for VASP\n    handlers_dict = {\n        \"VaspErrorHandler\": VaspErrorHandler(vtst_fixes=vtst_fixes),\n        \"FrozenJobErrorHandler\": FrozenJobErrorHandler(),\n        \"IncorrectSmearingHandler\": IncorrectSmearingHandler(),\n        \"LargeSigmaHandler\": LargeSigmaHandler(),\n        \"MeshSymmetryErrorHandler\": MeshSymmetryErrorHandler(),\n        \"NonConvergingErrorHandler\": NonConvergingErrorHandler(),\n        \"PositiveEnergyErrorHandler\": PositiveEnergyErrorHandler(),\n        \"PotimErrorHandler\": PotimErrorHandler(),\n        \"StdErrHandler\": StdErrHandler(),\n        \"UnconvergedErrorHandler\": UnconvergedErrorHandler(),\n        \"WalltimeHandler\": WalltimeHandler(),\n        \"KspacingMetalHandler\": KspacingMetalHandler(),\n    }\n    validators_dict = {\n        \"VaspFilesValidator\": VaspFilesValidator(),\n        \"VasprunXMLValidator\": VasprunXMLValidator(),\n    }\n\n    handlers = []\n    if vasp_custodian_handlers is None:\n        vasp_custodian_handlers = []\n\n    for handler_flag in vasp_custodian_handlers:\n        if handler_flag not in handlers_dict:\n            msg = f\"Unknown VASP error handler: {handler_flag}\"\n            raise ValueError(msg)\n        handlers.append(handlers_dict[handler_flag])\n\n    validators = []\n    if vasp_custodian_validators is None:\n        vasp_custodian_validators = []\n    for validator_flag in vasp_custodian_validators:\n        if validator_flag not in validators_dict:\n            msg = f\"Unknown VASP validator: {validator_flag}\"\n            raise ValueError(msg)\n        validators.append(validators_dict[validator_flag])\n\n    # Populate settings\n    full_vasp_cmd = f\"{vasp_parallel_cmd} {vasp_cmd}\"\n    full_vasp_gamma_cmd = f\"{vasp_parallel_cmd} {vasp_gamma_cmd}\"\n\n    # Run VASP\n    vasp_job_kwargs = {} if vasp_job_kwargs is None else vasp_job_kwargs\n    custodian_kwargs = {} if custodian_kwargs is None else custodian_kwargs\n    split_vasp_cmd = shlex.split(full_vasp_cmd)\n    split_vasp_gamma_cmd = shlex.split(full_vasp_gamma_cmd)\n    vasp_job_kwargs[\"gamma_vasp_cmd\"] = split_vasp_gamma_cmd\n\n    # Run with Custodian\n    jobs = [VaspJob(split_vasp_cmd, **vasp_job_kwargs)]\n\n    if vasp_custodian_wall_time:\n        handlers = [\n            *list(handlers),\n            WalltimeHandler(wall_time=vasp_custodian_wall_time),\n        ]\n\n    c = Custodian(\n        handlers,\n        jobs,\n        validators=validators,\n        max_errors=vasp_custodian_max_errors,\n        scratch_dir=scratch_dir,\n        directory=directory,\n        **custodian_kwargs,\n    )\n\n    return c.run()\n</code></pre>"},{"location":"reference/quacc/recipes/common/defects.html","title":"defects","text":"<p>Common defect workflows.</p>"},{"location":"reference/quacc/recipes/common/defects.html#quacc.recipes.common.defects.has_pmg_defects","title":"has_pmg_defects  <code>module-attribute</code>","text":"<pre><code>has_pmg_defects = bool(\n    find_spec(\"pymatgen.analysis.defects\")\n)\n</code></pre>"},{"location":"reference/quacc/recipes/common/defects.html#quacc.recipes.common.defects.has_shakenbreak","title":"has_shakenbreak  <code>module-attribute</code>","text":"<pre><code>has_shakenbreak = bool(find_spec('shakenbreak'))\n</code></pre>"},{"location":"reference/quacc/recipes/common/defects.html#quacc.recipes.common.defects.bulk_to_defects_subflow","title":"bulk_to_defects_subflow","text":"<pre><code>bulk_to_defects_subflow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job | None = None,\n    make_defects_kwargs: dict[str, Any] | None = None,\n) -&gt; list[dict]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Defect generation</p> </li> <li> <p>Defect relaxations</p> </li> <li> <p>Defect statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the structure.</p> </li> <li> <code>relax_job</code>               (<code>Job</code>)           \u2013            <p>The relaxation function.</p> </li> <li> <code>static_job</code>               (<code>Job | None</code>, default:                   <code>None</code> )           \u2013            <p>The static function.</p> </li> <li> <code>make_defects_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for quacc.atoms.defects.make_defects_from_bulk</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>List of dictionary of results.</p> </li> </ul> Source code in <code>quacc/recipes/common/defects.py</code> <pre><code>@subflow\n@requires(\n    has_pmg_defects,\n    \"Missing pymatgen-analysis-defects. Please run pip install quacc[defects]\",\n)\n@requires(has_shakenbreak, \"Missing shakenbreak. Please run pip install quacc[defects]\")\ndef bulk_to_defects_subflow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job | None = None,\n    make_defects_kwargs: dict[str, Any] | None = None,\n) -&gt; list[dict]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Defect generation\n\n    2. Defect relaxations\n\n    3. Defect statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    relax_job\n        The relaxation function.\n    static_job\n        The static function.\n    make_defects_kwargs\n        Keyword arguments for [quacc.atoms.defects.make_defects_from_bulk][]\n\n    Returns\n    -------\n    list[dict]\n        List of dictionary of results.\n    \"\"\"\n    make_defects_kwargs = make_defects_kwargs or {}\n    defects = make_defects_from_bulk(atoms, **make_defects_kwargs)\n\n    results = []\n    for defect in defects:\n        result = relax_job(defect)\n\n        if static_job is not None:\n            result = static_job(result[\"atoms\"])\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/common/elastic.html","title":"elastic","text":"<p>Common elastic constants workflows.</p>"},{"location":"reference/quacc/recipes/common/elastic.html#quacc.recipes.common.elastic.elastic_tensor_flow","title":"elastic_tensor_flow","text":"<pre><code>elastic_tensor_flow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job,\n    pre_relax: bool = True,\n    run_static: bool = False,\n    deform_kwargs: dict[str, Any] | None = None,\n) -&gt; ElasticSchema\n</code></pre> <p>Common workflow for calculating elastic tensors.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>relax_job</code>               (<code>Job</code>)           \u2013            <p>The relaxation function.</p> </li> <li> <code>static_job</code>               (<code>Job</code>)           \u2013            <p>The static function</p> </li> <li> <code>pre_relax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run a relaxation on the bulk structure before deformation (true) or run a static calculation (false)</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to run static calculations after any relaxations on the undeformed or deformed structures</p> </li> <li> <code>deform_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.deformation.make_deformations_from_bulk</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ElasticSchema</code>           \u2013            <p>See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/common/elastic.py</code> <pre><code>@flow\ndef elastic_tensor_flow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job,\n    pre_relax: bool = True,\n    run_static: bool = False,\n    deform_kwargs: dict[str, Any] | None = None,\n) -&gt; ElasticSchema:\n    \"\"\"\n    Common workflow for calculating elastic tensors.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    relax_job\n        The relaxation function.\n    static_job\n        The static function\n    pre_relax\n        Whether to run a relaxation on the bulk structure before deformation (true) or run a static\n        calculation (false)\n    run_static\n        Whether to run static calculations after any relaxations on the undeformed or deformed structures\n    deform_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.deformation.make_deformations_from_bulk][]\n\n    Returns\n    -------\n    ElasticSchema\n        See the return type-hint for the data structure.\n    \"\"\"\n    if pre_relax:\n        undeformed_result = relax_job(atoms, relax_cell=True)\n        if run_static:\n            undeformed_result = static_job(undeformed_result[\"atoms\"])\n    else:\n        undeformed_result = static_job(atoms)\n\n    return _elastic_tensor_subflow(\n        undeformed_result=undeformed_result,\n        relax_job=relax_job,\n        static_job=static_job if run_static else None,\n        deform_kwargs=deform_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/common/phonons.html","title":"phonons","text":"<p>Common workflows for phonons.</p>"},{"location":"reference/quacc/recipes/common/phonons.html#quacc.recipes.common.phonons.has_phonopy","title":"has_phonopy  <code>module-attribute</code>","text":"<pre><code>has_phonopy = bool(find_spec('phonopy'))\n</code></pre>"},{"location":"reference/quacc/recipes/common/phonons.html#quacc.recipes.common.phonons.has_seekpath","title":"has_seekpath  <code>module-attribute</code>","text":"<pre><code>has_seekpath = bool(find_spec('seekpath'))\n</code></pre>"},{"location":"reference/quacc/recipes/common/phonons.html#quacc.recipes.common.phonons.phonon_subflow","title":"phonon_subflow","text":"<pre><code>phonon_subflow(\n    atoms: Atoms,\n    force_job: Job,\n    fixed_atom_indices: list[int] | None = None,\n    symprec: float = 0.0001,\n    min_lengths: (\n        float | tuple[float, float, float] | None\n    ) = 20.0,\n    supercell_matrix: (\n        tuple[\n            tuple[int, int, int],\n            tuple[int, int, int],\n            tuple[int, int, int],\n        ]\n        | None\n    ) = None,\n    displacement: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    phonopy_kwargs: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; PhononSchema\n</code></pre> <p>Calculate phonon properties using the Phonopy package.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object with calculator attached.</p> </li> <li> <code>force_job</code>               (<code>Job</code>)           \u2013            <p>The static job to calculate the forces.</p> </li> <li> <code>fixed_atom_indices</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Indices of fixed atoms. These atoms will not be displaced during the phonon calculation. Useful for adsorbates on surfaces with weak coupling etc. Important approximation, use with caution.</p> </li> <li> <code>symprec</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Precision for symmetry detection.</p> </li> <li> <code>min_lengths</code>               (<code>float | tuple[float, float, float] | None</code>, default:                   <code>20.0</code> )           \u2013            <p>Minimum length of each lattice dimension (A).</p> </li> <li> <code>supercell_matrix</code>               (<code>tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The supercell matrix to use. If specified, it will override any value specified by <code>min_lengths</code>.</p> </li> <li> <code>displacement</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Atomic displacement (A).</p> </li> <li> <code>t_step</code>               (<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Temperature step (K).</p> </li> <li> <code>t_min</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Min temperature (K).</p> </li> <li> <code>t_max</code>               (<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>Max temperature (K).</p> </li> <li> <code>phonopy_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional kwargs to pass to the Phonopy class.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the output schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy</p> </li> </ul> Source code in <code>quacc/recipes/common/phonons.py</code> <pre><code>@subflow\n@requires(has_phonopy, \"Phonopy must be installed. Run `pip install quacc[phonons]`\")\n@requires(has_seekpath, \"Seekpath must be installed. Run `pip install quacc[phonons]`\")\ndef phonon_subflow(\n    atoms: Atoms,\n    force_job: Job,\n    fixed_atom_indices: list[int] | None = None,\n    symprec: float = 1e-4,\n    min_lengths: float | tuple[float, float, float] | None = 20.0,\n    supercell_matrix: (\n        tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None\n    ) = None,\n    displacement: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    phonopy_kwargs: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Calculate phonon properties using the Phonopy package.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object with calculator attached.\n    force_job\n        The static job to calculate the forces.\n    fixed_atom_indices\n        Indices of fixed atoms. These atoms will not be displaced\n        during the phonon calculation. Useful for adsorbates on\n        surfaces with weak coupling etc. Important approximation,\n        use with caution.\n    symprec\n        Precision for symmetry detection.\n    min_lengths\n        Minimum length of each lattice dimension (A).\n    supercell_matrix\n        The supercell matrix to use. If specified, it will override any\n        value specified by `min_lengths`.\n    displacement\n        Atomic displacement (A).\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    phonopy_kwargs\n        Additional kwargs to pass to the Phonopy class.\n    additional_fields\n        Additional fields to add to the output schema.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][]\n    \"\"\"\n    mask_to_fix = np.zeros(len(atoms), dtype=bool)\n\n    if fixed_atom_indices:\n        mask_to_fix[fixed_atom_indices] = True\n\n    displaced_atoms, non_displaced_atoms = atoms[~mask_to_fix], atoms[mask_to_fix]\n\n    get_phonopy_kwargs = {\n        \"min_lengths\": min_lengths,\n        \"supercell_matrix\": supercell_matrix,\n        \"symprec\": symprec,\n        \"displacement\": displacement,\n        \"phonopy_kwargs\": phonopy_kwargs,\n    }\n    phonopy = get_phonopy(displaced_atoms, **get_phonopy_kwargs)\n\n    if non_displaced_atoms:\n        non_displaced_atoms_supercell = get_atoms_supercell_by_phonopy(\n            non_displaced_atoms, phonopy.supercell_matrix\n        )\n    else:\n        non_displaced_atoms_supercell = Atoms()\n\n    supercells = [\n        phonopy_atoms_to_ase_atoms(s) + non_displaced_atoms_supercell\n        for s in phonopy.supercells_with_displacements\n    ]\n\n    @subflow\n    def _get_forces_subflow(supercells: list[Atoms]) -&gt; list[dict]:\n        return [\n            force_job(supercell) for supercell in supercells if supercell is not None\n        ]\n\n    @job\n    def _thermo_job(\n        atoms: Atoms,\n        displaced_atoms: Atoms,\n        non_displaced_atoms: Atoms,\n        get_phonopy_kwargs: dict[str, Any],\n        force_job_results: list[dict],\n        t_step: float,\n        t_min: float,\n        t_max: float,\n        additional_fields: dict[str, Any] | None,\n    ) -&gt; PhononSchema:\n        phonopy = get_phonopy(displaced_atoms, **get_phonopy_kwargs)\n        parameters = force_job_results[-1].get(\"parameters\")\n        forces = [\n            output[\"results\"][\"forces\"][: len(phonopy.supercell)]\n            for output in force_job_results\n        ]\n        phonopy_results = PhonopyRunner().run_phonopy(\n            phonopy,\n            forces,\n            symmetrize=bool(non_displaced_atoms),\n            t_step=t_step,\n            t_min=t_min,\n            t_max=t_max,\n        )\n\n        return summarize_phonopy(\n            phonopy,\n            atoms,\n            phonopy_results.directory,\n            parameters=parameters,\n            additional_fields=additional_fields,\n        )\n\n    if non_displaced_atoms:\n        additional_fields = recursive_dict_merge(\n            additional_fields,\n            {\n                \"displaced_atoms\": displaced_atoms,\n                \"non_displaced_atoms\": non_displaced_atoms,\n            },\n        )\n\n    force_job_results = _get_forces_subflow(supercells)\n    return _thermo_job(\n        atoms,\n        displaced_atoms,\n        non_displaced_atoms,\n        get_phonopy_kwargs,\n        force_job_results,\n        t_step,\n        t_min,\n        t_max,\n        additional_fields,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/common/slabs.html","title":"slabs","text":"<p>Common slab workflows.</p>"},{"location":"reference/quacc/recipes/common/slabs.html#quacc.recipes.common.slabs.bulk_to_slabs_subflow","title":"bulk_to_slabs_subflow","text":"<pre><code>bulk_to_slabs_subflow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job | None = None,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n) -&gt; list[dict]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> </li> <li> <p>Slab statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>relax_job</code>               (<code>Job</code>)           \u2013            <p>The relaxation function.</p> </li> <li> <code>static_job</code>               (<code>Job | None</code>, default:                   <code>None</code> )           \u2013            <p>The static function.</p> </li> <li> <code>make_slabs_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>List of schemas.</p> </li> </ul> Source code in <code>quacc/recipes/common/slabs.py</code> <pre><code>@subflow\ndef bulk_to_slabs_subflow(\n    atoms: Atoms,\n    relax_job: Job,\n    static_job: Job | None = None,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n) -&gt; list[dict]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n\n    3. Slab statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    relax_job\n        The relaxation function.\n    static_job\n        The static function.\n    make_slabs_kwargs\n        Additional keyword arguments to pass to\n        [quacc.atoms.slabs.make_slabs_from_bulk][]\n\n    Returns\n    -------\n    list[dict]\n        List of schemas.\n    \"\"\"\n    make_slabs_kwargs = make_slabs_kwargs or {}\n\n    slabs = make_slabs_from_bulk(atoms, **make_slabs_kwargs)\n\n    results = []\n    for slab in slabs:\n        result = relax_job(slab)\n\n        if static_job is not None:\n            result = static_job(result[\"atoms\"])\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/common/slabs.html#quacc.recipes.common.slabs.slab_to_ads_subflow","title":"slab_to_ads_subflow","text":"<pre><code>slab_to_ads_subflow(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    relax_job: Job,\n    static_job: Job | None,\n    make_ads_kwargs: dict[str, Any] | None = None,\n) -&gt; list[dict]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab-adsorbate generation</p> </li> <li> <p>Slab-adsorbate relaxations</p> </li> <li> <p>Slab-adsorbate statics (optional)</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the slab structure.</p> </li> <li> <code>adsorbate</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the adsorbate.</p> </li> <li> <code>relax_job</code>               (<code>Job</code>)           \u2013            <p>The slab releaxation job.</p> </li> <li> <code>static_job</code>               (<code>Job | None</code>)           \u2013            <p>The slab static job.</p> </li> <li> <code>make_ads_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_adsorbate_structures</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>List of schemas.</p> </li> </ul> Source code in <code>quacc/recipes/common/slabs.py</code> <pre><code>@subflow\ndef slab_to_ads_subflow(\n    atoms: Atoms,\n    adsorbate: Atoms,\n    relax_job: Job,\n    static_job: Job | None,\n    make_ads_kwargs: dict[str, Any] | None = None,\n) -&gt; list[dict]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab-adsorbate generation\n\n    2. Slab-adsorbate relaxations\n\n    3. Slab-adsorbate statics (optional)\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    relax_job\n        The slab releaxation job.\n    static_job\n        The slab static job.\n    make_ads_kwargs\n        Additional keyword arguments to pass to\n        [quacc.atoms.slabs.make_adsorbate_structures][]\n\n    Returns\n    -------\n    list[dict]\n        List of schemas.\n    \"\"\"\n    make_ads_kwargs = make_ads_kwargs or {}\n\n    slabs = make_adsorbate_structures(atoms, adsorbate, **make_ads_kwargs)\n\n    results = []\n    for slab in slabs:\n        result = relax_job(slab)\n\n        if static_job is not None:\n            result = static_job(result[\"atoms\"])\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/_base.html","title":"_base","text":"<p>Base jobs for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/_base.html#quacc.recipes.dftb._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base job function for DFTB+ recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters to use.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the calculator that would override the calculator defaults. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.dftb.Dftb calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/dftb/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for DFTB+ recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        The default calculator parameters to use.\n    calc_swaps\n        Dictionary of custom kwargs for the calculator that would override the\n        calculator defaults. Set a value to `quacc.Remove` to remove a pre-existing key\n        entirely. For a list of available keys, refer to the\n        [ase.calculators.dftb.Dftb][] calculator.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    calc = Dftb(**calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc(\n        geom_file=_GEOM_FILE\n    )\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html","title":"core","text":"<p>Core recipes for DFTB+</p>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    method: Literal[\n        \"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"\n    ] = \"GFN2-xTB\",\n    kpts: tuple | list[tuple] | dict | None = None,\n    relax_cell: bool = False,\n    copy_files: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a structure relaxation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                   <code>'GFN2-xTB'</code> )           \u2013            <p>Method to use.</p> </li> <li> <code>kpts</code>               (<code>tuple | list[tuple] | dict | None</code>, default:                   <code>None</code> )           \u2013            <p>k-point grid to use.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the unit cell shape/volume in addition to the positions.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator that would override the calculator defaults. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.dftb.Dftb calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\n    kpts: tuple | list[tuple] | dict | None = None,\n    relax_cell: bool = False,\n    copy_files: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a structure relaxation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Method to use.\n    kpts\n        k-point grid to use.\n    relax_cell\n        Whether to relax the unit cell shape/volume in addition to the\n        positions.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the calculator that would override the\n        calculator defaults. Set a value to `quacc.Remove` to remove a pre-existing key\n        entirely. For a list of available keys, refer to the\n        [ase.calculators.dftb.Dftb][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the return type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n        \"Hamiltonian_MaxSccIterations\": 200,\n        \"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n        \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else Remove,\n        \"Driver_\": \"GeometryOptimization\",\n        \"Driver_AppendGeometries\": \"Yes\",\n        \"Driver_LatticeOpt\": \"Yes\" if relax_cell else \"No\",\n        \"Driver_MaxSteps\": 2000,\n    }\n\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"DFTB+ Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/dftb/core.html#quacc.recipes.dftb.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    method: Literal[\n        \"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"\n    ] = \"GFN2-xTB\",\n    copy_files: SourceDirectory | Copy | None = None,\n    kpts: tuple | list[tuple] | dict | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'DFTB']</code>, default:                   <code>'GFN2-xTB'</code> )           \u2013            <p>Method to use.</p> </li> <li> <code>kpts</code>               (<code>tuple | list[tuple] | dict | None</code>, default:                   <code>None</code> )           \u2013            <p>k-point grid to use.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator that would override the calculator defaults. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.dftb.Dftb calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/dftb/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"DFTB\"] = \"GFN2-xTB\",\n    copy_files: SourceDirectory | Copy | None = None,\n    kpts: tuple | list[tuple] | dict | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Method to use.\n    kpts\n        k-point grid to use.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the calculator that would override the\n        calculator defaults. Set a value to `quacc.Remove` to remove a pre-existing key\n        entirely. For a list of available keys, refer to the\n        [ase.calculators.dftb.Dftb][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the return type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"Hamiltonian_\": \"xTB\" if \"xtb\" in method.lower() else \"DFTB\",\n        \"Hamiltonian_MaxSccIterations\": 200,\n        \"kpts\": kpts or ((1, 1, 1) if atoms.pbc.any() else None),\n        \"Hamiltonian_Method\": method if \"xtb\" in method.lower() else Remove,\n    }\n\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"DFTB+ Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html","title":"core","text":"<p>Core recipes for EMT.</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes.</p>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the cell</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the EMT calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.emt.EMT calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.opt. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    relax_cell\n        Whether to relax the cell\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the EMT calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.emt.EMT][] calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.opt][].\n        See the type-hint for the data structure.\n    \"\"\"\n    opt_params = opt_params or {}\n\n    calc = EMT(**calc_kwargs)\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_opt(\n        relax_cell=relax_cell, **opt_params\n    )\n\n    return Summarize(\n        additional_fields={\"name\": \"EMT Relax\"} | (additional_fields or {})\n    ).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/core.html#quacc.recipes.emt.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy from a previous calculation.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the EMT calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.emt.EMT calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    copy_files\n        Files to copy from a previous calculation.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the EMT calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.emt.EMT][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc = EMT(**calc_kwargs)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(\n        additional_fields={\"name\": \"EMT Static\"} | (additional_fields or {})\n    ).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/defects.html","title":"defects","text":"<p>Defect recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/defects.html#quacc.recipes.emt.defects.has_pmg_defects","title":"has_pmg_defects  <code>module-attribute</code>","text":"<pre><code>has_pmg_defects = bool(\n    find_spec(\"pymatgen.analysis.defects\")\n)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/defects.html#quacc.recipes.emt.defects.has_shakenbreak","title":"has_shakenbreak  <code>module-attribute</code>","text":"<pre><code>has_shakenbreak = bool(find_spec('shakenbreak'))\n</code></pre>"},{"location":"reference/quacc/recipes/emt/defects.html#quacc.recipes.emt.defects.bulk_to_defects_flow","title":"bulk_to_defects_flow","text":"<pre><code>bulk_to_defects_flow(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    run_static: bool = True,\n    make_defects_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; list[RunSchema | OptSchema]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Defect generation</p> </li> <li> <p>Defect relaxations</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.emt.core.relax_job</li> </ul> </li> <li> <p>Optional defect statics</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the structure.</p> </li> <li> <code>defect_gen</code>               (<code>AntiSiteGenerator | ChargeInterstitialGenerator | InterstitialGenerator | SubstitutionGenerator | VacancyGenerator | VoronoiInterstitialGenerator</code>, default:                   <code>VacancyGenerator</code> )           \u2013            <p>Defect generator</p> </li> <li> <code>defect_charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge state of the defect</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run static calculations.</p> </li> <li> <code>make_defects_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to pass to quacc.atoms.defects.make_defects_from_bulk</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictinoary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>           \u2013            <p>List of dictionary of results from quacc.schemas.ase.Summarize.run or quacc.schemas.ase.Summarize.opt. See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/defects.py</code> <pre><code>@flow\n@requires(\n    has_pmg_defects,\n    \"Missing pymatgen-analysis-defects. Please run pip install quacc[defects]\",\n)\n@requires(has_shakenbreak, \"Missing shakenbreak. Please run pip install quacc[defects]\")\ndef bulk_to_defects_flow(\n    atoms: Atoms,\n    defect_gen: (\n        AntiSiteGenerator\n        | ChargeInterstitialGenerator\n        | InterstitialGenerator\n        | SubstitutionGenerator\n        | VacancyGenerator\n        | VoronoiInterstitialGenerator\n    ) = VacancyGenerator,\n    defect_charge: int = 0,\n    run_static: bool = True,\n    make_defects_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Defect generation\n\n    2. Defect relaxations\n        - name: \"relax_job\"\n        - job: [quacc.recipes.emt.core.relax_job][]\n\n    3. Optional defect statics\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    defect_gen\n        Defect generator\n    defect_charge\n        Charge state of the defect\n    run_static\n        Whether to run static calculations.\n    make_defects_kwargs\n        Keyword arguments to pass to\n        [quacc.atoms.defects.make_defects_from_bulk][]\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictinoary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        List of dictionary of results from [quacc.schemas.ase.Summarize.run][]\n        or [quacc.schemas.ase.Summarize.opt][].\n        See the return type-hint for the data structure.\n    \"\"\"\n    relax_job_, static_job_ = customize_funcs(\n        [\"relax_job\", \"static_job\"],\n        [relax_job, static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n    make_defects_kwargs = recursive_dict_merge(\n        make_defects_kwargs, {\"defect_gen\": defect_gen, \"defect_charge\": defect_charge}\n    )\n\n    return bulk_to_defects_subflow(\n        atoms,\n        relax_job_,\n        static_job=static_job_ if run_static else None,\n        make_defects_kwargs=make_defects_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/elastic.html","title":"elastic","text":"<p>Elastic constants recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/elastic.html#quacc.recipes.emt.elastic.elastic_tensor_flow","title":"elastic_tensor_flow","text":"<pre><code>elastic_tensor_flow(\n    atoms: Atoms,\n    pre_relax: bool = True,\n    run_static: bool = False,\n    deform_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; ElasticSchema\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Bulk structure relaxation (if pre_relax is True)</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.emt.core.relax_job</li> </ul> </li> <li> <p>Bulk structure static calculation (if run_static is True)</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> <li> <p>Deformed structures generation</p> </li> <li> <p>Deformed structures relaxations</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.emt.core.relax_job</li> </ul> </li> <li> <p>Deformed structures statics (if run_static is True)</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> <li> <p>Elastic tensor calculation</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>pre_relax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run a relaxation on the structure before deformation (true)</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to run static calculations after any relaxations on the undeformed or deformed structures</p> </li> <li> <code>deform_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.deformation.make_deformations_from_bulk</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ElasticSchema</code>           \u2013            <p>See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/elastic.py</code> <pre><code>@flow\ndef elastic_tensor_flow(\n    atoms: Atoms,\n    pre_relax: bool = True,\n    run_static: bool = False,\n    deform_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; ElasticSchema:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Bulk structure relaxation (if pre_relax is True)\n        - name: \"relax_job\"\n        - job: [quacc.recipes.emt.core.relax_job][]\n\n    2. Bulk structure static calculation (if run_static is True)\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    3. Deformed structures generation\n\n    4. Deformed structures relaxations\n        - name: \"relax_job\"\n        - job: [quacc.recipes.emt.core.relax_job][]\n\n    5. Deformed structures statics (if run_static is True)\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    6. Elastic tensor calculation\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    pre_relax\n        Whether to run a relaxation on the structure before deformation (true)\n    run_static\n        Whether to run static calculations after any relaxations on the undeformed or deformed structures\n    deform_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.deformation.make_deformations_from_bulk][]\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    ElasticSchema\n        See the return type-hint for the data structure.\n    \"\"\"\n    relax_job_, static_job_ = customize_funcs(\n        [\"relax_job\", \"static_job\"],\n        [relax_job, static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )  # type: ignore\n\n    return elastic_tensor_flow_(\n        atoms=atoms,\n        relax_job=relax_job_,\n        static_job=static_job_,\n        pre_relax=pre_relax,\n        run_static=run_static,\n        deform_kwargs=deform_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/md.html","title":"md","text":"<p>Molecular Dynamics recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/md.html#quacc.recipes.emt.md.md_job","title":"md_job","text":"<pre><code>md_job(\n    atoms: Atoms,\n    dynamics: MolecularDynamics = VelocityVerlet,\n    steps: int = 1000,\n    timestep_fs: float = 1.0,\n    temperature_K: float | None = None,\n    pressure_bar: float | None = None,\n    md_params: MDParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; DynSchema\n</code></pre> <p>Carry out a Molecular Dynamics calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>dynamics</code>               (<code>MolecularDynamics</code>, default:                   <code>VelocityVerlet</code> )           \u2013            <p>ASE <code>MolecularDynamics</code> class to use, from <code>ase.md.md.MolecularDynamics</code>.</p> </li> <li> <code>steps</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of MD steps to run.</p> </li> <li> <code>timestep_fs</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Time step in fs.</p> </li> <li> <code>temperature_K</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Temperature in K, if applicable for the given ensemble.</p> </li> <li> <code>pressure_bar</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Pressure in bar, if applicable for the given ensemble.</p> </li> <li> <code>md_params</code>               (<code>MDParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the MD run. For a list of available keys, refer to quacc.runners.ase.Runner.run_md.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the EMT calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>ase.calculators.emt.EMT</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DynSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.md. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/md.py</code> <pre><code>@job\ndef md_job(\n    atoms: Atoms,\n    dynamics: MolecularDynamics = VelocityVerlet,\n    steps: int = 1000,\n    timestep_fs: float = 1.0,\n    temperature_K: float | None = None,\n    pressure_bar: float | None = None,\n    md_params: MDParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; DynSchema:\n    \"\"\"\n    Carry out a Molecular Dynamics calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    dynamics\n        ASE `MolecularDynamics` class to use, from `ase.md.md.MolecularDynamics`.\n    steps\n        Number of MD steps to run.\n    timestep_fs\n        Time step in fs.\n    temperature_K\n        Temperature in K, if applicable for the given ensemble.\n    pressure_bar\n        Pressure in bar, if applicable for the given ensemble.\n    md_params\n        Dictionary of custom kwargs for the MD run. For a list of available\n        keys, refer to [quacc.runners.ase.Runner.run_md][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the EMT calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `ase.calculators.emt.EMT` calculator.\n\n    Returns\n    -------\n    DynSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.md][].\n        See the type-hint for the data structure.\n    \"\"\"\n    md_defaults = {\n        \"steps\": steps,\n        \"dynamics_kwargs\": {\n            \"timestep\": timestep_fs * fs,\n            \"temperature_K\": temperature_K if temperature_K else Remove,\n            \"pressure_au\": pressure_bar * bar if pressure_bar else Remove,\n        },\n    }\n    md_params = recursive_dict_merge(md_defaults, md_params)\n\n    calc = EMT(**calc_kwargs)\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_md(dynamics, **md_params)\n\n    return Summarize(\n        additional_fields={\"name\": \"EMT MD\"} | (additional_fields or {})\n    ).md(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/emt/phonons.html","title":"phonons","text":"<p>Phonon recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/phonons.html#quacc.recipes.emt.phonons.phonon_flow","title":"phonon_flow","text":"<pre><code>phonon_flow(\n    atoms: Atoms,\n    symprec: float = 0.0001,\n    min_lengths: (\n        float | tuple[float, float, float] | None\n    ) = 20.0,\n    supercell_matrix: (\n        tuple[\n            tuple[int, int, int],\n            tuple[int, int, int],\n            tuple[int, int, int],\n        ]\n        | None\n    ) = None,\n    displacement: float = 0.01,\n    fixed_atom_indices: list[int] | None = None,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; PhononSchema\n</code></pre> <p>Carry out a phonon workflow, consisting of:</p> <ol> <li> <p>Generation of supercells.</p> </li> <li> <p>Static calculations on supercells</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> <li> <p>Calculation of thermodynamic properties.</p> </li> </ol> <p>Note</p> <p>Phonon calculations rely on a structure that is tightly converged. We suggest running a pre-relaxation with <code>opt_params: {\"fmax\": 1e-3}</code> or tighter before running this workflow.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>symprec</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Precision for symmetry detection.</p> </li> <li> <code>min_lengths</code>               (<code>float | tuple[float, float, float] | None</code>, default:                   <code>20.0</code> )           \u2013            <p>Minimum length of each lattice dimension (A).</p> </li> <li> <code>supercell_matrix</code>               (<code>tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The supercell matrix to use. If specified, it will override any value specified by <code>min_lengths</code>.</p> </li> <li> <code>displacement</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Atomic displacement (A).</p> </li> <li> <code>fixed_atom_indices</code>               (<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Indices of fixed atoms. These atoms will not be displaced during the phonon calculation. Useful for adsorbates on surfaces with weak coupling etc. Important approximation, use with caution.</p> </li> <li> <code>t_step</code>               (<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Temperature step (K).</p> </li> <li> <code>t_min</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Min temperature (K).</p> </li> <li> <code>t_max</code>               (<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>Max temperature (K).</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy. See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/phonons.py</code> <pre><code>@flow\ndef phonon_flow(\n    atoms: Atoms,\n    symprec: float = 1e-4,\n    min_lengths: float | tuple[float, float, float] | None = 20.0,\n    supercell_matrix: (\n        tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None\n    ) = None,\n    displacement: float = 0.01,\n    fixed_atom_indices: list[int] | None = None,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Carry out a phonon workflow, consisting of:\n\n    1. Generation of supercells.\n\n    2. Static calculations on supercells\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    3. Calculation of thermodynamic properties.\n\n    !!! Note\n\n        Phonon calculations rely on a structure that is tightly converged.\n        We suggest running a pre-relaxation with `opt_params: {\"fmax\": 1e-3}`\n        or tighter before running this workflow.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    symprec\n        Precision for symmetry detection.\n    min_lengths\n        Minimum length of each lattice dimension (A).\n    supercell_matrix\n        The supercell matrix to use. If specified, it will override any\n        value specified by `min_lengths`.\n    displacement\n        Atomic displacement (A).\n    fixed_atom_indices\n        Indices of fixed atoms. These atoms will not be displaced\n        during the phonon calculation. Useful for adsorbates on\n        surfaces with weak coupling etc. Important approximation,\n        use with caution.\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][].\n        See the return type-hint for the data structure.\n    \"\"\"\n    static_job_ = customize_funcs(\n        [\"static_job\"],\n        [static_job],\n        param_defaults=None,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    return phonon_subflow(\n        atoms,\n        static_job_,\n        symprec=symprec,\n        min_lengths=min_lengths,\n        supercell_matrix=supercell_matrix,\n        fixed_atom_indices=fixed_atom_indices,\n        displacement=displacement,\n        t_step=t_step,\n        t_min=t_min,\n        t_max=t_max,\n        additional_fields={\"name\": \"EMT Phonons\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/emt/slabs.html","title":"slabs","text":"<p>Slab recipes for EMT.</p>"},{"location":"reference/quacc/recipes/emt/slabs.html#quacc.recipes.emt.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\n    atoms: Atoms,\n    run_static: bool = True,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; list[RunSchema | OptSchema]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.emt.core.relax_job</li> </ul> </li> <li> <p>Optional slab statics</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run static calculations.</p> </li> <li> <code>make_slabs_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[RunSchema | OptSchema]</code>           \u2013            <p>RunSchema or OptSchema for each slab. See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/emt/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\n    atoms: Atoms,\n    run_static: bool = True,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; list[RunSchema | OptSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n        - name: \"relax_job\"\n        - job: [quacc.recipes.emt.core.relax_job][]\n\n    3. Optional slab statics\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    run_static\n        Whether to run static calculations.\n    make_slabs_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_slabs_from_bulk][]\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    list[RunSchema | OptSchema]\n        [RunSchema][quacc.schemas.ase.Summarize.run] or\n        [OptSchema][quacc.schemas.ase.Summarize.opt] for each slab.\n        See the return type-hint for the data structure.\n    \"\"\"\n    relax_job_, static_job_ = customize_funcs(\n        [\"relax_job\", \"static_job\"],\n        [relax_job, static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    return bulk_to_slabs_subflow(\n        atoms,\n        relax_job_,\n        static_job=static_job_ if run_static else None,\n        make_slabs_kwargs=make_slabs_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/_base.html","title":"_base","text":"<p>Base jobs for espresso.</p>"},{"location":"reference/quacc/recipes/espresso/_base.html#quacc.recipes.espresso._base.prepare_calc","title":"prepare_calc","text":"<pre><code>prepare_calc(\n    atoms: Atoms,\n    preset: str | None = None,\n    template: EspressoTemplate | None = None,\n    profile: EspressoProfile | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n) -&gt; Espresso\n</code></pre> <p>Commonly used preparation function to merge parameters and create an Espresso calculator accordingly.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the preset to use</p> </li> <li> <code>template</code>               (<code>EspressoTemplate | None</code>, default:                   <code>None</code> )           \u2013            <p>EspressoTemplate to use</p> </li> <li> <code>profile</code>               (<code>EspressoProfile | None</code>, default:                   <code>None</code> )           \u2013            <p>EspressoProfile to use</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.espresso.Espresso calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Espresso</code>           \u2013            <p>The Espresso calculator.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/_base.py</code> <pre><code>def prepare_calc(\n    atoms: Atoms,\n    preset: str | None = None,\n    template: EspressoTemplate | None = None,\n    profile: EspressoProfile | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n) -&gt; Espresso:\n    \"\"\"\n    Commonly used preparation function to merge parameters\n    and create an Espresso calculator accordingly.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Name of the preset to use\n    template\n        EspressoTemplate to use\n    profile\n        EspressoProfile to use\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.espresso.Espresso][] calculator.\n\n    Returns\n    -------\n    Espresso\n        The Espresso calculator.\n    \"\"\"\n    calc_defaults = calc_defaults or {}\n    calc_swaps = calc_swaps or {}\n\n    calc_defaults[\"input_data\"] = Namelist(calc_defaults.get(\"input_data\"))\n    calc_swaps[\"input_data\"] = Namelist(calc_swaps.get(\"input_data\"))\n\n    binary = template.binary if template else \"pw\"\n\n    if binary in ALL_KEYS:\n        calc_defaults[\"input_data\"].to_nested(binary=binary, **calc_defaults)\n        calc_swaps[\"input_data\"].to_nested(binary=binary, **calc_swaps)\n\n    calc_defaults = remove_conflicting_kpts_kspacing(calc_defaults, calc_swaps)\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    return Espresso(\n        input_atoms=atoms,\n        preset=preset,\n        template=template,\n        profile=profile,\n        **calc_flags,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/_base.html#quacc.recipes.espresso._base.prepare_copy","title":"prepare_copy","text":"<pre><code>prepare_copy(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    calc_params: dict[str, Any] | None = None,\n    binary: str = \"pw\",\n) -&gt; Copy | None\n</code></pre> <p>Function that will prepare the files to copy.</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>calc_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The calculator parameters.</p> </li> <li> <code>binary</code>               (<code>str</code>, default:                   <code>'pw'</code> )           \u2013            <p>The binary to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary of files to copy.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/_base.py</code> <pre><code>def prepare_copy(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    calc_params: dict[str, Any] | None = None,\n    binary: str = \"pw\",\n) -&gt; Copy | None:\n    \"\"\"\n    Function that will prepare the files to copy.\n\n    Parameters\n    ----------\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    calc_params\n        The calculator parameters.\n    binary\n        The binary to use.\n\n    Returns\n    -------\n    dict\n        Dictionary of files to copy.\n    \"\"\"\n    if isinstance(copy_files, Copy):\n        return copy_files\n\n    if isinstance(copy_files, str | Path):\n        copy_files = [copy_files]\n\n    if isinstance(copy_files, list):\n        exact_files_to_copy = prepare_copy_files(calc_params, binary=binary)\n        return Copy(dict.fromkeys(copy_files, exact_files_to_copy))\n\n    return copy_files\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/_base.html#quacc.recipes.espresso._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms | None = None,\n    preset: str | None = None,\n    template: EspressoTemplate | None = None,\n    profile: EspressoProfile | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n) -&gt; RunSchema\n</code></pre> <p>Base function to carry out espresso recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | None</code>, default:                   <code>None</code> )           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the preset to use</p> </li> <li> <code>template</code>               (<code>EspressoTemplate | None</code>, default:                   <code>None</code> )           \u2013            <p>EspressoTemplate to use</p> </li> <li> <code>profile</code>               (<code>EspressoProfile | None</code>, default:                   <code>None</code> )           \u2013            <p>EspressoProfile to use</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.espresso.Espresso calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/espresso/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms | None = None,\n    preset: str | None = None,\n    template: EspressoTemplate | None = None,\n    profile: EspressoProfile | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base function to carry out espresso recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Name of the preset to use\n    template\n        EspressoTemplate to use\n    profile\n        EspressoProfile to use\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.espresso.Espresso][] calculator.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    atoms = Atoms() if atoms is None else atoms\n    calc = prepare_calc(\n        atoms,\n        preset=preset,\n        template=template,\n        profile=profile,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_swaps,\n    )\n\n    updated_copy_files = prepare_copy(\n        copy_files=copy_files,\n        calc_params=calc.user_calc_params,\n        binary=calc.template.binary,\n    )\n\n    geom_file = template.outputname if template and template.binary == \"pw\" else None\n\n    final_atoms = Runner(atoms, calc, copy_files=updated_copy_files).run_calc(\n        geom_file=geom_file\n    )\n\n    return Summarize(move_magmoms=True, additional_fields=additional_fields).run(\n        final_atoms, atoms\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/_base.html#quacc.recipes.espresso._base.run_and_summarize_opt","title":"run_and_summarize_opt","text":"<pre><code>run_and_summarize_opt(\n    atoms: Atoms | None = None,\n    preset: str | None = None,\n    template: EspressoTemplate | None = None,\n    profile: EspressoProfile | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n) -&gt; RunSchema\n</code></pre> <p>Base function to carry out espresso recipes with ASE optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | None</code>, default:                   <code>None</code> )           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the preset to use</p> </li> <li> <code>template</code>               (<code>EspressoTemplate | None</code>, default:                   <code>None</code> )           \u2013            <p>EspressoTemplate to use</p> </li> <li> <code>profile</code>               (<code>EspressoProfile | None</code>, default:                   <code>None</code> )           \u2013            <p>EspressoProfile to use</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.espresso.Espresso calculator.</p> </li> <li> <code>opt_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default optimization parameters.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/espresso/_base.py</code> <pre><code>def run_and_summarize_opt(\n    atoms: Atoms | None = None,\n    preset: str | None = None,\n    template: EspressoTemplate | None = None,\n    profile: EspressoProfile | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base function to carry out espresso recipes with ASE optimizers.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Name of the preset to use\n    template\n        EspressoTemplate to use\n    profile\n        EspressoProfile to use\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.espresso.Espresso][] calculator.\n    opt_defaults\n        The default optimization parameters.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    atoms = Atoms() if atoms is None else atoms\n    calc = prepare_calc(\n        atoms,\n        preset=preset,\n        template=template,\n        profile=profile,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_swaps,\n    )\n\n    updated_copy_files = prepare_copy(\n        copy_files=copy_files,\n        calc_params=calc.user_calc_params,\n        binary=calc.template.binary,\n    )\n\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    dyn = Runner(atoms, calc, copy_files=updated_copy_files).run_opt(**opt_flags)\n\n    return Summarize(move_magmoms=True, additional_fields=additional_fields).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/bands.html","title":"bands","text":"<p>This module, 'bands.py', contains recipes for performing bands and fermi surface calculations using the bands.x and fs.x binaries from Quantum ESPRESSO via the quacc library.</p>"},{"location":"reference/quacc/recipes/espresso/bands.html#quacc.recipes.espresso.bands.bands_flow","title":"bands_flow","text":"<pre><code>bands_flow(\n    atoms: Atoms,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | dict[SourceDirectory, Filenames]\n    ),\n    run_bands_pp: bool = True,\n    run_fermi_surface: bool = False,\n    make_bandpath: bool = True,\n    line_density: float = 20,\n    force_gamma: bool = True,\n    job_params: dict[str, Any] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; EspressoBandsSchema\n</code></pre> <p>Function to compute bands structure and fermi surface using pw.x, bands.x and fs.x.</p> <p>Consists of the following steps:</p> <ol> <li> <p>A pw.x non-self consistent calculation</p> <ul> <li>name: \"bands_pw_job\"</li> <li>job : quacc.recipes.espresso.bands.bands_pw_job</li> </ul> </li> <li> <p>A bands.x post-processing calculation</p> <ul> <li>name: \"bands_pp_job\"</li> <li>job : quacc.recipes.espresso.bands.bands_pp_job</li> </ul> </li> <li> <p>A fs.x calculation to obtain the fermi surface</p> <ul> <li>name: \"fermi_surface_job\"</li> <li>job : quacc.recipes.espresso.bands.fermi_surface_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | dict[SourceDirectory, Filenames]</code>)           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>run_bands_pp</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, a bands.x post-processing calculation will be carried out. This allows to re-order bands and computes band-related properties.</p> </li> <li> <code>run_fermi_surface</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a fs.x calculation will be carried out. This allows to generate the fermi surface of your structure. It requires a uniform unshifted k-point grid bands calculation.</p> </li> <li> <code>make_bandpath</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, it returns the primitive cell for your structure and generates the high symmetry k-path using Latmer-Munro approach. For more information look at pymatgen.symmetry.bandstructure.HighSymmKpath</p> </li> <li> <code>line_density</code>               (<code>float</code>, default:                   <code>20</code> )           \u2013            <p>Density of kpoints along the band path if make_bandpath is True For more information quacc.utils.kpts.convert_pmg_kpts</p> </li> <li> <code>force_gamma</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Forces gamma-centered k-points when using make_bandpath For more information quacc.utils.kpts.convert_pmg_kpts</p> </li> <li> <code>job_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BandsSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/bands.py</code> <pre><code>@flow\ndef bands_flow(\n    atoms: Atoms,\n    copy_files: (\n        SourceDirectory | list[SourceDirectory] | dict[SourceDirectory, Filenames]\n    ),\n    run_bands_pp: bool = True,\n    run_fermi_surface: bool = False,\n    make_bandpath: bool = True,\n    line_density: float = 20,\n    force_gamma: bool = True,\n    job_params: dict[str, Any] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; EspressoBandsSchema:\n    \"\"\"\n    Function to compute bands structure and fermi surface using pw.x, bands.x and fs.x.\n\n    Consists of the following steps:\n\n    1. A pw.x non-self consistent calculation\n        - name: \"bands_pw_job\"\n        - job : [quacc.recipes.espresso.bands.bands_pw_job][]\n\n    2. A bands.x post-processing calculation\n        - name: \"bands_pp_job\"\n        - job : [quacc.recipes.espresso.bands.bands_pp_job][]\n\n    3. A fs.x calculation to obtain the fermi surface\n        - name: \"fermi_surface_job\"\n        - job : [quacc.recipes.espresso.bands.fermi_surface_job][]\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    run_bands_pp\n        If True, a bands.x post-processing calculation will be carried out.\n        This allows to re-order bands and computes band-related properties.\n    run_fermi_surface\n        If True, a fs.x calculation will be carried out.\n        This allows to generate the fermi surface of your structure.\n        It requires a uniform unshifted k-point grid bands calculation.\n    make_bandpath\n        If True, it returns the primitive cell for your structure and generates\n        the high symmetry k-path using Latmer-Munro approach.\n        For more information look at\n        [pymatgen.symmetry.bandstructure.HighSymmKpath][]\n    line_density\n        Density of kpoints along the band path if make_bandpath is True\n        For more information [quacc.utils.kpts.convert_pmg_kpts][]\n    force_gamma\n        Forces gamma-centered k-points when using make_bandpath\n        For more information [quacc.utils.kpts.convert_pmg_kpts][]\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    BandsSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    (bands_pw_job_, bands_pp_job_, fermi_surface_job_) = customize_funcs(\n        [\"bands_pw_job\", \"bands_pp_job\", \"fermi_surface_job\"],\n        [bands_pw_job, bands_pp_job, fermi_surface_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    bands_results = bands_pw_job_(\n        atoms,\n        copy_files,\n        make_bandpath=make_bandpath,\n        line_density=line_density,\n        force_gamma=force_gamma,\n    )\n    results = {\"bands_pw\": bands_results}\n    bands_results_dir = bands_results[\"dir_name\"]\n\n    if run_bands_pp:\n        bands_pp_results = bands_pp_job_(prev_outdir=bands_results_dir)\n        results[\"bands_pp\"] = bands_pp_results\n\n    if run_fermi_surface:\n        fermi_results = fermi_surface_job_(prev_outdir=bands_results_dir)\n        results[\"fermi_surface\"] = fermi_results\n\n    return results\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/bands.html#quacc.recipes.espresso.bands.bands_pp_job","title":"bands_pp_job","text":"<pre><code>bands_pp_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to re-order bands and computes bands-related properties with bands.x. This allows one to get the bands structure in a more readable way.</p> <p>Note</p> <p>This requires a previous quacc.recipes.espresso.bands.bands_pw_job calculation.</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/bands.py</code> <pre><code>@job\ndef bands_pp_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to re-order bands and computes bands-related properties with bands.x.\n    This allows one to get the bands structure in a more readable way.\n\n    !!! Note\n\n        This requires a previous [quacc.recipes.espresso.bands.bands_pw_job][] calculation.\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"bands\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults={},\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"bands.x post-processing\"}\n        | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/bands.html#quacc.recipes.espresso.bands.bands_pw_job","title":"bands_pw_job","text":"<pre><code>bands_pw_job(\n    atoms: Atoms,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    make_bandpath: bool = True,\n    line_density: float = 20,\n    force_gamma: bool = True,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic bandstructure calculation with pw.x.</p> <p>Note</p> <p>First perform a normal SCF calculation quacc.recipes.espresso.core.static_job; then use this job if you are interested in calculating only the Kohn-Sham states for the given set of k-points</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>make_bandpath</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, it returns the primitive cell for your structure and generates the high symmetry k-path using Latmer-Munro approach. For more information look at pymatgen.symmetry.bandstructure.HighSymmKpath</p> </li> <li> <code>line_density</code>               (<code>float</code>, default:                   <code>20</code> )           \u2013            <p>Density of kpoints along the band path if make_bandpath is True For more information quacc.utils.kpts.convert_pmg_kpts</p> </li> <li> <code>force_gamma</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Forces gamma-centered k-points when using make_bandpath For more information quacc.utils.kpts.convert_pmg_kpts</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/bands.py</code> <pre><code>@job\ndef bands_pw_job(\n    atoms: Atoms,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    make_bandpath: bool = True,\n    line_density: float = 20,\n    force_gamma: bool = True,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic bandstructure calculation with pw.x.\n\n    !!! Note\n\n        First perform a normal SCF calculation [quacc.recipes.espresso.core.static_job][];\n        then use this job if you are interested in calculating only the Kohn-Sham states\n        for the given set of k-points\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    make_bandpath\n        If True, it returns the primitive cell for your structure and generates\n        the high symmetry k-path using Latmer-Munro approach.\n        For more information look at\n        [pymatgen.symmetry.bandstructure.HighSymmKpath][]\n    line_density\n        Density of kpoints along the band path if make_bandpath is True\n        For more information [quacc.utils.kpts.convert_pmg_kpts][]\n    force_gamma\n        Forces gamma-centered k-points when using make_bandpath\n        For more information [quacc.utils.kpts.convert_pmg_kpts][]\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"input_data\": {\"control\": {\"calculation\": \"bands\", \"verbosity\": \"high\"}}\n    }\n    if make_bandpath:\n        structure = AseAtomsAdaptor.get_structure(atoms)\n        primitive = SpacegroupAnalyzer(structure).get_primitive_standard_structure()\n        atoms = primitive.to_ase_atoms()\n        calc_defaults[\"kpts\"] = bandpath(\n            convert_pmg_kpts(\n                {\"line_density\": line_density}, atoms, force_gamma=force_gamma\n            )[0],\n            cell=atoms.get_cell(),\n        )\n\n    return run_and_summarize(\n        atoms,\n        template=EspressoTemplate(\"pw\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"pw.x bands\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/bands.html#quacc.recipes.espresso.bands.fermi_surface_job","title":"fermi_surface_job","text":"<pre><code>fermi_surface_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to retrieve the fermi surface with fs.x</p> <p>Note</p> <p>It requires a previous uniform unshifted k-point grid bands calculation.</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/bands.py</code> <pre><code>@job\ndef fermi_surface_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to retrieve the fermi surface with fs.x\n\n    !!! Note\n\n        It requires a previous uniform unshifted k-point grid bands calculation.\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"fs\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults={},\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"fs.x fermi_surface\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html","title":"core","text":"<p>Core recipes for espresso.</p>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.BASE_SET_METAL","title":"BASE_SET_METAL  <code>module-attribute</code>","text":"<pre><code>BASE_SET_METAL: EspressoBaseSet = {\n    \"input_data\": {\n        \"system\": {\n            \"occupations\": \"smearing\",\n            \"smearing\": \"cold\",\n            \"degauss\": 0.01,\n        },\n        \"electrons\": {\n            \"conv_thr\": 1e-08,\n            \"mixing_mode\": \"local-TF\",\n            \"mixing_beta\": 0.35,\n        },\n        \"control\": {},\n    },\n    \"kspacing\": 0.033,\n}\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.BASE_SET_NON_METAL","title":"BASE_SET_NON_METAL  <code>module-attribute</code>","text":"<pre><code>BASE_SET_NON_METAL: EspressoBaseSet = {\n    \"input_data\": {\n        \"system\": {\n            \"occupations\": \"smearing\",\n            \"smearing\": \"gaussian\",\n            \"degauss\": 0.005,\n        },\n        \"electrons\": {\n            \"conv_thr\": 1e-08,\n            \"mixing_mode\": \"local-TF\",\n            \"mixing_beta\": 0.35,\n        },\n    },\n    \"kspacing\": 0.045,\n}\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.ase_relax_job","title":"ase_relax_job","text":"<pre><code>ase_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    autorestart: bool = True,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a structure relaxation with pw.x using ASE external optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'sssp_1.3.0_pbe_efficiency'</code> )           \u2013            <p>The name of a YAML file containing a list of parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>ESPRESSO_PRESET_DIR</code> (default: quacc/calculators/espresso/presets).</p> </li> <li> <code>autorestart</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to automatically turn on the restart flag after the first calculation. This avoids recomputing everything from scratch at each step of the optimization.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the cell or not.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/core.py</code> <pre><code>@job\ndef ase_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    autorestart: bool = True,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a structure relaxation with pw.x using ASE\n    external optimizers.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    preset\n        The name of a YAML file containing a list of parameters to use as\n        a \"preset\" for the calculator. quacc will automatically look in the\n        `ESPRESSO_PRESET_DIR` (default: quacc/calculators/espresso/presets).\n    autorestart\n        Whether to automatically turn on the restart flag after the first\n        calculation. This avoids recomputing everything from scratch at each\n        step of the optimization.\n    relax_cell\n        Whether to relax the cell or not.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = BASE_SET_METAL if check_is_metal(atoms) else BASE_SET_NON_METAL\n    calc_defaults[\"input_data\"][\"control\"] = {\n        \"calculation\": \"scf\",\n        \"tstress\": relax_cell,\n        \"tprnfor\": True,\n    }\n\n    opt_defaults = {\"optimizer\": BFGSLineSearch, \"relax_cell\": relax_cell}\n\n    return run_and_summarize_opt(\n        atoms,\n        preset=preset,\n        template=EspressoTemplate(\"pw\", autorestart=autorestart, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"pw.x ExternalRelax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.non_scf_job","title":"non_scf_job","text":"<pre><code>non_scf_job(\n    atoms: Atoms,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic NSCF calculation with pw.x.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'sssp_1.3.0_pbe_efficiency'</code> )           \u2013            <p>The name of a YAML file containing a list of parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>ESPRESSO_PRESET_DIR</code> (default: quacc/calculators/espresso/presets).</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/core.py</code> <pre><code>@job\ndef non_scf_job(\n    atoms: Atoms,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic NSCF calculation with pw.x.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    preset\n        The name of a YAML file containing a list of parameters to use as\n        a \"preset\" for the calculator. quacc will automatically look in the\n        `ESPRESSO_PRESET_DIR` (default: quacc/calculators/espresso/presets).\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"input_data\": {\"control\": {\"calculation\": \"nscf\"}},\n        \"kspacing\": 0.033,\n    }\n\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        template=EspressoTemplate(\"pw\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"pw.x Non SCF\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.post_processing_job","title":"post_processing_job","text":"<pre><code>post_processing_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic pp.x calculation (post-processing). It is mainly used to extract the charge density from a previous pw.x calculation. and perform simple to complex post-processing on it. Fore more details please see https://www.quantum-espresso.org/Doc/INPUT_PP.html</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/core.py</code> <pre><code>@job\ndef post_processing_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic pp.x calculation (post-processing).\n    It is mainly used to extract the charge density from a previous pw.x calculation.\n    and perform simple to complex post-processing on it. Fore more details please see\n    https://www.quantum-espresso.org/Doc/INPUT_PP.html\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"input_data\": {\n            \"inputpp\": {\"plot_num\": 0},\n            \"plot\": {\n                \"iflag\": 3,\n                \"output_format\": 6,\n                \"fileout\": \"pseudo_charge_density.cube\",\n            },\n        }\n    }\n\n    return run_and_summarize(\n        template=EspressoTemplate(\"pp\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"pp.x post-processing\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    relax_cell: bool = False,\n    test_run: bool = False,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a structure relaxation with pw.x.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'sssp_1.3.0_pbe_efficiency'</code> )           \u2013            <p>The name of a YAML file containing a list of parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>ESPRESSO_PRESET_DIR</code> (default: quacc/calculators/espresso/presets).</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the cell or not.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    relax_cell: bool = False,\n    test_run: bool = False,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a structure relaxation with pw.x.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    preset\n        The name of a YAML file containing a list of parameters to use as\n        a \"preset\" for the calculator. quacc will automatically look in the\n        `ESPRESSO_PRESET_DIR` (default: quacc/calculators/espresso/presets).\n    relax_cell\n        Whether to relax the cell or not.\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = BASE_SET_METAL if check_is_metal(atoms) else BASE_SET_NON_METAL\n    calc_defaults[\"input_data\"][\"control\"] = {\n        \"calculation\": \"vc-relax\" if relax_cell else \"relax\"\n    }\n\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        template=EspressoTemplate(\"pw\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"pw.x Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/core.html#quacc.recipes.espresso.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    test_run: bool = False,\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic SCF calculation with pw.x.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'sssp_1.3.0_pbe_efficiency'</code> )           \u2013            <p>The name of a YAML file containing a list of parameters to use as a \"preset\" for the calculator. quacc will automatically look in the <code>ESPRESSO_PRESET_DIR</code> (default: quacc/calculators/espresso/presets).</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    preset: str | None = \"sssp_1.3.0_pbe_efficiency\",\n    test_run: bool = False,\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic SCF calculation with pw.x.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    preset\n        The name of a YAML file containing a list of parameters to use as\n        a \"preset\" for the calculator. quacc will automatically look in the\n        `ESPRESSO_PRESET_DIR` (default: quacc/calculators/espresso/presets).\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = BASE_SET_METAL if check_is_metal(atoms) else BASE_SET_NON_METAL\n    calc_defaults[\"input_data\"][\"control\"] = {\"calculation\": \"scf\"}\n\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        template=EspressoTemplate(\"pw\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"pw.x Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/dos.html","title":"dos","text":"<p>DOS/ProjWFC recipes for performing dos calculations</p>"},{"location":"reference/quacc/recipes/espresso/dos.html#quacc.recipes.espresso.dos.dos_flow","title":"dos_flow","text":"<pre><code>dos_flow(\n    atoms: Atoms,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n    job_params: dict[str, Any] | None = None,\n) -&gt; EspressoDosSchema\n</code></pre> <p>This function performs a total density of states calculations.</p> <p>Consists of following jobs that can be modified:</p> <ol> <li> <p>pw.x static</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.espresso.core.static_job</li> </ul> </li> <li> <p>pw.x non self-consistent</p> <ul> <li>name: \"non_scf_job\"</li> <li>job: quacc.recipes.espresso.core.non_scf_job</li> </ul> </li> <li> <p>dos.x total density of states</p> <ul> <li>name: \"dos_job\"</li> <li>job: quacc.recipes.espresso.dos.dos_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>job_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DosSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/dos.py</code> <pre><code>@flow\ndef dos_flow(\n    atoms: Atoms,\n    job_decorators: dict[str, Callable | None] | None = None,\n    job_params: dict[str, Any] | None = None,\n) -&gt; EspressoDosSchema:\n    \"\"\"\n    This function performs a total density of states calculations.\n\n    Consists of following jobs that can be modified:\n\n    1. pw.x static\n        - name: \"static_job\"\n        - job: [quacc.recipes.espresso.core.static_job][]\n\n    2. pw.x non self-consistent\n        - name: \"non_scf_job\"\n        - job: [quacc.recipes.espresso.core.non_scf_job][]\n\n    3. dos.x total density of states\n        - name: \"dos_job\"\n        - job: [quacc.recipes.espresso.dos.dos_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    DosSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    job_params = job_params or {}\n    default_job_params = {\n        \"static_job\": {\n            \"kspacing\": 0.2,\n            \"input_data\": {\"system\": {\"occupations\": \"tetrahedra\"}},\n        },\n        \"non_scf_job\": recursive_dict_merge(\n            job_params.get(\"static_job\"),\n            {\n                \"kspacing\": 0.01,\n                \"input_data\": {\n                    \"control\": {\"calculation\": \"nscf\", \"verbosity\": \"high\"},\n                    \"system\": {\"occupations\": \"tetrahedra\"},\n                },\n            },\n        ),\n    }\n\n    static_job_, non_scf_job_, dos_job_ = customize_funcs(\n        [\"static_job\", \"non_scf_job\", \"dos_job\"],\n        [static_job, non_scf_job, dos_job],\n        param_defaults=default_job_params,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    static_results = static_job_(atoms)\n    static_results_dir = static_results[\"dir_name\"]\n    non_scf_results = non_scf_job_(atoms, prev_outdir=static_results_dir)\n    dos_results = dos_job_(prev_outdir=static_results_dir)\n\n    return {\n        \"static_job\": static_results,\n        \"non_scf_job\": non_scf_results,\n        \"dos_job\": dos_results,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/dos.html#quacc.recipes.espresso.dos.dos_job","title":"dos_job","text":"<pre><code>dos_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic dos.x calculation (density of states). It is mainly used to extract the charge density and wavefunction from a previous pw.x calculation. It generates the total density of states. For more details, please see https://www.quantum-espresso.org/Doc/INPUT_DOS.html</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the calculation will be run in test mode. This is useful for quickly checking if the calculation will run without errors.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of <code>ase.io.espresso.write_fortran_namelist</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/dos.py</code> <pre><code>@job\ndef dos_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic dos.x calculation (density of states).\n    It is mainly used to extract the charge density and wavefunction from a previous pw.x calculation.\n    It generates the total density of states. For more details, please see\n    https://www.quantum-espresso.org/Doc/INPUT_DOS.html\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    test_run\n        If True, the calculation will be run in test mode. This is useful for quickly\n        checking if the calculation will run without errors.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        `ase.io.espresso.write_fortran_namelist` for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"dos\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=None,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"dos.x Density-of-States\"}\n        | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/dos.html#quacc.recipes.espresso.dos.projwfc_flow","title":"projwfc_flow","text":"<pre><code>projwfc_flow(\n    atoms: Atoms,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n    job_params: dict[str, Any] | None = None,\n) -&gt; EspressoProjwfcSchema\n</code></pre> <p>This function performs a projwfc calculation.</p> <p>Consists of following jobs that can be modified:</p> <ol> <li> <p>pw.x static</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.espresso.core.static_job</li> </ul> </li> <li> <p>pw.x non self-consistent</p> <ul> <li>name: \"non_scf_job\"</li> <li>job: quacc.recipes.espresso.core.non_scf_job</li> </ul> </li> <li> <p>projwfc.x job</p> <ul> <li>name: \"projwfc_job\"</li> <li>job: quacc.recipes.espresso.dos.projwfc_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>job_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProjwfcSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/dos.py</code> <pre><code>@flow\ndef projwfc_flow(\n    atoms: Atoms,\n    job_decorators: dict[str, Callable | None] | None = None,\n    job_params: dict[str, Any] | None = None,\n) -&gt; EspressoProjwfcSchema:\n    \"\"\"\n    This function performs a projwfc calculation.\n\n    Consists of following jobs that can be modified:\n\n    1. pw.x static\n        - name: \"static_job\"\n        - job: [quacc.recipes.espresso.core.static_job][]\n\n    2. pw.x non self-consistent\n        - name: \"non_scf_job\"\n        - job: [quacc.recipes.espresso.core.non_scf_job][]\n\n    3. projwfc.x job\n        - name: \"projwfc_job\"\n        - job: [quacc.recipes.espresso.dos.projwfc_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    ProjwfcSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    job_params = job_params or {}\n    default_job_params = {\n        \"static_job\": {\n            \"kspacing\": 0.2,\n            \"input_data\": {\"system\": {\"occupations\": \"tetrahedra\"}},\n        },\n        \"non_scf_job\": recursive_dict_merge(\n            job_params.get(\"static_job\"),\n            {\n                \"kspacing\": 0.01,\n                \"input_data\": {\n                    \"control\": {\"calculation\": \"nscf\", \"verbosity\": \"high\"},\n                    \"system\": {\"occupations\": \"tetrahedra\"},\n                },\n            },\n        ),\n    }\n    static_job_, non_scf_job_, projwfc_job_ = customize_funcs(\n        [\"static_job\", \"non_scf_job\", \"projwfc_job\"],\n        [static_job, non_scf_job, projwfc_job],\n        param_defaults=default_job_params,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    static_results = static_job_(atoms)\n    static_results_dir = static_results[\"dir_name\"]\n    non_scf_results = non_scf_job_(atoms, prev_outdir=static_results_dir)\n    projwfc_results = projwfc_job_(prev_outdir=static_results_dir)\n\n    return {\n        \"static_job\": static_results,\n        \"non_scf_job\": non_scf_results,\n        \"projwfc_job\": projwfc_results,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/dos.html#quacc.recipes.espresso.dos.projwfc_job","title":"projwfc_job","text":"<pre><code>projwfc_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic projwfc.x calculation. It is mainly used to extract the charge density and wavefunction from a previous pw.x calculation. It can generate partial dos, local dos, spilling parameter and more. Fore more details please see https://www.quantum-espresso.org/Doc/INPUT_PROJWFC.html</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the calculation will be run in test mode. This is useful for quickly checking if the calculation will run without errors.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of <code>ase.io.espresso.write_fortran_namelist</code> for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/dos.py</code> <pre><code>@job\ndef projwfc_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic projwfc.x calculation.\n    It is mainly used to extract the charge density and wavefunction from a previous pw.x calculation.\n    It can generate partial dos, local dos, spilling parameter and more. Fore more details please see\n    https://www.quantum-espresso.org/Doc/INPUT_PROJWFC.html\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    test_run\n        If True, the calculation will be run in test mode. This is useful for quickly\n        checking if the calculation will run without errors.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        `ase.io.espresso.write_fortran_namelist` for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"projwfc\", test_run=test_run, outdir=prev_outdir),\n        calc_defaults=None,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"projwfc.x Projects-wavefunctions\"}\n        | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html","title":"phonons","text":"<p>This module, 'phonons.py', contains recipes for performing phonon calculations using the ph.x binary from Quantum ESPRESSO via the quacc library.</p> <p>The recipes provided in this module are jobs and flows that can be used to perform phonon calculations in different fashion.</p>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.dvscf_q2r_job","title":"dvscf_q2r_job","text":"<pre><code>dvscf_q2r_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic dvscf_q2r calculation allowing phonon potential interpolation from coarse to fine q-point grids using Fourier interpolation. It should allow you to use all the features of the dvscf_q2r binary which does not have an official documentation.</p> <p>To use this, run a quacc.recipes.espresso.phonons.phonon_job on a coarse q-point grid, dvscf_q2r.x can then be used to inverse Fourier transform the phonon potentials to a real-space supercell, you can later run an additional quacc.recipes.espresso.phonons.phonon_job with <code>ldvscf_interpolation = True</code> to Fourier transform the potentials to desired q points.</p> <p>Only one card, &amp;input:</p> <p>prefix  : Prepended to input/output filenames, default: 'pwscf' outdir  : Directory containing input, output, and scratch files.           In quacc this is always set to the current working directory. fildyn  : File where the dynamical matrix is written.           In quacc this should always be set to 'matdyn'. fildvscf : File where the potential variation is written.            In quacc this should always be set to 'dvscf'.            (character, Default: 'dvscf') wpot_dir : Directory where the w_pot binary files are written.            In quacc this is always set to outdir / w_pot do_long_range : If .true., subtract the long-range part of the potential                 before interpolation. Requires epsilon and Born effective                 charge data in _ph0/prefix.phsave/tensor.xml. default: .false. do_charge_neutral : If .true., renormalize phonon potential to impose                 neutrality of Born effective charges. default: .false. verbosity : If 'high', write more information to stdout.</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@job\ndef dvscf_q2r_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic dvscf_q2r calculation allowing phonon potential\n    interpolation from coarse to fine q-point grids using Fourier interpolation.\n    It should allow you to use all the features of the dvscf_q2r binary which does\n    not have an official documentation.\n\n    To use this, run a [quacc.recipes.espresso.phonons.phonon_job][] on a coarse q-point\n    grid, dvscf_q2r.x can then be used to inverse Fourier transform the phonon potentials\n    to a real-space supercell, you can later run an additional\n    [quacc.recipes.espresso.phonons.phonon_job][] with `ldvscf_interpolation = True`\n    to Fourier transform the potentials to desired q points.\n\n    Only one card, &amp;input:\n\n    prefix  : Prepended to input/output filenames, default: 'pwscf'\n    outdir  : Directory containing input, output, and scratch files.\n              In quacc this is always set to the current working directory.\n    fildyn  : File where the dynamical matrix is written.\n              In quacc this should always be set to 'matdyn'.\n    fildvscf : File where the potential variation is written.\n               In quacc this should always be set to 'dvscf'.\n               (character, Default: 'dvscf')\n    wpot_dir : Directory where the w_pot binary files are written.\n               In quacc this is always set to outdir / w_pot\n    do_long_range : If .true., subtract the long-range part of the potential\n                    before interpolation. Requires epsilon and Born effective\n                    charge data in _ph0/prefix.phsave/tensor.xml. default: .false.\n    do_charge_neutral : If .true., renormalize phonon potential to impose\n                    neutrality of Born effective charges. default: .false.\n    verbosity : If 'high', write more information to stdout.\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"dvscf_q2r\", outdir=prev_outdir),\n        calc_defaults={},\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"dvscf_q2r Phonon\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.grid_phonon_flow","title":"grid_phonon_flow","text":"<pre><code>grid_phonon_flow(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | dict[SourceDirectory, Filenames]\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    nblocks: int = 1,\n    job_params: dict[str, Any] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; RunSchema\n</code></pre> <p>This function performs grid parallelization of a ph.x calculation. Each representation of each q-point is calculated in a separate job, allowing for distributed computation across different machines and times.</p> <p>The grid parallelization is a technique to make phonon calculation embarrassingly parallel. This function should return similar results to quacc.recipes.espresso.phonons.phonon_job. If you don't know about grid parallelization please consult the Quantum Espresso user manual and exemples.</p> <p>This approach requires the data of the pw.x calculation to be copied to each job, leading to a total data size on the disk of n*m times the size of the pw.x calculation, where: - n is the number of q-points - m is the number of representations</p> <p>In addition to the data produced by each ph.x calculation. This can result in large data sizes for systems with many atoms.</p> <p>To mitigate this, an optional \"nblocks\" argument can be provided. This groups multiple representations together in a single job, reducing the data size by a factor of nblocks, but also reducing the level of parallelization. In the case of nblocks = 0, each job will contain all the representations for each q-point.</p> <p>Consists of following jobs that can be modified:</p> <ol> <li> <p>ph.x calculation test_run</p> <ul> <li>name: \"ph_init_job\"</li> <li>job: quacc.recipes.espresso.phonons.phonon_job</li> </ul> </li> <li> <p>(n * m) / nblocks ph.x calculations</p> <ul> <li>name: \"ph_job\"</li> <li>job: quacc.recipes.espresso.phonons.phonon_job</li> </ul> </li> <li> <p>ph.x calculation to gather data and diagonalize each dynamical matrix</p> <ul> <li>name: \"ph_recover_job\"</li> <li>job: quacc.recipes.espresso.phonons.phonon_job</li> </ul> </li> </ol> <p>Note</p> <p>Phonon calculations rely on a structure that is tightly converged. We suggest running a <code>relax_job</code> with the following settings:</p> <pre><code>inputs_data = {\n    \"control\": {\"forc_conv_thr\": 5.0e-5},\n    \"electrons\": {\"conv_thr\": 1e-12},\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>nblocks</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of representations to group together in a single job. This will reduce the amount of data produced by a factor of nblocks. If nblocks = 0, each job will contain all the representations for a single q-point.</p> </li> <li> <code>job_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@flow\ndef grid_phonon_flow(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | dict[SourceDirectory, Filenames]\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    nblocks: int = 1,\n    job_params: dict[str, Any] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    This function performs grid parallelization of a ph.x calculation. Each\n    representation of each q-point is calculated in a separate job, allowing for\n    distributed computation across different machines and times.\n\n    The grid parallelization is a technique to make phonon calculation embarrassingly\n    parallel. This function should return similar results to\n    [quacc.recipes.espresso.phonons.phonon_job][]. If you don't know about\n    grid parallelization please consult the Quantum Espresso user manual and\n    exemples.\n\n    This approach requires the data of the pw.x calculation to be copied to each job,\n    leading to a total data size on the disk of n*m times the size of the pw.x calculation, where:\n    - n is the number of q-points\n    - m is the number of representations\n\n    In addition to the data produced by each ph.x calculation. This can\n    result in large data sizes for systems with many atoms.\n\n    To mitigate this, an optional \"nblocks\" argument can be provided. This\n    groups multiple representations together in a single job, reducing the\n    data size by a factor of nblocks, but also reducing the level of parallelization.\n    In the case of nblocks = 0, each job will contain all the representations for each q-point.\n\n    Consists of following jobs that can be modified:\n\n    1. ph.x calculation test_run\n        - name: \"ph_init_job\"\n        - job: [quacc.recipes.espresso.phonons.phonon_job][]\n\n    2. (n * m) / nblocks ph.x calculations\n        - name: \"ph_job\"\n        - job: [quacc.recipes.espresso.phonons.phonon_job][]\n\n    3. ph.x calculation to gather data and diagonalize each dynamical matrix\n        - name: \"ph_recover_job\"\n        - job: [quacc.recipes.espresso.phonons.phonon_job][]\n\n    !!! Note\n\n        Phonon calculations rely on a structure that is tightly converged.\n        We suggest running a `relax_job` with the following settings:\n\n        ```python\n        inputs_data = {\n            \"control\": {\"forc_conv_thr\": 5.0e-5},\n            \"electrons\": {\"conv_thr\": 1e-12},\n        }\n        ```\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    nblocks\n        The number of representations to group together in a single job.\n        This will reduce the amount of data produced by a factor of nblocks.\n        If nblocks = 0, each job will contain all the representations for a\n        single q-point.\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n\n    @subflow\n    def _ph_recover_subflow(grid_results: list[RunSchema]) -&gt; RunSchema:\n        prev_dirs = {}\n        for result in grid_results:\n            prev_dirs[result[\"dir_name\"]] = [\n                Path(\"**\", \"*.xml.*\"),\n                Path(\"**\", \"data-file-schema.xml.*\"),\n                Path(\"**\", \"charge-density.*\"),\n                Path(\"**\", \"wfc*.*\"),\n                Path(\"**\", \"paw.txt.*\"),\n            ]\n        return ph_recover_job(copy_files=prev_dirs)\n\n    @subflow\n    def _grid_phonon_subflow(\n        ph_input_data: UserDict | None,\n        ph_init_job_results: RunSchema,\n        ph_job: Job,\n        nblocks: int = 1,\n    ) -&gt; list[RunSchema]:\n        \"\"\"\n        This functions is a subflow used in\n        [quacc.recipes.espresso.phonons.grid_phonon_flow][].\n\n        Parameters\n        ----------\n        ph_input_data\n            The input data for the phonon calculation.\n        ph_init_job_results\n            The results of the phonon 'only_init' job.\n        ph_job\n            The phonon job to be executed.\n        nblocks\n            The number of blocks for grouping representations.\n\n        Returns\n        -------\n        list[RunSchema]\n            A list of results from each phonon job.\n        \"\"\"\n        ph_input_data = Namelist(ph_input_data)\n        ph_input_data.to_nested(binary=\"ph\")\n\n        prev_outdir = ph_init_job_results[\"parameters\"][\"input_data\"][\"inputph\"][\n            \"outdir\"\n        ]\n\n        grid_results = []\n        for qnum, qdata in ph_init_job_results[\"results\"].items():\n            ph_input_data[\"inputph\"][\"start_q\"] = qnum\n            ph_input_data[\"inputph\"][\"last_q\"] = qnum\n            repr_to_do = grid_prepare_repr(qdata[\"representations\"], nblocks)\n            files_to_copy = grid_copy_files(\n                ph_input_data, prev_outdir, qnum, qdata[\"qpoint\"]\n            )\n            for representation in repr_to_do:\n                ph_input_data[\"inputph\"][\"start_irr\"] = representation[0]\n                ph_input_data[\"inputph\"][\"last_irr\"] = representation[-1]\n                ph_job_results = ph_job(\n                    copy_files=deepcopy(files_to_copy),\n                    input_data=deepcopy(ph_input_data),\n                )\n                grid_results.append(ph_job_results)\n\n        return grid_results\n\n    job_params = job_params or {}\n    default_job_params = {\n        \"ph_init_job\": recursive_dict_merge(\n            {\"input_data\": {\"inputph\": {\"lqdir\": True, \"only_init\": True}}},\n            job_params.get(\"ph_job\"),\n        ),\n        \"ph_job\": {\n            \"input_data\": {\n                \"inputph\": {\"lqdir\": True, \"low_directory_check\": True, \"recover\": True}\n            }\n        },\n        \"ph_recover_job\": recursive_dict_merge(\n            {\"input_data\": {\"inputph\": {\"recover\": True, \"lqdir\": True}}},\n            job_params.get(\"ph_job\"),\n        ),\n    }\n    ph_init_job, ph_job, ph_recover_job = customize_funcs(\n        [\"ph_init_job\", \"ph_job\", \"ph_recover_job\"],\n        [phonon_job, phonon_job, phonon_job],\n        param_defaults=default_job_params,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    ph_init_job_results = ph_init_job(copy_files=copy_files, prev_outdir=prev_outdir)\n    grid_results = _grid_phonon_subflow(\n        job_params[\"ph_job\"][\"input_data\"], ph_init_job_results, ph_job, nblocks=nblocks\n    )\n\n    return _ph_recover_subflow(grid_results)\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.matdyn_job","title":"matdyn_job","text":"<pre><code>matdyn_job(\n    copy_files: (\n        SourceDirectory | list[SourceDirectory] | Copy\n    ),\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic <code>matdyn.x</code> calculation. It should allow you to use all the features of the matdyn.x binary</p> <p>This program calculates the phonon frequencies for a list of generic q vectors starting from the interatomic force constants generated from the dynamical matrices as written by DFPT phonon code through the program <code>q2r.x</code></p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy</code>)           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@job\ndef matdyn_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy),\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic `matdyn.x` calculation. It should allow you to use\n    all the features of the [matdyn.x binary](https://www.quantum-espresso.org/Doc/INPUT_MATDYN.html#idm138)\n\n    This program calculates the phonon frequencies for a list of generic\n    q vectors starting from the interatomic force constants generated\n    from the dynamical matrices as written by DFPT phonon code through\n    the program `q2r.x`\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"matdyn\"),\n        calc_defaults={},\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"matdyn.x Phonon\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.phonon_dos_flow","title":"phonon_dos_flow","text":"<pre><code>phonon_dos_flow(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | dict[SourceDirectory, Filenames]\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    job_params: dict[str, Any] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; EspressoPhononDosSchema\n</code></pre> <p>Function to carry out a phonon DOS calculation. The phonon calculation is carried out on a coarse q-grid, the force constants are calculated and extrapolated to a finer q-grid, and the phonon DOS is calculated.</p> <p>Consists of following jobs that can be modified:</p> <ol> <li>ph.x calculation<ul> <li>name: \"phonon_job\"</li> <li>job: quacc.recipes.espresso.phonons.phonon_job</li> </ul> </li> <li>q2r.x calculation<ul> <li>name: \"q2r_job\"</li> <li>job: quacc.recipes.espresso.phonons.q2r_job</li> </ul> </li> <li>matdyn.x calculation<ul> <li>name: \"matdyn_job\"</li> <li>job: quacc.recipes.espresso.phonons.matdyn_job</li> </ul> </li> </ol> <p>Note</p> <p>Phonon calculations rely on a structure that is tightly converged. We suggest running a <code>relax_job</code> with the following settings:</p> <pre><code>input_data = {\n    \"control\": {\"forc_conv_thr\": 5.0e-5},\n    \"electrons\": {\"conv_thr\": 1e-12},\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>job_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@flow\ndef phonon_dos_flow(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | dict[SourceDirectory, Filenames]\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    job_params: dict[str, Any] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; EspressoPhononDosSchema:\n    \"\"\"\n    Function to carry out a phonon DOS calculation. The phonon calculation is carried\n    out on a coarse q-grid, the force constants are calculated and extrapolated to a\n    finer q-grid, and the phonon DOS is calculated.\n\n    Consists of following jobs that can be modified:\n\n    1. ph.x calculation\n        - name: \"phonon_job\"\n        - job: [quacc.recipes.espresso.phonons.phonon_job][]\n    2. q2r.x calculation\n        - name: \"q2r_job\"\n        - job: [quacc.recipes.espresso.phonons.q2r_job][]\n    3. matdyn.x calculation\n        - name: \"matdyn_job\"\n        - job: [quacc.recipes.espresso.phonons.matdyn_job][]\n\n    !!! Note\n\n        Phonon calculations rely on a structure that is tightly converged.\n        We suggest running a `relax_job` with the following settings:\n\n        ```python\n        input_data = {\n            \"control\": {\"forc_conv_thr\": 5.0e-5},\n            \"electrons\": {\"conv_thr\": 1e-12},\n        }\n        ```\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    default_job_params = {\n        \"phonon_job\": {\n            \"input_data\": {\n                \"inputph\": {\n                    \"tr2_ph\": 1e-12,\n                    \"alpha_mix(1)\": 0.1,\n                    \"verbosity\": \"high\",\n                    \"ldisp\": True,\n                    \"nq1\": 4,\n                    \"nq2\": 4,\n                    \"nq3\": 4,\n                }\n            }\n        },\n        \"matdyn_job\": {\n            \"input_data\": {\"input\": {\"dos\": True, \"nk1\": 32, \"nk2\": 32, \"nk3\": 32}}\n        },\n    }\n    ph_job, fc_job, dos_job = customize_funcs(\n        [\"phonon_job\", \"q2r_job\", \"matdyn_job\"],\n        [phonon_job, q2r_job, matdyn_job],\n        param_defaults=default_job_params,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    ph_job_results = ph_job(copy_files=copy_files, prev_outdir=prev_outdir)\n    fc_job_results = fc_job(ph_job_results[\"dir_name\"])\n    dos_job_results = dos_job(fc_job_results[\"dir_name\"])\n\n    return {\n        \"phonon_job\": ph_job_results,\n        \"q2r_job\": fc_job_results,\n        \"matdyn_job\": dos_job_results,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.phonon_job","title":"phonon_job","text":"<pre><code>phonon_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    use_phcg: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic ph.x calculation. It should allow you to use all the features of the ph.x binary</p> <p><code>ph.x</code> calculates the dynamical matrix at a set of q-points within the Density Functional Perturbation Theory (DFPT) framework. The dynamical matrix is used to calculate the phonon frequencies and eigenvectors. Various other properties can be calculated using other post-processing tools.</p> <p>Note</p> <p>Phonon calculations rely on a structure that is tightly converged. We suggest running a <code>relax_job</code> with the following settings:</p> <pre><code>inputs_data = {\n    \"control\": {\"forc_conv_thr\": 5.0e-5},\n    \"electrons\": {\"conv_thr\": 1e-12},\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>test_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, a test run is performed to check that the calculation input_data is correct or to generate some files/info if needed.</p> </li> <li> <code>use_phcg</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the calculation is performed using the <code>phcg.x</code> code which uses a faster algorithm. It can be used only if you sample the Brillouin Zone at Gamma and you only need the phonon modes at Gamma (molecules typically). It cannot be used with spin-polarization, USPP and PAW.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@job\ndef phonon_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    test_run: bool = False,\n    use_phcg: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic ph.x calculation. It should allow you to\n    use all the features of the [ph.x binary](https://www.quantum-espresso.org/Doc/INPUT_PH.html)\n\n    `ph.x` calculates the dynamical matrix at a set of q-points within the Density\n    Functional Perturbation Theory (DFPT) framework. The dynamical matrix is used to calculate the phonon frequencies and eigenvectors. Various other properties can be\n    calculated using other post-processing tools.\n\n    !!! Note\n\n        Phonon calculations rely on a structure that is tightly converged.\n        We suggest running a `relax_job` with the following settings:\n\n        ```python\n        inputs_data = {\n            \"control\": {\"forc_conv_thr\": 5.0e-5},\n            \"electrons\": {\"conv_thr\": 1e-12},\n        }\n        ```\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    test_run\n        If True, a test run is performed to check that the calculation input_data is correct or\n        to generate some files/info if needed.\n    use_phcg\n        If True, the calculation is performed using the `phcg.x` code which uses a faster algorithm.\n        It can be used only if you sample the Brillouin Zone at Gamma and you only need the phonon\n        modes at Gamma (molecules typically). It cannot be used with spin-polarization, USPP and PAW.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    binary = \"phcg\" if use_phcg else \"ph\"\n    calc_defaults = {\n        \"input_data\": {\n            \"inputph\": {\"tr2_ph\": 1e-12, \"alpha_mix(1)\": 0.1, \"verbosity\": \"high\"}\n        },\n        \"qpts\": (0, 0, 0),\n    }\n\n    return run_and_summarize(\n        template=EspressoTemplate(binary, test_run=test_run, outdir=prev_outdir),\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": f\"{binary}.x Phonon\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.postahc_job","title":"postahc_job","text":"<pre><code>postahc_job(\n    copy_files: (\n        SourceDirectory\n        | list[SourceDirectory]\n        | Copy\n        | None\n    ) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic postahc calculation. It should allow you to use all the features of the postahc.x binary</p> <p>Calculate the phonon-induced electron self-energy in the full matrix form at a given temperature. This requires the results of a previous ph.x calculation with <code>electron_phonon='ahc'</code></p> <p>self energies calculated and printed by <code>postahc.x</code></p> <ul> <li>Total self-energy in the on-shell approximation (OSA)</li> <li>Debye-Waller self-energy in the RIA</li> <li>Total Fan self-energy in the OSA</li> <li>Upper Fan self-energy</li> <li>Lower Fan self-energy in the OSA</li> </ul> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>prev_outdir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>The output directory of a previous calculation. If provided, Quantum Espresso will directly read the necessary files from this directory, eliminating the need to manually copy files. The directory will be ungzipped if necessary.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@job\ndef postahc_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy | None) = None,\n    prev_outdir: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic postahc calculation. It should allow you to\n    use all the features of the [postahc.x binary](https://www.quantum-espresso.org/Doc/INPUT_POSTAHC.html#idm11)\n\n    Calculate the phonon-induced electron self-energy in the full matrix form\n    at a given temperature. This requires the results of a previous ph.x calculation\n    with `electron_phonon='ahc'`\n\n    self energies calculated and printed by `postahc.x`\n\n    - Total self-energy in the on-shell approximation (OSA)\n    - Debye-Waller self-energy in the RIA\n    - Total Fan self-energy in the OSA\n    - Upper Fan self-energy\n    - Lower Fan self-energy in the OSA\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    prev_outdir\n        The output directory of a previous calculation. If provided, Quantum Espresso\n        will directly read the necessary files from this directory, eliminating the need\n        to manually copy files. The directory will be ungzipped if necessary.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"postahc\", outdir=prev_outdir),\n        calc_defaults={},\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"postahc Phonon\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/espresso/phonons.html#quacc.recipes.espresso.phonons.q2r_job","title":"q2r_job","text":"<pre><code>q2r_job(\n    copy_files: (\n        SourceDirectory | list[SourceDirectory] | Copy\n    ),\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic q2r.x calculation. It should allow you to use all the features of the q2r.x binary</p> <p><code>q2r.x</code> reads force constant matrices C(q) produced by the <code>ph.x</code> code for a grid of q-points and calculates the corresponding set of interatomic force constants (IFC), C(R)</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | list[SourceDirectory] | Copy</code>)           \u2013            <p>Source directory or directories to copy files from. If a <code>SourceDirectory</code> or a list of <code>SourceDirectory</code> is provided, this interface will automatically guess which files have to be copied over by looking at the binary and <code>input_data</code>. If a dict is provided, the mode is manual, keys are source directories and values are relative path to files or directories to copy. Glob patterns are supported.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the Espresso calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See the docstring of quacc.calculators.espresso.espresso.Espresso for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/espresso/phonons.py</code> <pre><code>@job\ndef q2r_job(\n    copy_files: (SourceDirectory | list[SourceDirectory] | Copy),\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic q2r.x calculation. It should allow you to\n    use all the features of the [q2r.x binary](https://www.quantum-espresso.org/Doc/INPUT_Q2R.html#idm51)\n\n    `q2r.x` reads force constant matrices C(q) produced by the `ph.x` code\n    for a grid of q-points and calculates the corresponding set\n    of interatomic force constants (IFC), C(R)\n\n    Parameters\n    ----------\n    copy_files\n        Source directory or directories to copy files from. If a `SourceDirectory` or a\n        list of `SourceDirectory` is provided, this interface will automatically guess\n        which files have to be copied over by looking at the binary and `input_data`.\n        If a dict is provided, the mode is manual, keys are source directories and values\n        are relative path to files or directories to copy. Glob patterns are supported.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the Espresso calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. See the docstring of\n        [quacc.calculators.espresso.espresso.Espresso][] for more information.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        template=EspressoTemplate(\"q2r\"),\n        calc_defaults={},\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"q2r.x Phonon\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/_base.html","title":"_base","text":"<p>Base jobs for Gaussian.</p>"},{"location":"reference/quacc/recipes/gaussian/_base.html#quacc.recipes.gaussian._base.LOG_FILE","title":"LOG_FILE  <code>module-attribute</code>","text":"<pre><code>LOG_FILE = f'{_LABEL}.log'\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/_base.html#quacc.recipes.gaussian._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base job function for carrying out Gaussian recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default parameters for the calculator.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Gaussian calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.gaussian.Gaussian calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for carrying out Gaussian recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        Default parameters for the calculator.\n    calc_swaps\n        Dictionary of custom kwargs for the Gaussian calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.gaussian.Gaussian][] calculator.\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    settings = get_settings()\n    gaussian_cmd = f\"{settings.GAUSSIAN_CMD} &lt; {_LABEL}.com &gt; {LOG_FILE}\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    calc = Gaussian(command=gaussian_cmd, label=_LABEL, **calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc(\n        geom_file=LOG_FILE\n    )\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html","title":"core","text":"<p>Core recipes for Gaussian.</p>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    freq: bool = False,\n    copy_files: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>)           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>)           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97xd'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>freq</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If a frequency calculation should be carried out.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Gaussian calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.gaussian.Gaussian calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    freq: bool = False,\n    copy_files: SourceDirectory | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    freq\n        If a frequency calculation should be carried out.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results\n    **calc_kwargs\n        Custom kwargs for the Gaussian calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.gaussian.Gaussian][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    calc_defaults = {\n        # General settings\n        \"mem\": \"16GB\",\n        \"chk\": f\"{_LABEL}.chk\",\n        \"nprocshared\": psutil.cpu_count(logical=False),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"pop\": \"CM5\",\n        # Job-specific settings\n        \"opt\": \"\",\n        \"nosymmetry\": \"\",\n        \"ioplist\": [\"2/9=2000\"],  # https://gitlab.com/ase/ase/-/issues/660\n        \"freq\": \"\" if freq else Remove,\n    }\n\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Gaussian Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gaussian/core.html#quacc.recipes.gaussian.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97xd'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Gaussian calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.gaussian.Gaussian calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/gaussian/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Gaussian calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.gaussian.Gaussian][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    calc_defaults = {\n        # General settings\n        \"mem\": \"16GB\",\n        \"chk\": f\"{_LABEL}.chk\",\n        \"nprocshared\": psutil.cpu_count(logical=False),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"pop\": \"CM5\",\n        # Job-specific settings\n        \"force\": \"\",\n        \"gfinput\": \"\",\n        \"ioplist\": [\"6/7=3\", \"2/9=2000\"],  # https://gitlab.com/ase/ase/-/issues/660\n    }\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Gaussian Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/_base.html","title":"_base","text":"<p>Base jobs for GULP.</p>"},{"location":"reference/quacc/recipes/gulp/_base.html#quacc.recipes.gulp._base.GEOM_FILE_NOPBC","title":"GEOM_FILE_NOPBC  <code>module-attribute</code>","text":"<pre><code>GEOM_FILE_NOPBC = 'gulp.xyz'\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/_base.html#quacc.recipes.gulp._base.GEOM_FILE_PBC","title":"GEOM_FILE_PBC  <code>module-attribute</code>","text":"<pre><code>GEOM_FILE_PBC = 'gulp.cif'\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/_base.html#quacc.recipes.gulp._base.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/_base.html#quacc.recipes.gulp._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    library: str | None = None,\n    keyword_defaults: list[str] | None = None,\n    option_defaults: list[str] | None = None,\n    keyword_swaps: list[str] | None = None,\n    option_swaps: list[str] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Base job function for GULP recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>library</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Filename of the potential library file, if required.</p> </li> <li> <code>keyword_defaults</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default <code>keywords</code> for calculator.</p> </li> <li> <code>option_defaults</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default <code>options</code> for calculator.</p> </li> <li> <code>keyword_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of custom <code>keyword</code> kwargs for the GULP calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>option_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom <code>options</code> kwargs for the GULP calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional field to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Any other keyword arguments to pass to the <code>GULP</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/gulp/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    library: str | None = None,\n    keyword_defaults: list[str] | None = None,\n    option_defaults: list[str] | None = None,\n    keyword_swaps: list[str] | None = None,\n    option_swaps: list[str] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for GULP recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    library\n        Filename of the potential library file, if required.\n    keyword_defaults\n        Default `keywords` for calculator.\n    option_defaults\n        Default `options` for calculator.\n    keyword_swaps\n        List of custom `keyword` kwargs for the GULP calculator. To remove entries\n        from the defaults, put a `#` in front of the name. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    option_swaps\n        Dictionary of custom `options` kwargs for the GULP calculator. To remove entries\n        from the defaults, put a `#` in front of the name. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    additional_fields\n        Additional field to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Any other keyword arguments to pass to the `GULP` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    keyword_defaults = keyword_defaults or []\n    settings = get_settings()\n    gulp_cmd = f\"{settings.GULP_CMD} &lt; gulp.gin &gt; gulp.got\"\n\n    if not atoms.pbc.any():\n        if \"opti\" in keyword_defaults and \"conv\" not in keyword_defaults:\n            keyword_defaults += [\"conv\"]\n        keyword_defaults = [k for k in keyword_defaults if k not in [\"gwolf\", \"conp\"]]\n\n    if option_defaults is None:\n        option_defaults = []\n\n    option_defaults += [\n        (\n            f\"output cif {GEOM_FILE_PBC}\"\n            if atoms.pbc.any()\n            else f\"output xyz {GEOM_FILE_NOPBC}\"\n        )\n    ]\n\n    keywords = merge_list_params(keyword_defaults, keyword_swaps)\n    options = merge_list_params(option_defaults, option_swaps)\n\n    gulp_keywords = \" \".join(keywords)\n    gulp_options = list(options)\n\n    if settings.GULP_LIB:\n        os.environ[\"GULP_LIB\"] = str(settings.GULP_LIB)\n    calc = GULP(\n        command=gulp_cmd,\n        keywords=gulp_keywords,\n        options=gulp_options,\n        library=library,\n        **calc_kwargs,\n    )\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc(\n        geom_file=GEOM_FILE_PBC if atoms.pbc.any() else GEOM_FILE_NOPBC\n    )\n\n    if (\n        settings.CHECK_CONVERGENCE\n        and \"opti\" in gulp_keywords\n        and not final_atoms.calc.get_opt_state()\n    ):\n        msg = \"Optimization did not converge.\"\n        raise RuntimeError(msg)\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html","title":"core","text":"<p>Core recipes for GULP.</p>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    use_gfnff: bool = True,\n    relax_cell: bool = False,\n    keywords: list[str] | None = None,\n    options: list[str] | None = None,\n    library: str | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Carry out a structure relaxation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>use_gfnff</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>True if the volume should be relaxed; False if not.</p> </li> <li> <code>keywords</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of custom <code>keyword</code> kwargs for the GULP calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>options</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom <code>options</code> kwargs for the GULP calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>library</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Filename of the potential library file, if required.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    use_gfnff: bool = True,\n    relax_cell: bool = False,\n    keywords: list[str] | None = None,\n    options: list[str] | None = None,\n    library: str | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a structure relaxation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    relax_cell\n        True if the volume should be relaxed; False if not.\n    keywords\n        List of custom `keyword` kwargs for the GULP calculator. To remove entries\n        from the defaults, put a `#` in front of the name. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    options\n        Dictionary of custom `options` kwargs for the GULP calculator. To remove entries\n        from the defaults, put a `#` in front of the name. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    library\n        Filename of the potential library file, if required.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    keyword_defaults = [\"opti\", \"conp\" if relax_cell else \"conv\"]\n    if use_gfnff:\n        keyword_defaults += [\"gfnff\", \"gwolf\"]\n\n    option_defaults = [\"dump every gulp.res\"]\n\n    return run_and_summarize(\n        atoms,\n        library=library,\n        keyword_defaults=keyword_defaults,\n        option_defaults=option_defaults,\n        keyword_swaps=keywords,\n        option_swaps=options,\n        additional_fields={\"name\": \"GULP Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/gulp/core.html#quacc.recipes.gulp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    use_gfnff: bool = True,\n    keywords: list[str] | None = None,\n    options: list[str] | None = None,\n    library: str | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>use_gfnff</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>True if (p)GFN-FF should be used; False if not.</p> </li> <li> <code>keywords</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of custom <code>keyword</code> kwargs for the GULP calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>options</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of custom <code>options</code> kwargs for the GULP calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. For a list of available keys, refer to the <code>ase.calculators.gulp.GULP</code> calculator.</p> </li> <li> <code>library</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Filename of the potential library file, if required.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/gulp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    use_gfnff: bool = True,\n    keywords: list[str] | None = None,\n    options: list[str] | None = None,\n    library: str | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    use_gfnff\n        True if (p)GFN-FF should be used; False if not.\n    keywords\n        List of custom `keyword` kwargs for the GULP calculator. To remove entries\n        from the defaults, put a `#` in front of the name. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    options\n        List of custom `options` kwargs for the GULP calculator. To remove entries\n        from the defaults, put a `#` in front of the name. For a list of\n        available keys, refer to the `ase.calculators.gulp.GULP` calculator.\n    library\n        Filename of the potential library file, if required.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    keyword_defaults = [\"gfnff\", \"gwolf\"] if use_gfnff else []\n    option_defaults = [\"dump every gulp.res\"]\n\n    return run_and_summarize(\n        atoms,\n        library=library,\n        keyword_defaults=keyword_defaults,\n        option_defaults=option_defaults,\n        keyword_swaps=keywords,\n        option_swaps=options,\n        additional_fields={\"name\": \"GULP Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html","title":"core","text":"<p>Core recipes for Lennard-Jones Potential.</p> <p>NOTE: This set of minimal recipes is mainly for demonstration purposes</p>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms: Atoms,\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    vib_kwargs: VibKwargs | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VibThermoSchema\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>energy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> <li> <code>vib_kwargs</code>               (<code>VibKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the ase.vibrations.Vibrations class.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the LJ calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the [ase.calculators.lj.LennardJones] calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    vib_kwargs: VibKwargs | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    vib_kwargs\n        Dictionary of kwargs for the [ase.vibrations.Vibrations][] class.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Dictionary of custom kwargs for the LJ calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.lj.LennardJones] calculator.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results\n    \"\"\"\n    vib_kwargs = vib_kwargs or {}\n\n    calc = LennardJones(**calc_kwargs)\n    vib = Runner(atoms, calc).run_vib(vib_kwargs=vib_kwargs)\n\n    return VibSummarize(\n        vib,\n        additional_fields={\"name\": \"LJ Frequency and Thermo\"}\n        | (additional_fields or {}),\n    ).vib_and_thermo(\n        \"ideal_gas\", energy=energy, temperature=temperature, pressure=pressure\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Function to carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the LJ calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the [ase.calculators.lj.LennardJones] calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Function to carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the LJ calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.lj.LennardJones] calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    opt_params = opt_params or {}\n\n    calc = LennardJones(**calc_kwargs)\n    dyn = Runner(atoms, calc).run_opt(**opt_params)\n\n    return Summarize(\n        additional_fields={\"name\": \"LJ Relax\"} | (additional_fields or {})\n    ).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/lj/core.html#quacc.recipes.lj.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a static calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the LJ calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the [ase.calculators.lj.LennardJones] calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/lj/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms, additional_fields: dict[str, Any] | None = None, **calc_kwargs\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    **calc_kwargs\n        Dictionary of custom kwargs for the LJ calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.lj.LennardJones] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc = LennardJones(**calc_kwargs)\n    final_atoms = Runner(atoms, calc).run_calc()\n\n    return Summarize(\n        additional_fields={\"name\": \"LJ Static\"} | (additional_fields or {})\n    ).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/_base.html","title":"_base","text":"<p>Common utility functions for universal machine-learned interatomic potentials.</p>"},{"location":"reference/quacc/recipes/mlp/_base.html#quacc.recipes.mlp._base.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/_base.html#quacc.recipes.mlp._base.has_frozen","title":"has_frozen  <code>module-attribute</code>","text":"<pre><code>has_frozen = bool(find_spec('frozendict'))\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/_base.html#quacc.recipes.mlp._base.freezeargs","title":"freezeargs","text":"<pre><code>freezeargs(func: Callable) -&gt; Callable\n</code></pre> <p>Convert a mutable dictionary into immutable. Useful to make sure dictionary args are compatible with cache From https://stackoverflow.com/a/53394430</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>Function to be wrapped.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Wrapped function with frozen dictionary arguments.</p> </li> </ul> Source code in <code>quacc/recipes/mlp/_base.py</code> <pre><code>@requires(has_frozen, \"frozendict must be installed. Run pip install frozendict.\")\ndef freezeargs(func: Callable) -&gt; Callable:\n    \"\"\"\n    Convert a mutable dictionary into immutable.\n    Useful to make sure dictionary args are compatible with cache\n    From https://stackoverflow.com/a/53394430\n\n    Parameters\n    ----------\n    func\n        Function to be wrapped.\n\n    Returns\n    -------\n    Callable\n        Wrapped function with frozen dictionary arguments.\n    \"\"\"\n    from frozendict import frozendict\n\n    @wraps(func)\n    def wrapped(*args, **kwargs):\n        args = (frozendict(arg) if isinstance(arg, dict) else arg for arg in args)\n        kwargs = {\n            k: frozendict(v) if isinstance(v, dict) else v for k, v in kwargs.items()\n        }\n        return func(*args, **kwargs)\n\n    return wrapped\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/_base.html#quacc.recipes.mlp._base.pick_calculator","title":"pick_calculator  <code>cached</code>","text":"<pre><code>pick_calculator(\n    method: Literal[\n        \"mace-mp\",\n        \"m3gnet\",\n        \"chgnet\",\n        \"tensornet\",\n        \"sevennet\",\n        \"orb\",\n        \"fairchem\",\n    ],\n    **calc_kwargs\n) -&gt; BaseCalculator\n</code></pre> <p>Adapted from <code>matcalc.util.get_universal_calculator</code>.</p> <p>Note</p> <p>The <code>orb_models</code> are licensed under the APACHE license as found at the following link: https://github.com/orbital-materials/orb-models</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>Literal['mace-mp', 'm3gnet', 'chgnet', 'tensornet', 'sevennet', 'orb', 'fairchem']</code>)           \u2013            <p>Name of the calculator to use.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the underlying calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseCalculator</code>           \u2013            <p>The instantiated calculator</p> </li> </ul> Source code in <code>quacc/recipes/mlp/_base.py</code> <pre><code>@freezeargs\n@lru_cache\ndef pick_calculator(\n    method: Literal[\n        \"mace-mp\", \"m3gnet\", \"chgnet\", \"tensornet\", \"sevennet\", \"orb\", \"fairchem\"\n    ],\n    **calc_kwargs,\n) -&gt; BaseCalculator:\n    \"\"\"\n    Adapted from `matcalc.util.get_universal_calculator`.\n\n    !!! Note\n\n        The `orb_models` are licensed under the APACHE license as found at the following\n        link: https://github.com/orbital-materials/orb-models\n\n    Parameters\n    ----------\n    method\n        Name of the calculator to use.\n    **calc_kwargs\n        Custom kwargs for the underlying calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely.\n\n    Returns\n    -------\n    BaseCalculator\n        The instantiated calculator\n    \"\"\"\n    import torch\n\n    if not torch.cuda.is_available():\n        LOGGER.warning(\"CUDA is not available to PyTorch. Calculations will be slow.\")\n\n    method = method.lower()\n\n    if \"m3gnet\" in method or \"chgnet\" in method or \"tensornet\" in method:\n        import matgl\n        from matgl import __version__\n        from matgl.ext.ase import PESCalculator\n\n        if method == \"m3gnet\":\n            model = matgl.load_model(\"M3GNet-MatPES-PBE-v2025.1-PES\")\n        elif method == \"chgnet\":\n            model = matgl.load_model(\"CHGNet-MatPES-PBE-2025.2.10-2.7M-PES\")\n        elif method == \"tensornet\":\n            model = matgl.load_model(\"TensorNet-MatPES-PBE-v2025.1-PES\")\n        else:\n            model = matgl.load_model(method)\n\n        if \"stress_weight\" not in calc_kwargs:\n            calc_kwargs[\"stress_weight\"] = _GPa_to_eV_per_A3\n\n        calc = PESCalculator(potential=model, **calc_kwargs)\n\n    elif method.lower() == \"mace-mp\":\n        from mace import __version__\n        from mace.calculators import mace_mp\n\n        if \"default_dtype\" not in calc_kwargs:\n            calc_kwargs[\"default_dtype\"] = \"float64\"\n        calc = mace_mp(**calc_kwargs)\n\n    elif method.lower() == \"sevennet\":\n        from sevenn import __version__\n        from sevenn.sevennet_calculator import SevenNetCalculator\n\n        calc = SevenNetCalculator(**calc_kwargs)\n\n    elif method.lower() == \"orb\":\n        from orb_models import __version__\n        from orb_models.forcefield import pretrained\n        from orb_models.forcefield.calculator import ORBCalculator\n\n        orb_model = calc_kwargs.get(\"model\", \"orb_v2\")\n        orbff = getattr(pretrained, orb_model)()\n        calc = ORBCalculator(model=orbff, **calc_kwargs)\n\n    elif method.lower() == \"fairchem\":\n        from fairchem.core import FAIRChemCalculator, __version__\n\n        calc = FAIRChemCalculator.from_model_checkpoint(**calc_kwargs)\n\n    else:\n        raise ValueError(f\"Unrecognized {method=}.\")\n\n    calc.parameters[\"version\"] = __version__\n\n    return calc\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/core.html","title":"core","text":"<p>Core recipes for universal machine-learned interatomic potentials.</p>"},{"location":"reference/quacc/recipes/mlp/core.html#quacc.recipes.mlp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    method: Literal[\n        \"mace-mp-0\",\n        \"m3gnet\",\n        \"chgnet\",\n        \"sevennet\",\n        \"orb\",\n        \"fairchem\",\n    ],\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['mace-mp-0', 'm3gnet', 'chgnet', 'sevennet', 'orb', 'fairchem']</code>)           \u2013            <p>Universal ML interatomic potential method to use</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the cell.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the underlying calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>mace.calculators.mace_mp</code>, <code>chgnet.model.dynamics.CHGNetCalculator</code>, <code>matgl.ext.ase.M3GNetCalculator</code>, <code>sevenn.sevennet_calculator.SevenNetCalculator</code>, <code>orb_models.forcefield.calculator.ORBCalculator</code>, <code>fairchem.core.FAIRChemCalculator</code> calculators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/mlp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    method: Literal[\"mace-mp-0\", \"m3gnet\", \"chgnet\", \"sevennet\", \"orb\", \"fairchem\"],\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Universal ML interatomic potential method to use\n    relax_cell\n        Whether to relax the cell.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the underlying calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `mace.calculators.mace_mp`, `chgnet.model.dynamics.CHGNetCalculator`,\n        `matgl.ext.ase.M3GNetCalculator`, `sevenn.sevennet_calculator.SevenNetCalculator`,\n        `orb_models.forcefield.calculator.ORBCalculator`,\n        `fairchem.core.FAIRChemCalculator` calculators.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][].\n        See the type-hint for the data structure.\n    \"\"\"\n    opt_defaults = {\"fmax\": 0.05}\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    calc = pick_calculator(method, **calc_kwargs)\n\n    dyn = Runner(atoms, calc).run_opt(relax_cell=relax_cell, **opt_flags)\n\n    return Summarize(\n        additional_fields={\"name\": f\"{method} Relax\"} | (additional_fields or {})\n    ).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/core.html#quacc.recipes.mlp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    method: Literal[\n        \"mace-mp-0\",\n        \"m3gnet\",\n        \"chgnet\",\n        \"sevennet\",\n        \"orb\",\n        \"fairchem\",\n    ],\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['mace-mp-0', 'm3gnet', 'chgnet', 'sevennet', 'orb', 'fairchem']</code>)           \u2013            <p>Universal ML interatomic potential method to use</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the underlying calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>mace.calculators.mace_mp</code>, <code>chgnet.model.dynamics.CHGNetCalculator</code>, <code>matgl.ext.ase.M3GNetCalculator</code>, <code>sevenn.sevennet_calculator.SevenNetCalculator</code>, <code>orb_models.forcefield.calculator.ORBCalculator</code>, <code>fairchem.core.FAIRChemCalculator</code> calculators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/mlp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    method: Literal[\"mace-mp-0\", \"m3gnet\", \"chgnet\", \"sevennet\", \"orb\", \"fairchem\"],\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Universal ML interatomic potential method to use\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the underlying calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `mace.calculators.mace_mp`, `chgnet.model.dynamics.CHGNetCalculator`,\n        `matgl.ext.ase.M3GNetCalculator`, `sevenn.sevennet_calculator.SevenNetCalculator`,\n        `orb_models.forcefield.calculator.ORBCalculator`,\n        `fairchem.core.FAIRChemCalculator` calculators.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc = pick_calculator(method, **calc_kwargs)\n    final_atoms = Runner(atoms, calc).run_calc()\n    return Summarize(\n        additional_fields={\"name\": f\"{method} Static\"} | (additional_fields or {})\n    ).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/elastic.html","title":"elastic","text":"<p>Elastic constants recipes for MLPs.</p>"},{"location":"reference/quacc/recipes/mlp/elastic.html#quacc.recipes.mlp.elastic.elastic_tensor_flow","title":"elastic_tensor_flow","text":"<pre><code>elastic_tensor_flow(\n    atoms: Atoms,\n    pre_relax: bool = True,\n    run_static: bool = False,\n    deform_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; ElasticSchema\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Bulk structure relaxation (if pre_relax is True)</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.emt.core.relax_job</li> </ul> </li> <li> <p>Bulk structure static calculation (if run_static is True)</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> <li> <p>Deformed structures generation</p> </li> <li> <p>Deformed structures relaxations</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.emt.core.relax_job</li> </ul> </li> <li> <p>Deformed structures statics (if run_static is True)</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.emt.core.static_job</li> </ul> </li> <li> <p>Elastic tensor calculation</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>pre_relax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run a relaxation on the structure before deformation (true)</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to run static calculations after any relaxations on the undeformed or deformed structures</p> </li> <li> <code>deform_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.deformation.make_deformations_from_bulk</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ElasticSchema</code>           \u2013            <p>See the return type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/mlp/elastic.py</code> <pre><code>@flow\ndef elastic_tensor_flow(\n    atoms: Atoms,\n    pre_relax: bool = True,\n    run_static: bool = False,\n    deform_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; ElasticSchema:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Bulk structure relaxation (if pre_relax is True)\n        - name: \"relax_job\"\n        - job: [quacc.recipes.emt.core.relax_job][]\n\n    2. Bulk structure static calculation (if run_static is True)\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    3. Deformed structures generation\n\n    4. Deformed structures relaxations\n        - name: \"relax_job\"\n        - job: [quacc.recipes.emt.core.relax_job][]\n\n    5. Deformed structures statics (if run_static is True)\n        - name: \"static_job\"\n        - job: [quacc.recipes.emt.core.static_job][]\n\n    6. Elastic tensor calculation\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    pre_relax\n        Whether to run a relaxation on the structure before deformation (true)\n    run_static\n        Whether to run static calculations after any relaxations on the undeformed or deformed structures\n    deform_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.deformation.make_deformations_from_bulk][]\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    ElasticSchema\n        See the return type-hint for the data structure.\n    \"\"\"\n    relax_job_, static_job_ = customize_funcs(\n        [\"relax_job\", \"static_job\"],\n        [relax_job, static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )  # type: ignore\n\n    return elastic_tensor_flow_(\n        atoms=atoms,\n        relax_job=relax_job_,\n        static_job=static_job_,\n        pre_relax=pre_relax,\n        run_static=run_static,\n        deform_kwargs=deform_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/phonons.html","title":"phonons","text":"<p>Phonon recipes for MLPs.</p>"},{"location":"reference/quacc/recipes/mlp/phonons.html#quacc.recipes.mlp.phonons.has_phonopy","title":"has_phonopy  <code>module-attribute</code>","text":"<pre><code>has_phonopy = bool(find_spec('phonopy'))\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/phonons.html#quacc.recipes.mlp.phonons.has_seekpath","title":"has_seekpath  <code>module-attribute</code>","text":"<pre><code>has_seekpath = bool(find_spec('seekpath'))\n</code></pre>"},{"location":"reference/quacc/recipes/mlp/phonons.html#quacc.recipes.mlp.phonons.phonon_flow","title":"phonon_flow","text":"<pre><code>phonon_flow(\n    atoms: Atoms,\n    method: Literal[\n        \"mace-mp-0\",\n        \"m3gnet\",\n        \"chgnet\",\n        \"tensornet\",\n        \"sevennet\",\n        \"orb\",\n        \"fairchem\",\n    ],\n    symprec: float = 0.0001,\n    min_lengths: (\n        float | tuple[float, float, float] | None\n    ) = 20.0,\n    supercell_matrix: (\n        tuple[\n            tuple[int, int, int],\n            tuple[int, int, int],\n            tuple[int, int, int],\n        ]\n        | None\n    ) = None,\n    displacement: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; PhononSchema\n</code></pre> <p>Carry out a phonon workflow, consisting of:</p> <ol> <li> <p>Generation of supercells.</p> </li> <li> <p>Static calculations on supercells</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.mlp.core.static_job</li> </ul> </li> <li> <p>Calculation of thermodynamic properties.</p> </li> </ol> <p>Note</p> <p>Phonon calculations rely on a structure that is tightly converged. We suggest running a pre-relaxation with <code>opt_params = {\"fmax\": 1e-3}</code> or tighter before running this workflow.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['mace-mp-0', 'm3gnet', 'chgnet', 'tensornet', 'sevennet', 'orb', 'fairchem']</code>)           \u2013            <p>Universal ML interatomic potential method to use</p> </li> <li> <code>symprec</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Precision for symmetry detection.</p> </li> <li> <code>min_lengths</code>               (<code>float | tuple[float, float, float] | None</code>, default:                   <code>20.0</code> )           \u2013            <p>Minimum length of each lattice dimension (A).</p> </li> <li> <code>supercell_matrix</code>               (<code>tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The supercell matrix to use. If specified, it will override any value specified by <code>min_lengths</code>.</p> </li> <li> <code>displacement</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Atomic displacement (A).</p> </li> <li> <code>t_step</code>               (<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Temperature step (K).</p> </li> <li> <code>t_min</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Min temperature (K).</p> </li> <li> <code>t_max</code>               (<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>Max temperature (K).</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/mlp/phonons.py</code> <pre><code>@flow\n@requires(\n    has_phonopy, message=\"Phonopy must be installed. Run `pip install quacc[phonons]`\"\n)\n@requires(\n    has_seekpath, message=\"Seekpath must be installed. Run `pip install quacc[phonons]`\"\n)\ndef phonon_flow(\n    atoms: Atoms,\n    method: Literal[\n        \"mace-mp-0\", \"m3gnet\", \"chgnet\", \"tensornet\", \"sevennet\", \"orb\", \"fairchem\"\n    ],\n    symprec: float = 1e-4,\n    min_lengths: float | tuple[float, float, float] | None = 20.0,\n    supercell_matrix: (\n        tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None\n    ) = None,\n    displacement: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Carry out a phonon workflow, consisting of:\n\n    1. Generation of supercells.\n\n    2. Static calculations on supercells\n        - name: \"static_job\"\n        - job: [quacc.recipes.mlp.core.static_job][]\n\n    3. Calculation of thermodynamic properties.\n\n    !!! Note\n\n        Phonon calculations rely on a structure that is tightly converged.\n        We suggest running a pre-relaxation with `opt_params = {\"fmax\": 1e-3}`\n        or tighter before running this workflow.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        Universal ML interatomic potential method to use\n    symprec\n        Precision for symmetry detection.\n    min_lengths\n        Minimum length of each lattice dimension (A).\n    supercell_matrix\n        The supercell matrix to use. If specified, it will override any\n        value specified by `min_lengths`.\n    displacement\n        Atomic displacement (A).\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][].\n        See the type-hint for the data structure.\n    \"\"\"\n    job_param_defaults = {\"all\": {\"method\": method}}\n    static_job_ = customize_funcs(\n        [\"static_job\"],\n        [static_job],\n        param_defaults=job_param_defaults,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    return phonon_subflow(\n        atoms,\n        static_job_,\n        symprec=symprec,\n        min_lengths=min_lengths,\n        supercell_matrix=supercell_matrix,\n        displacement=displacement,\n        t_step=t_step,\n        t_min=t_min,\n        t_max=t_max,\n        additional_fields={\"name\": f\"{method} Phonons\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/mrcc/_base.html","title":"_base","text":"<p>Base jobs for MRCC.</p>"},{"location":"reference/quacc/recipes/mrcc/_base.html#quacc.recipes.mrcc._base.prep_calculator","title":"prep_calculator","text":"<pre><code>prep_calculator(\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: dict[str, str] | None = None,\n    input_swaps: dict[str, str] | None = None,\n) -&gt; MRCC\n</code></pre> <p>Prepare the MRCC calculator.</p> <p>Parameters:</p> <ul> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>default_inputs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default input parameters.</p> </li> <li> <code>input_swaps</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of mrccinput swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MRCC</code>           \u2013            <p>The MRCC calculator</p> </li> </ul> Source code in <code>quacc/recipes/mrcc/_base.py</code> <pre><code>def prep_calculator(\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: dict[str, str] | None = None,\n    input_swaps: dict[str, str] | None = None,\n) -&gt; MRCC:\n    \"\"\"\n    Prepare the MRCC calculator.\n\n    Parameters\n    ----------\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    default_inputs\n        Default input parameters.\n    input_swaps\n        Dictionary of mrccinput swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n\n    Returns\n    -------\n    MRCC\n        The MRCC calculator\n    \"\"\"\n    mrccinput = recursive_dict_merge(\n        default_inputs, input_swaps, {\"charge\": charge, \"mult\": spin_multiplicity}\n    )\n\n    # If spin_multiplicity bigger than 1, check if scftype is in either mrccinput or blocks\n    if spin_multiplicity &gt; 1:\n        if \"scftype\" not in mrccinput:\n            raise ValueError(\n                \"For spin_multiplicity &gt; 1, scftype keyword must be specified in mrccinput\"\n            )\n        if mrccinput[\"scftype\"].lower() not in [\"uhf\", \"uks\", \"rohf\", \"roks\"]:\n            raise ValueError(\n                \"For spin_multiplicity &gt; 1, scftype must not be set to RHF or RKS\"\n            )\n\n    settings = get_settings()\n\n    return MRCC(profile=MrccProfile(command=settings.MRCC_CMD), **mrccinput)\n</code></pre>"},{"location":"reference/quacc/recipes/mrcc/_base.html#quacc.recipes.mrcc._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: dict[str, str] | None = None,\n    input_swaps: dict[str, str] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base job function for MRCC recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>default_inputs</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default input parameters.</p> </li> <li> <code>input_swaps</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcasimpleinput swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize</p> </li> </ul> Source code in <code>quacc/recipes/mrcc/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: dict[str, str] | None = None,\n    input_swaps: dict[str, str] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for MRCC recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    default_inputs\n        Default input parameters.\n    input_swaps\n        List of orcasimpleinput swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize][]\n    \"\"\"\n    calc = prep_calculator(\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        input_swaps=input_swaps,\n    )\n\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/mrcc/core.html","title":"core","text":"<p>Core recipes for MRCC.</p>"},{"location":"reference/quacc/recipes/mrcc/core.html#quacc.recipes.mrcc.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"pbe\",\n    basis: str = \"def2-tzvp\",\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'pbe'</code> )           \u2013            <p>The method [e.g., PBE or CCSD(T)] to use, this is the value for the calc keyword.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Gaussian calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize</p> </li> </ul> Source code in <code>quacc/recipes/mrcc/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"pbe\",\n    basis: str = \"def2-tzvp\",\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        The method [e.g., PBE or CCSD(T)] to use, this is the value for the calc keyword.\n    basis\n        Basis set\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Gaussian calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize][]\n    \"\"\"\n    default_inputs = {\"calc\": method, \"basis\": basis, \"symm\": \"off\"}\n\n    return run_and_summarize(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        input_swaps=calc_kwargs,\n        additional_fields={\"name\": \"MRCC Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html","title":"core","text":"<p>Core recipes for the NewtonNet code.</p>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.has_newtonnet","title":"has_newtonnet  <code>module-attribute</code>","text":"<pre><code>has_newtonnet = bool(find_spec('newtonnet'))\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.has_sella","title":"has_sella  <code>module-attribute</code>","text":"<pre><code>has_sella = bool(find_spec('sella'))\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms: Atoms,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VibThermoSchema\n</code></pre> <p>Perform a frequency calculation using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>The temperature for the thermodynamic analysis.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The pressure for the thermodynamic analysis.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef freq_job(\n    atoms: Atoms,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Perform a frequency calculation using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    temperature\n        The temperature for the thermodynamic analysis.\n    pressure\n        The pressure for the thermodynamic analysis.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n\n    settings = get_settings()\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": \"autograd\",\n    }\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n\n    calc = MLAseCalculator(**calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    summary = Summarize(\n        additional_fields={\"name\": \"NewtonNet Frequency\"} | (additional_fields or {})\n    ).run(final_atoms, atoms)\n\n    vib = VibrationsData(final_atoms, summary[\"results\"][\"hessian\"])\n    return VibSummarize(\n        vib,\n        directory=summary[\"dir_name\"],\n        additional_fields={\"name\": \"ASE Vibrations and Thermo Analysis\"},\n    ).vib_and_thermo(\n        \"ideal_gas\",\n        energy=summary[\"results\"][\"energy\"],\n        temperature=temperature,\n        pressure=pressure,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.opt. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef relax_job(\n    atoms: Atoms,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.opt][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n    from sella import Sella\n\n    settings = get_settings()\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\"optimizer\": Sella} if has_sella else {}\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    calc = MLAseCalculator(**calc_flags)\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_opt(**opt_flags)\n\n    return _add_stdev_and_hess(\n        Summarize(\n            additional_fields={\"name\": \"NewtonNet Relax\"} | (additional_fields or {})\n        ).opt(dyn)\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/core.html#quacc.recipes.newtonnet.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/core.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n\n    settings = get_settings()\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n    }\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n\n    calc = MLAseCalculator(**calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(\n        additional_fields={\"name\": \"NewtonNet Static\"} | (additional_fields or {})\n    ).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html","title":"ts","text":"<p>Transition state recipes for the NewtonNet code.</p>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.has_geodesic_interpolate","title":"has_geodesic_interpolate  <code>module-attribute</code>","text":"<pre><code>has_geodesic_interpolate = bool(\n    find_spec(\"geodesic_interpolate\")\n)\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.has_newtonnet","title":"has_newtonnet  <code>module-attribute</code>","text":"<pre><code>has_newtonnet = bool(find_spec('newtonnet'))\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.has_sella","title":"has_sella  <code>module-attribute</code>","text":"<pre><code>has_sella = bool(find_spec('sella'))\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.geodesic_job","title":"geodesic_job","text":"<pre><code>geodesic_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    geodesic_interpolate_kwargs: (\n        dict[str, Any] | None\n    ) = None,\n    **calc_kwargs\n) -&gt; GeodesicSchema\n</code></pre> <p>Perform a quasi-IRC job using the given reactant and product atoms objects.</p> <p>Parameters:</p> <ul> <li> <code>reactant_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the reactant structure.</p> </li> <li> <code>product_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the product structure.</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for quacc.recipes.newtonnet.core.relax_job function.</p> </li> <li> <code>geodesic_interpolate_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for geodesic_interpolate, by default None.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeodesicSchema</code>           \u2013            <p>A dictionary containing the following keys:     - 'relax_reactant': Summary of the relaxed reactant structure.     - 'relax_product': Summary of the relaxed product structure.     - 'initial_images': The interpolated images between reactant and product.     - 'ts_atoms': ASE atoms object for the highest energy structure for the geodesic path</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(\n    has_geodesic_interpolate,\n    \"geodesic-interpolate must be installed. Refer to the quacc documentation.\",\n)\ndef geodesic_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    geodesic_interpolate_kwargs: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; GeodesicSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given reactant and product atoms objects.\n\n    Parameters\n    ----------\n    reactant_atoms\n        The Atoms object representing the reactant structure.\n    product_atoms\n        The Atoms object representing the product structure.\n    relax_job_kwargs\n        Keyword arguments to use for [quacc.recipes.newtonnet.core.relax_job][] function.\n    geodesic_interpolate_kwargs\n        Keyword arguments for geodesic_interpolate, by default None.\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    GeodesicSchema\n        A dictionary containing the following keys:\n            - 'relax_reactant': Summary of the relaxed reactant structure.\n            - 'relax_product': Summary of the relaxed product structure.\n            - 'initial_images': The interpolated images between reactant and product.\n            - 'ts_atoms': ASE atoms object for the highest energy structure for the geodesic path\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n\n    from quacc.atoms.ts import geodesic_interpolate_wrapper\n\n    relax_job_kwargs = relax_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": None,\n    }\n\n    geodesic_defaults = {\"n_images\": 20}\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc_flags[\"hess_method\"] = None\n    geodesic_interpolate_flags = recursive_dict_merge(\n        geodesic_defaults, geodesic_interpolate_kwargs\n    )\n\n    # Define calculator\n    reactant_atoms.calc = MLAseCalculator(**calc_flags)\n    product_atoms.calc = MLAseCalculator(**calc_flags)\n\n    # Run IRC\n    relax_summary_r = strip_decorator(relax_job)(reactant_atoms, **relax_job_kwargs)\n    relax_summary_p = strip_decorator(relax_job)(product_atoms, **relax_job_kwargs)\n\n    images = geodesic_interpolate_wrapper(\n        relax_summary_r[\"atoms\"].copy(),\n        relax_summary_p[\"atoms\"].copy(),\n        **geodesic_interpolate_flags,\n    )\n\n    potential_energies = []\n    for image in images:\n        image.calc = MLAseCalculator(**calc_flags)\n        potential_energies.append(image.get_potential_energy())\n\n    ts_index = np.argmax(potential_energies)\n    ts_atoms = images[ts_index]\n\n    return {\n        \"relax_reactant\": relax_summary_r,\n        \"relax_product\": relax_summary_p,\n        \"initial_images\": images,\n        \"ts_atoms\": ts_atoms,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; NewtonNetIRCSchema\n</code></pre> <p>Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system.</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the frequency analysis.</p> </li> <li> <code>freq_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.freq_job</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IRCSchema</code>           \u2013            <p>A dictionary containing the IRC summary and thermodynamic summary. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; NewtonNetIRCSchema:\n    \"\"\"\n    Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    run_freq\n        Whether to run the frequency analysis.\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.freq_job][]\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    IRCSchema\n        A dictionary containing the IRC summary and thermodynamic summary.\n        See the type-hint for the data structure.\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n    from sella import IRC\n\n    freq_job_kwargs = freq_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\"dx\": 0.1, \"eta\": 1e-4, \"gamma\": 0.4, \"keep_going\": True},\n        \"run_kwargs\": {\"direction\": direction},\n    }\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    # Define calculator\n    calc = MLAseCalculator(**calc_flags)\n\n    # Run IRC\n    with change_settings({\"CHECK_CONVERGENCE\": False}):\n        dyn = Runner(atoms, calc).run_opt(**opt_flags)\n        opt_irc_summary = _add_stdev_and_hess(\n            Summarize(\n                additional_fields={\"name\": f\"NewtonNet IRC: {direction}\"}\n                | (additional_fields or {})\n            ).opt(dyn)\n        )\n\n    # Run frequency job\n    freq_summary = (\n        strip_decorator(freq_job)(opt_irc_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    opt_irc_summary[\"freq_job\"] = freq_summary\n\n    return opt_irc_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.neb_job","title":"neb_job","text":"<pre><code>neb_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    interpolation_method: Literal[\n        \"linear\", \"idpp\", \"geodesic\"\n    ] = \"linear\",\n    relax_job_kwargs: dict[str, Any] | None = None,\n    interpolate_kwargs: dict[str, Any] | None = None,\n    neb_kwargs: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; NebSchema\n</code></pre> <p>Perform a nudged elastic band (NEB) calculation to find the minimum energy path (MEP) between the given reactant and product structures.</p> <p>Parameters:</p> <ul> <li> <code>reactant_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the reactant structure.</p> </li> <li> <code>product_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the product structure.</p> </li> <li> <code>interpolation_method</code>               (<code>Literal['linear', 'idpp', 'geodesic']</code>, default:                   <code>'linear'</code> )           \u2013            <p>The method to initialize the NEB optimization. There are three choices here, \"linear\", \"idpp\" and \"geodesic\". Defaults to linear.</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.relax_job function.</p> </li> <li> <code>interpolate_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the interpolate functions (geodesic, linear or idpp).</p> </li> <li> <code>neb_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the NEB calculation.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NebSchema</code>           \u2013            <p>A dictionary containing the NEB results</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef neb_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    interpolation_method: Literal[\"linear\", \"idpp\", \"geodesic\"] = \"linear\",\n    relax_job_kwargs: dict[str, Any] | None = None,\n    interpolate_kwargs: dict[str, Any] | None = None,\n    neb_kwargs: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; NebSchema:\n    \"\"\"\n    Perform a nudged elastic band (NEB) calculation to find the minimum energy path (MEP) between the given reactant and product structures.\n\n    Parameters\n    ----------\n    reactant_atoms\n        The Atoms object representing the reactant structure.\n    product_atoms\n        The Atoms object representing the product structure.\n    interpolation_method\n        The method to initialize the NEB optimization. There are three choices here, \"linear\", \"idpp\" and \"geodesic\".\n        Defaults to linear.\n    relax_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.relax_job][] function.\n    interpolate_kwargs\n        Keyword arguments for the interpolate functions (geodesic, linear or idpp).\n    neb_kwargs\n        Keyword arguments for the NEB calculation.\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    NebSchema\n        A dictionary containing the NEB results\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n\n    from quacc.atoms.ts import geodesic_interpolate_wrapper\n\n    relax_job_kwargs = relax_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": None,\n    }\n\n    interpolate_defaults = {\"n_images\": 20}\n\n    neb_defaults = {\"method\": \"aseneb\", \"precon\": None}\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    interpolate_flags = recursive_dict_merge(interpolate_defaults, interpolate_kwargs)\n    neb_flags = recursive_dict_merge(neb_defaults, neb_kwargs)\n\n    # Define calculator\n    calc = MLAseCalculator(**calc_flags)\n\n    # Run relax job\n    relax_summary_r = strip_decorator(relax_job)(reactant_atoms, **relax_job_kwargs)\n    relax_summary_p = strip_decorator(relax_job)(product_atoms, **relax_job_kwargs)\n\n    if interpolation_method == \"geodesic\":\n        images = geodesic_interpolate_wrapper(\n            relax_summary_r[\"atoms\"], relax_summary_p[\"atoms\"], **interpolate_flags\n        )\n    else:\n        images = [reactant_atoms]\n        images += [\n            reactant_atoms.copy() for _ in range(interpolate_flags[\"n_images\"] - 2)\n        ]\n        images += [product_atoms]\n        neb = NEB(images)\n\n        # Interpolate linearly the positions of the middle images:\n        neb.interpolate(method=interpolation_method)\n        images = neb.images\n\n    max_steps = neb_flags.pop(\"max_steps\", None)\n    dyn = Runner(images, calc).run_neb(max_steps=max_steps, neb_kwargs=neb_flags)\n\n    return {\n        \"relax_reactant\": relax_summary_r,\n        \"relax_product\": relax_summary_p,\n        \"initial_images\": images,\n        \"neb_results\": Summarize(\n            additional_fields={\n                \"neb_flags\": neb_flags,\n                \"calc_flags\": calc_flags,\n                \"interpolate_flags\": interpolate_flags,\n            }\n        ).neb(dyn, len(images)),\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    irc_job_kwargs: dict[str, Any] | None = None,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    freq_job_kwargs: dict[str, Any] | None = None,\n) -&gt; NewtonNetQuasiIRCSchema\n</code></pre> <p>Perform a quasi-IRC job using the given atoms object. The initial IRC job by default is run with <code>max_steps: 5</code>.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>The direction of the IRC calculation</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the frequency analysis</p> </li> <li> <code>irc_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.irc_job</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.relax_job</p> </li> <li> <code>freq_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.freq_job</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QuasiIRCSchema</code>           \u2013            <p>A dictionary containing the IRC summary, optimization summary, and thermodynamic summary. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef quasi_irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    irc_job_kwargs: dict[str, Any] | None = None,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    freq_job_kwargs: dict[str, Any] | None = None,\n) -&gt; NewtonNetQuasiIRCSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given atoms object. The initial IRC job by default\n    is run with `max_steps: 5`.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system\n    direction\n        The direction of the IRC calculation\n    run_freq\n        Whether to run the frequency analysis\n    irc_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.irc_job][]\n    relax_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.relax_job][]\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.freq_job][]\n\n    Returns\n    -------\n    QuasiIRCSchema\n        A dictionary containing the IRC summary, optimization summary, and\n        thermodynamic summary.\n        See the type-hint for the data structure.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    freq_job_kwargs = freq_job_kwargs or {}\n\n    irc_job_defaults = {\"max_steps\": 5}\n    irc_job_kwargs = recursive_dict_merge(irc_job_defaults, irc_job_kwargs)\n\n    # Run IRC\n    irc_summary = strip_decorator(irc_job)(\n        atoms, direction=direction, run_freq=False, **irc_job_kwargs\n    )\n\n    # Run opt\n    relax_summary = strip_decorator(relax_job)(irc_summary[\"atoms\"], **relax_job_kwargs)\n\n    # Run frequency\n    freq_summary = (\n        strip_decorator(freq_job)(relax_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    relax_summary[\"freq_job\"] = freq_summary\n    relax_summary[\"irc_job\"] = irc_summary\n\n    return relax_summary\n</code></pre>"},{"location":"reference/quacc/recipes/newtonnet/ts.html#quacc.recipes.newtonnet.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\n    atoms: Atoms,\n    use_custom_hessian: bool = False,\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; NewtonNetTSSchema\n</code></pre> <p>Perform a transition state (TS) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system.</p> </li> <li> <code>use_custom_hessian</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a custom Hessian matrix.</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the frequency job.</p> </li> <li> <code>freq_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.freq_job</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TSSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef ts_job(\n    atoms: Atoms,\n    use_custom_hessian: bool = False,\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; NewtonNetTSSchema:\n    \"\"\"\n    Perform a transition state (TS) job using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    use_custom_hessian\n        Whether to use a custom Hessian matrix.\n    run_freq\n        Whether to run the frequency job.\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.freq_job][]\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    TSSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    from newtonnet.utils.ase_interface import MLAseCalculator\n    from sella import Sella\n\n    additional_fields = additional_fields or {}\n    freq_job_kwargs = freq_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"optimizer\": Sella,\n        \"optimizer_kwargs\": (\n            {\"diag_every_n\": 0, \"order\": 1} if use_custom_hessian else {\"order\": 1}\n        ),\n    }\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    if use_custom_hessian:\n        opt_flags[\"optimizer_kwargs\"][\"hessian_function\"] = _get_hessian\n\n    calc = MLAseCalculator(**calc_flags)\n\n    # Run the TS optimization\n    dyn = Runner(atoms, calc).run_opt(**opt_flags)\n    opt_ts_summary = _add_stdev_and_hess(\n        Summarize(additional_fields={\"name\": \"NewtonNet TS\"}).opt(dyn), **calc_flags\n    )\n\n    # Run a frequency calculation\n    freq_summary = (\n        strip_decorator(freq_job)(opt_ts_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    opt_ts_summary[\"freq_job\"] = freq_summary\n\n    return opt_ts_summary\n</code></pre>"},{"location":"reference/quacc/recipes/onetep/_base.html","title":"_base","text":"<p>Base jobs for Onetep.</p>"},{"location":"reference/quacc/recipes/onetep/_base.html#quacc.recipes.onetep._base.prep_calculator","title":"prep_calculator","text":"<pre><code>prep_calculator(\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n) -&gt; Onetep\n</code></pre> <p>Prepare the Onetep calculator.</p> <p>Parameters:</p> <ul> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the ONETEP calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.onetep.Onetep calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Onetep</code>           \u2013            <p>The Onetep calculator.</p> </li> </ul> Source code in <code>quacc/recipes/onetep/_base.py</code> <pre><code>def prep_calculator(\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n) -&gt; Onetep:\n    \"\"\"\n    Prepare the Onetep calculator.\n\n    Parameters\n    ----------\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the ONETEP calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.onetep.Onetep][] calculator.\n\n    Returns\n    -------\n    Onetep\n        The Onetep calculator.\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n    settings = get_settings()\n\n    return Onetep(\n        profile=OnetepProfile(f\"{settings.ONETEP_CMD}\", str(settings.ONETEP_PP_PATH)),\n        **calc_flags,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/onetep/_base.html#quacc.recipes.onetep._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base function to carry out Onetep recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the ONETEP calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.onetep.Onetep calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/onetep/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base function to carry out Onetep recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the ONETEP calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.onetep.Onetep][] calculator.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    calc = prep_calculator(calc_defaults=calc_defaults, calc_swaps=calc_swaps)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/onetep/_base.html#quacc.recipes.onetep._base.run_and_summarize_opt","title":"run_and_summarize_opt","text":"<pre><code>run_and_summarize_opt(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base function to carry out Onetep recipes with ASE optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the ONETEP calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.onetep.Onetep calculator.</p> </li> <li> <code>opt_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default optimization parameters.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/onetep/_base.py</code> <pre><code>def run_and_summarize_opt(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base function to carry out Onetep recipes with ASE optimizers.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the ONETEP calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.onetep.Onetep][] calculator.\n    opt_defaults\n        The default optimization parameters.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n    calc = prep_calculator(calc_defaults=calc_defaults, calc_swaps=calc_swaps)\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_opt(**opt_flags)\n\n    return Summarize(additional_fields=additional_fields).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/onetep/core.html","title":"core","text":"<p>Core recipes for Onetep.</p>"},{"location":"reference/quacc/recipes/onetep/core.html#quacc.recipes.onetep.core.BASE_SET","title":"BASE_SET  <code>module-attribute</code>","text":"<pre><code>BASE_SET = {\n    \"keywords\": {\n        \"output_detail\": \"verbose\",\n        \"do_properties\": True,\n        \"cutoff_energy\": \"600 eV\",\n        \"task\": \"SinglePoint\",\n    }\n}\n</code></pre>"},{"location":"reference/quacc/recipes/onetep/core.html#quacc.recipes.onetep.core.ase_relax_job","title":"ase_relax_job","text":"<pre><code>ase_relax_job(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a structure relaxation with ONETEP using ASE external optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the ONETEP calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/onetep/core.py</code> <pre><code>@job\ndef ase_relax_job(\n    atoms: Atoms,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a structure relaxation with ONETEP using ASE\n    external optimizers.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    relax_cell\n        True if a volume relaxation should be performed. False if only the positions\n        should be updated.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Additional keyword arguments to pass to the ONETEP calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = recursive_dict_merge(\n        BASE_SET,\n        {\"keywords\": {\"write_forces\": True, \"forces_output_detail\": \"verbose\"}},\n    )\n\n    opt_defaults = {\"optimizer\": LBFGS, \"relax_cell\": relax_cell}\n\n    return run_and_summarize_opt(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"ONETEP ASE Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/onetep/core.html#quacc.recipes.onetep.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a basic SCF calculation with ONETEP.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the ONETEP calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.onetep.Onetep calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results, specified in quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/onetep/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a basic SCF calculation with ONETEP.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the ONETEP calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.onetep.Onetep][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results, specified in [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    return run_and_summarize(\n        atoms,\n        calc_defaults=BASE_SET,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"ONETEP Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/_base.html","title":"_base","text":"<p>Base jobs for ORCA.</p>"},{"location":"reference/quacc/recipes/orca/_base.html#quacc.recipes.orca._base.GEOM_FILE","title":"GEOM_FILE  <code>module-attribute</code>","text":"<pre><code>GEOM_FILE = f'{_LABEL}.xyz'\n</code></pre>"},{"location":"reference/quacc/recipes/orca/_base.html#quacc.recipes.orca._base.prep_calculator","title":"prep_calculator","text":"<pre><code>prep_calculator(\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: list[str] | None = None,\n    default_blocks: list[str] | None = None,\n    input_swaps: list[str] | None = None,\n    block_swaps: list[str] | None = None,\n    **calc_kwargs\n) -&gt; ORCA\n</code></pre> <p>Prepare the ORCA calculator.</p> <p>Parameters:</p> <ul> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>default_inputs</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default input parameters.</p> </li> <li> <code>default_blocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default block input parameters.</p> </li> <li> <code>input_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcasimpleinput swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>block_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcablock swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Any other keyword arguments to pass to the <code>ORCA</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ORCA</code>           \u2013            <p>The ORCA calculator</p> </li> </ul> Source code in <code>quacc/recipes/orca/_base.py</code> <pre><code>def prep_calculator(\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: list[str] | None = None,\n    default_blocks: list[str] | None = None,\n    input_swaps: list[str] | None = None,\n    block_swaps: list[str] | None = None,\n    **calc_kwargs,\n) -&gt; ORCA:\n    \"\"\"\n    Prepare the ORCA calculator.\n\n    Parameters\n    ----------\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    default_inputs\n        Default input parameters.\n    default_blocks\n        Default block input parameters.\n    input_swaps\n        List of orcasimpleinput swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    block_swaps\n        List of orcablock swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    **calc_kwargs\n        Any other keyword arguments to pass to the `ORCA` calculator.\n\n    Returns\n    -------\n    ORCA\n        The ORCA calculator\n    \"\"\"\n    inputs = merge_list_params(default_inputs, input_swaps)\n    blocks = merge_list_params(default_blocks, block_swaps)\n    if \"xyzfile\" not in inputs:\n        inputs.append(\"xyzfile\")\n    orcasimpleinput = \" \".join(inputs)\n    orcablocks = \"\\n\".join(blocks)\n    settings = get_settings()\n\n    return ORCA(\n        profile=OrcaProfile(command=settings.ORCA_CMD),\n        charge=charge,\n        mult=spin_multiplicity,\n        orcasimpleinput=orcasimpleinput,\n        orcablocks=orcablocks,\n        **calc_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/_base.html#quacc.recipes.orca._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: list[str] | None = None,\n    default_blocks: list[str] | None = None,\n    input_swaps: list[str] | None = None,\n    block_swaps: list[str] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Base job function for ORCA recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>default_inputs</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default input parameters.</p> </li> <li> <code>default_blocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default block input parameters.</p> </li> <li> <code>input_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcasimpleinput swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>block_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcablock swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Any other keyword arguments to pass to the <code>ORCA</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: list[str] | None = None,\n    default_blocks: list[str] | None = None,\n    input_swaps: list[str] | None = None,\n    block_swaps: list[str] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for ORCA recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    default_inputs\n        Default input parameters.\n    default_blocks\n        Default block input parameters.\n    input_swaps\n        List of orcasimpleinput swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    block_swaps\n        List of orcablock swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Any other keyword arguments to pass to the `ORCA` calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    calc = prep_calculator(\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=input_swaps,\n        block_swaps=block_swaps,\n        **calc_kwargs,\n    )\n\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc(\n        geom_file=GEOM_FILE\n    )\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/orca/_base.html#quacc.recipes.orca._base.run_and_summarize_opt","title":"run_and_summarize_opt","text":"<pre><code>run_and_summarize_opt(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: list[str] | None = None,\n    default_blocks: list[str] | None = None,\n    input_swaps: list[str] | None = None,\n    block_swaps: list[str] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Base job function for ORCA recipes with ASE optimizer.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>default_inputs</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default input parameters.</p> </li> <li> <code>default_blocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default block input parameters.</p> </li> <li> <code>input_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcasimpleinput swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>block_swaps</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of orcablock swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name.</p> </li> <li> <code>opt_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default arguments for the ASE optimizer.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for quacc.runners.ase.Runner.run_opt</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Any other keyword arguments to pass to the <code>ORCA</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/_base.py</code> <pre><code>def run_and_summarize_opt(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    default_inputs: list[str] | None = None,\n    default_blocks: list[str] | None = None,\n    input_swaps: list[str] | None = None,\n    block_swaps: list[str] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Base job function for ORCA recipes with ASE optimizer.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    default_inputs\n        Default input parameters.\n    default_blocks\n        Default block input parameters.\n    input_swaps\n        List of orcasimpleinput swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    block_swaps\n        List of orcablock swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name.\n    opt_defaults\n        Default arguments for the ASE optimizer.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.Runner.run_opt][]\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Any other keyword arguments to pass to the `ORCA` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results\n    \"\"\"\n    calc = prep_calculator(\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=input_swaps,\n        block_swaps=block_swaps,\n        **calc_kwargs,\n    )\n\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_opt(**opt_flags)\n    return Summarize(additional_fields=additional_fields).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html","title":"core","text":"<p>Core recipes for ORCA.</p>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.ase_quasi_irc_job","title":"ase_quasi_irc_job","text":"<pre><code>ase_quasi_irc_job(\n    atoms: Atoms,\n    mode: list[list[float]] | NDArray,\n    perturb_magnitude: float = 0.6,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    opt_params: OptParams | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; OptSchema\n</code></pre> <p>Quasi-IRC to optimize a reaction endpoint from a transition-state with known vibrational frequency modes. Perturbs the structure of <code>atoms</code> by a finite amount (0.6 * the normalized mode magnitude) along the specified vibrational frequency mode (assumed to be the transition mode), and then performs a <code>relax_job</code> on the perturbed structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>mode</code>               (<code>list[list[float]] | NDArray</code>)           \u2013            <p>Transition mode. This should be an Nx3 matrix, where N is the number of atoms in <code>atoms</code>.</p> </li> <li> <code>perturb_magnitude</code>               (<code>float</code>, default:                   <code>0.6</code> )           \u2013            <p>Factor to multiply the transition mode. Default is 0.6. In some cases, it may be advisable to increase this factor, perhaps to 1.0 or 1.1. Lowering it is not generally found to be helpful.</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>Direction of the (Quasi)IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97x-d3bj'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>orcasimpleinput</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcasimpleinput</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcasimpleinput</code>.</p> </li> <li> <code>orcablocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcablocks</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcablocks</code>.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of optimization parameters.</p> </li> <li> <code>nprocs</code>               (<code>int | Literal['max']</code>, default:                   <code>'max'</code> )           \u2013            <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef ase_quasi_irc_job(\n    atoms: Atoms,\n    mode: list[list[float]] | NDArray,\n    perturb_magnitude: float = 0.6,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    opt_params: OptParams | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Quasi-IRC to optimize a reaction endpoint from a transition-state with known vibrational frequency modes.\n    Perturbs the structure of `atoms` by a finite amount (0.6 * the normalized mode magnitude) along the specified\n    vibrational frequency mode (assumed to be the transition mode), and then performs a `relax_job` on the perturbed\n    structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    mode\n        Transition mode. This should be an Nx3 matrix, where N is the number of atoms in `atoms`.\n    perturb_magnitude\n        Factor to multiply the transition mode. Default is 0.6. In some cases, it may be advisable to increase this\n        factor, perhaps to 1.0 or 1.1. Lowering it is not generally found to be helpful.\n    direction\n        Direction of the (Quasi)IRC. Should be \"forward\" or \"reverse\".\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set.\n    orcasimpleinput\n        List of `orcasimpleinput` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcasimpleinput`.\n    orcablocks\n        List of `orcablocks` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcablocks`.\n    opt_params\n        Dictionary of optimization parameters.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results\n    \"\"\"\n    nprocs = (psutil.cpu_count(logical=False) if nprocs == \"max\" else nprocs) or 1\n    default_inputs = [xc, basis, \"engrad\", \"normalprint\"]\n    default_blocks = [f\"%pal nprocs {nprocs} end\"]\n\n    scale = perturb_magnitude if direction == \"forward\" else perturb_magnitude * -1\n\n    return run_and_summarize_opt(\n        perturb(atoms, mode, scale),\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"ORCA ASE Quasi-IRC\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.ase_relax_job","title":"ase_relax_job","text":"<pre><code>ase_relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    opt_params: OptParams | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; OptSchema\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97x-d3bj'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>orcasimpleinput</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcasimpleinput</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcasimpleinput</code>.</p> </li> <li> <code>orcablocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcablocks</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcablocks</code>.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of optimization parameters.</p> </li> <li> <code>nprocs</code>               (<code>int | Literal['max']</code>, default:                   <code>'max'</code> )           \u2013            <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef ase_relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    opt_params: OptParams | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set.\n    orcasimpleinput\n        List of `orcasimpleinput` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcasimpleinput`.\n    orcablocks\n        List of `orcablocks` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcablocks`.\n    opt_params\n        Dictionary of optimization parameters.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results\n    \"\"\"\n    nprocs = (psutil.cpu_count(logical=False) if nprocs == \"max\" else nprocs) or 1\n    default_inputs = [xc, basis, \"engrad\", \"normalprint\"]\n    default_blocks = [f\"%pal nprocs {nprocs} end\"]\n\n    return run_and_summarize_opt(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"ORCA ASE Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    numerical: bool = False,\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Carry out a vibrational frequency analysis calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97x-d3bj'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>numerical</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True (default False), a numeric frequency calculation will be requested</p> </li> <li> <code>orcasimpleinput</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcasimpleinput</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcasimpleinput</code>.</p> </li> <li> <code>orcablocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcablocks</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcablocks</code>.</p> </li> <li> <code>nprocs</code>               (<code>int | Literal['max']</code>, default:                   <code>'max'</code> )           \u2013            <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    numerical: bool = False,\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a vibrational frequency analysis calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    numerical\n        If True (default False), a numeric frequency calculation will be requested\n    orcasimpleinput\n        List of `orcasimpleinput` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcasimpleinput`.\n    orcablocks\n        List of `orcablocks` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcablocks`.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    nprocs = (psutil.cpu_count(logical=False) if nprocs == \"max\" else nprocs) or 1\n    default_inputs = [xc, basis, \"normalprint\", \"numfreq\" if numerical else \"freq\"]\n    default_blocks = [f\"%pal nprocs {nprocs} end\"]\n\n    return run_and_summarize(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields={\"name\": \"ORCA Vibrational Frequency Analysis\"}\n        | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    run_freq: bool = False,\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Carry out a geometry optimization.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97x-d3bj'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If a frequency calculation should be carried out.</p> </li> <li> <code>orcasimpleinput</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcasimpleinput</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcasimpleinput</code>.</p> </li> <li> <code>orcablocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcablocks</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcablocks</code>.</p> </li> <li> <code>nprocs</code>               (<code>int | Literal['max']</code>, default:                   <code>'max'</code> )           \u2013            <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    run_freq: bool = False,\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a geometry optimization.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    run_freq\n        If a frequency calculation should be carried out.\n    orcasimpleinput\n        List of `orcasimpleinput` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcasimpleinput`.\n    orcablocks\n        List of `orcablocks` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcablocks`.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    additional_fields = {\"name\": \"ORCA Relax\"} | (additional_fields or {})\n    nprocs = (psutil.cpu_count(logical=False) if nprocs == \"max\" else nprocs) or 1\n\n    default_inputs = [xc, basis, \"normalprint\", \"opt\"]\n    if run_freq:\n        default_inputs.append(\"freq\")\n\n    default_blocks = [f\"%pal nprocs {nprocs} end\"]\n\n    return run_and_summarize(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields=additional_fields,\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/orca/core.html#quacc.recipes.orca.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97x-d3bj'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>orcasimpleinput</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcasimpleinput</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcasimpleinput</code>.</p> </li> <li> <code>orcablocks</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of <code>orcablocks</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcablocks</code>.</p> </li> <li> <code>nprocs</code>               (<code>int | Literal['max']</code>, default:                   <code>'max'</code> )           \u2013            <p>Number of processors to use. Defaults to the number of physical cores.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/orca/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] = \"max\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    orcasimpleinput\n        List of `orcasimpleinput` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcasimpleinput`.\n    orcablocks\n        List of `orcablocks` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA][] calculator for details on `orcablocks`.\n    nprocs\n        Number of processors to use. Defaults to the number of physical cores.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    additional_fields = {\"name\": \"ORCA Static\"} | (additional_fields or {})\n    nprocs = (psutil.cpu_count(logical=False) if nprocs == \"max\" else nprocs) or 1\n    default_inputs = [xc, basis, \"engrad\", \"normalprint\"]\n    default_blocks = [f\"%pal nprocs {nprocs} end\"]\n\n    return run_and_summarize(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields=additional_fields,\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/_base.html","title":"_base","text":"<p>Base jobs for Psi4.</p>"},{"location":"reference/quacc/recipes/psi4/_base.html#quacc.recipes.psi4._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base function to carry out Psi4 recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default calculator parameters.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the Psi4 calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.psi4.Psi4 calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/psi4/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base function to carry out Psi4 recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    calc_defaults\n        The default calculator parameters.\n    calc_swaps\n        Custom kwargs for the Psi4 calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.psi4.Psi4][] calculator.\n    additional_fields\n        Any additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    calc = Psi4(**calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/core.html","title":"core","text":"<p>Core recipes for Psi4.</p>"},{"location":"reference/quacc/recipes/psi4/core.html#quacc.recipes.psi4.core.has_psi4","title":"has_psi4  <code>module-attribute</code>","text":"<pre><code>has_psi4 = bool(find_spec('psi4'))\n</code></pre>"},{"location":"reference/quacc/recipes/psi4/core.html#quacc.recipes.psi4.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97x-v\",\n    basis: str = \"def2-tzvp\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Function to carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'wb97x-v'</code> )           \u2013            <p>The level of theory to use.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Psi4 calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.psi4.Psi4 calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/psi4/core.py</code> <pre><code>@job\n@requires(has_psi4, \"Psi4 not installed. Try conda install -c psi4 psi4\")\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97x-v\",\n    basis: str = \"def2-tzvp\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Function to carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        The level of theory to use.\n    basis\n        Basis set\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Psi4 calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.psi4.Psi4][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"mem\": \"16GB\",\n        \"num_threads\": \"max\",\n        \"method\": method,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"multiplicity\": spin_multiplicity,\n        \"reference\": \"uks\" if spin_multiplicity &gt; 1 else \"rks\",\n    }\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Psi4 Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/_base.html","title":"_base","text":"<p>Base jobs for Q-Chem.</p>"},{"location":"reference/quacc/recipes/qchem/_base.html#quacc.recipes.qchem._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema\n</code></pre> <p>Base job function used for Q-Chem recipes that don't rely on ASE optimizers or other ASE dynamics classes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The default parameters for the recipe.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Q-Chem calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.qchem.qchem.QChem</code> calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any additional fields to set in the summary.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function used for Q-Chem recipes that don't rely on ASE optimizers or other\n    ASE dynamics classes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    calc_defaults\n        The default parameters for the recipe.\n    calc_swaps\n        Dictionary of custom kwargs for the Q-Chem calculator. Set a value to `quacc.Remove` to\n        remove a pre-existing key entirely. For a list of available keys, refer to the\n        `quacc.calculators.qchem.qchem.QChem` calculator.\n    additional_fields\n        Any additional fields to set in the summary.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n    calc = QChem(\n        atoms, charge=charge, spin_multiplicity=spin_multiplicity, **calc_flags\n    )\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(additional_fields=additional_fields).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/_base.html#quacc.recipes.qchem._base.run_and_summarize_opt","title":"run_and_summarize_opt","text":"<pre><code>run_and_summarize_opt(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; OptSchema\n</code></pre> <p>Base function for Q-Chem recipes that involve ASE optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default arguments for the Q-Chem calculator.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Q-Chem calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>quacc.calculators.qchem.qchem.QChem</code> calculator.</p> </li> <li> <code>opt_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default arguments for the ASE optimizer.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for quacc.runners.ase.Runner.run_opt</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt</p> </li> </ul> Source code in <code>quacc/recipes/qchem/_base.py</code> <pre><code>def run_and_summarize_opt(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Base function for Q-Chem recipes that involve ASE optimizers.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    calc_defaults\n        Default arguments for the Q-Chem calculator.\n    calc_swaps\n        Dictionary of custom kwargs for the Q-Chem calculator. Set a value to `quacc.Remove` to\n        remove a pre-existing key entirely. For a list of available keys, refer to the\n        `quacc.calculators.qchem.qchem.QChem` calculator.\n    opt_defaults\n        Default arguments for the ASE optimizer.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.Runner.run_opt][]\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][]\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    calc = QChem(\n        atoms, charge=charge, spin_multiplicity=spin_multiplicity, **calc_flags\n    )\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_opt(**opt_flags)\n\n    return Summarize(additional_fields=additional_fields).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html","title":"core","text":"<p>Core recipes for Q-Chem.</p>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.has_sella","title":"has_sella  <code>module-attribute</code>","text":"<pre><code>has_sella = bool(find_spec('sella'))\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Perform a frequency calculation on a molecular structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'wb97mv'</code> )           \u2013            <p>DFT exchange-correlation functional or other electronic structure method.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-svpd'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.    **calc_kwargs Custom kwargs for the calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See quacc.calculators.qchem.qchem.QChem for more details.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Perform a frequency calculation on a molecular structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method.\n    basis\n        Basis set.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.    **calc_kwargs\n        Custom kwargs for the calculator. Set a value to `quacc.Remove` to remove\n        a pre-existing key entirely. See [quacc.calculators.qchem.qchem.QChem][] for more\n        details.\n    additional_fields\n        Additional fields to add to the results dictionary.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][]\n    \"\"\"\n    calc_defaults = recursive_dict_merge(\n        _BASE_SET, {\"rem\": {\"job_type\": \"freq\", \"method\": method, \"basis\": basis}}\n    )\n\n    return run_and_summarize(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        copy_files=copy_files,\n        additional_fields={\"name\": \"Q-Chem Frequency\"} | (additional_fields or {}),\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Optimize aka \"relax\" a molecular structure with an ASE optimizer.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'wb97mv'</code> )           \u2013            <p>DFT exchange-correlation functional or other electronic structure method.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-svpd'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See quacc.calculators.qchem.qchem.QChem for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Optimize aka \"relax\" a molecular structure with an ASE optimizer.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method.\n    basis\n        Basis set.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the calculator. Set a value to `quacc.Remove` to remove\n        a pre-existing key entirely. See [quacc.calculators.qchem.qchem.QChem][] for more\n        details.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = recursive_dict_merge(\n        _BASE_SET, {\"rem\": {\"job_type\": \"force\", \"method\": method, \"basis\": basis}}\n    )\n    opt_defaults = {\"optimizer\": Sella} if has_sella else {}\n\n    return run_and_summarize_opt(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/core.html#quacc.recipes.qchem.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str | None = \"wb97mv\",\n    basis: str | None = \"def2-tzvpd\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Total charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str | None</code>, default:                   <code>'wb97mv'</code> )           \u2013            <p>DFT exchange-correlation functional or other electronic structure method.</p> </li> <li> <code>basis</code>               (<code>str | None</code>, default:                   <code>'def2-tzvpd'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See quacc.calculators.qchem.qchem.QChem for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/qchem/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str | None = \"wb97mv\",\n    basis: str | None = \"def2-tzvpd\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Total charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method.\n    basis\n        Basis set.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the calculator. Set a value to `quacc.Remove` to remove\n        a pre-existing key entirely. See [quacc.calculators.qchem.qchem.QChem][] for more\n        details.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = recursive_dict_merge(\n        _BASE_SET, {\"rem\": {\"job_type\": \"force\", \"method\": method, \"basis\": basis}}\n    )\n\n    return run_and_summarize(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Q-Chem Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html","title":"ts","text":"<p>Transition state recipes for Q-Chem.</p>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.has_sella","title":"has_sella  <code>module-attribute</code>","text":"<pre><code>has_sella = bool(find_spec('sella'))\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>IRC optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>Direction of the IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'wb97mv'</code> )           \u2013            <p>DFT exchange-correlation functional or other electronic structure method.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-svpd'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See quacc.calculators.qchem.qchem.QChem for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef irc_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    IRC optimize a molecular structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    direction\n        Direction of the IRC. Should be \"forward\" or \"reverse\".\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method.\n    basis\n        Basis set.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the calculator. Set a value to `quacc.Remove` to remove\n        a pre-existing key entirely. See [quacc.calculators.qchem.qchem.QChem][] for more\n        details.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][]\n    \"\"\"\n    from sella import IRC\n\n    calc_defaults = recursive_dict_merge(\n        _BASE_SET, {\"rem\": {\"job_type\": \"force\", \"method\": method, \"basis\": basis}}\n    )\n    opt_defaults = {\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\"keep_going\": True},\n        \"run_kwargs\": {\"direction\": direction},\n    }\n    if opt_params and opt_params.get(\"optimizer\", IRC) is not IRC:\n        raise ValueError(\"Only Sella's IRC should be used for IRC optimization.\")\n\n    return run_and_summarize_opt(\n        atoms,\n        charge,\n        spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem IRC\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(\n    atoms: Atoms,\n    mode: list[list[float]] | NDArray,\n    perturb_magnitude: float = 0.6,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Quasi-IRC to optimize a reaction endpoint from a transition-state with known vibrational frequency modes. Perturbs the structure of <code>atoms</code> by a finite amount (0.6 * the normalized mode magnitude) along the specified vibrational frequency mode (assumed to be the transition mode), and then performs a <code>relax_job</code> on the perturbed structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object.</p> </li> <li> <code>mode</code>               (<code>list[list[float]] | NDArray</code>)           \u2013            <p>Transition mode. This should be an Nx3 matrix, where N is the number of atoms in <code>atoms</code>.</p> </li> <li> <code>perturb_magnitude</code>               (<code>float</code>, default:                   <code>0.6</code> )           \u2013            <p>Factor to multiply the transition mode. Default is 0.6. In some cases, it may be advisable to increase this factor, perhaps to 1.0 or 1.1. Lowering it is not generally found to be helpful.</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>Direction of the (Quasi)IRC. Should be \"forward\" or \"reverse\".</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'wb97mv'</code> )           \u2013            <p>DFT exchange-correlation functional or other electronic structure method.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-svpd'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See quacc.calculators.qchem.qchem.QChem for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef quasi_irc_job(\n    atoms: Atoms,\n    mode: list[list[float]] | NDArray,\n    perturb_magnitude: float = 0.6,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Quasi-IRC to optimize a reaction endpoint from a transition-state with known vibrational frequency modes.\n    Perturbs the structure of `atoms` by a finite amount (0.6 * the normalized mode magnitude) along the specified\n    vibrational frequency mode (assumed to be the transition mode), and then performs a `relax_job` on the perturbed\n    structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object.\n    mode\n        Transition mode. This should be an Nx3 matrix, where N is the number of atoms in `atoms`.\n    perturb_magnitude\n        Factor to multiply the transition mode. Default is 0.6. In some cases, it may be advisable to increase this\n        factor, perhaps to 1.0 or 1.1. Lowering it is not generally found to be helpful.\n    direction\n        Direction of the (Quasi)IRC. Should be \"forward\" or \"reverse\".\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method.\n    basis\n        Basis set.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the calculator. Set a value to `quacc.Remove` to remove\n        a pre-existing key entirely. See [quacc.calculators.qchem.qchem.QChem][] for more\n        details.\n\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][]\n    \"\"\"\n    from sella import Sella\n\n    calc_defaults = recursive_dict_merge(\n        _BASE_SET, {\"rem\": {\"job_type\": \"force\", \"method\": method, \"basis\": basis}}\n    )\n    opt_defaults = {\"optimizer\": Sella} if has_sella else {}\n\n    scale = perturb_magnitude if direction == \"forward\" else perturb_magnitude * -1\n\n    return run_and_summarize_opt(\n        perturb(atoms, mode, scale),\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem Quasi-IRC\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/qchem/ts.html#quacc.recipes.qchem.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>TS optimize a molecular structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'wb97mv'</code> )           \u2013            <p>DFT exchange-correlation functional or other electronic structure method.</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2-svpd'</code> )           \u2013            <p>Basis set.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. See quacc.calculators.qchem.qchem.QChem for more details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/qchem/ts.py</code> <pre><code>@job\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef ts_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    method: str = \"wb97mv\",\n    basis: str = \"def2-svpd\",\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    TS optimize a molecular structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    method\n        DFT exchange-correlation functional or other electronic structure\n        method.\n    basis\n        Basis set.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the calculator. Set a value to `quacc.Remove` to remove\n        a pre-existing key entirely. See [quacc.calculators.qchem.qchem.QChem][] for more\n        details.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from sella import Sella\n\n    calc_defaults = recursive_dict_merge(\n        _BASE_SET, {\"rem\": {\"job_type\": \"force\", \"method\": method, \"basis\": basis}}\n    )\n    opt_defaults = {\"optimizer\": Sella, \"optimizer_kwargs\": {\"order\": 1}}\n\n    if opt_params and opt_params.get(\"optimizer\", Sella) is not Sella:\n        raise ValueError(\"Only Sella should be used for TS optimization.\")\n\n    return run_and_summarize_opt(\n        atoms,\n        charge,\n        spin_multiplicity,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"Q-Chem TS\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html","title":"core","text":"<p>Core recipes for the tblite code.</p>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.has_tblite","title":"has_tblite  <code>module-attribute</code>","text":"<pre><code>has_tblite = bool(find_spec('tblite'))\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms: Atoms,\n    method: Literal[\n        \"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"\n    ] = \"GFN2-xTB\",\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    vib_kwargs: VibKwargs | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VibThermoSchema\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                   <code>'GFN2-xTB'</code> )           \u2013            <p>xTB method to use</p> </li> <li> <code>energy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> <li> <code>vib_kwargs</code>               (<code>VibKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for quacc.runners.ase.Runner.run_vib.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the tblite calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>tblite.ase.TBLite</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(has_tblite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef freq_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    vib_kwargs: VibKwargs | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        xTB method to use\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    vib_kwargs\n        Dictionary of kwargs for [quacc.runners.ase.Runner.run_vib][].\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the tblite calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `tblite.ase.TBLite` calculator.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results\n    \"\"\"\n    from tblite.ase import TBLite\n\n    vib_kwargs = vib_kwargs or {}\n\n    calc_defaults = {\"method\": method}\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc = TBLite(**calc_flags)\n\n    vib = Runner(atoms, calc).run_vib(vib_kwargs=vib_kwargs)\n    return VibSummarize(\n        vib,\n        additional_fields={\"name\": \"TBLite Frequency and Thermo\"}\n        | (additional_fields or {}),\n    ).vib_and_thermo(\n        \"ideal_gas\", energy=energy, temperature=temperature, pressure=pressure\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    method: Literal[\n        \"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"\n    ] = \"GFN2-xTB\",\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; OptSchema\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                   <code>'GFN2-xTB'</code> )           \u2013            <p>xTB method to use</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the cell.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the tblite calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>tblite.ase.TBLite</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.opt. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(has_tblite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef relax_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; OptSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        xTB method to use\n    relax_cell\n        Whether to relax the cell.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the tblite calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `tblite.ase.TBLite` calculator.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.opt][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from tblite.ase import TBLite\n\n    opt_params = opt_params or {}\n    calc_defaults = {\"method\": method}\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc = TBLite(**calc_flags)\n    dyn = Runner(atoms, calc).run_opt(relax_cell=relax_cell, **opt_params)\n\n    return Summarize(\n        additional_fields={\"name\": \"TBLite Relax\"} | (additional_fields or {})\n    ).opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/core.html#quacc.recipes.tblite.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    method: Literal[\n        \"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"\n    ] = \"GFN2-xTB\",\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>method</code>               (<code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code>, default:                   <code>'GFN2-xTB'</code> )           \u2013            <p>xTB method to use</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the TBLite calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>tblite.ase.TBLite</code> calculator</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/tblite/core.py</code> <pre><code>@job\n@requires(has_tblite, \"tblite must be installed. Refer to the quacc documentation.\")\ndef static_job(\n    atoms: Atoms,\n    method: Literal[\"GFN1-xTB\", \"GFN2-xTB\", \"IPEA1-xTB\"] = \"GFN2-xTB\",\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    method\n        xTB method to use\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the TBLite calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `tblite.ase.TBLite` calculator\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from tblite.ase import TBLite\n\n    calc_defaults = {\"method\": method}\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc = TBLite(**calc_flags)\n\n    final_atoms = Runner(atoms, calc).run_calc()\n    return Summarize(\n        additional_fields={\"name\": \"TBLite Static\"} | (additional_fields or {})\n    ).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/phonons.html","title":"phonons","text":"<p>Phonon recipes for TBLite.</p>"},{"location":"reference/quacc/recipes/tblite/phonons.html#quacc.recipes.tblite.phonons.has_phonopy","title":"has_phonopy  <code>module-attribute</code>","text":"<pre><code>has_phonopy = bool(find_spec('phonopy'))\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/phonons.html#quacc.recipes.tblite.phonons.has_seekpath","title":"has_seekpath  <code>module-attribute</code>","text":"<pre><code>has_seekpath = bool(find_spec('seekpath'))\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/phonons.html#quacc.recipes.tblite.phonons.has_tblite","title":"has_tblite  <code>module-attribute</code>","text":"<pre><code>has_tblite = bool(find_spec('tblite'))\n</code></pre>"},{"location":"reference/quacc/recipes/tblite/phonons.html#quacc.recipes.tblite.phonons.phonon_flow","title":"phonon_flow","text":"<pre><code>phonon_flow(\n    atoms: Atoms,\n    symprec: float = 0.0001,\n    min_lengths: (\n        float | tuple[float, float, float] | None\n    ) = 20.0,\n    supercell_matrix: (\n        tuple[\n            tuple[int, int, int],\n            tuple[int, int, int],\n            tuple[int, int, int],\n        ]\n        | None\n    ) = None,\n    displacement: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; PhononSchema\n</code></pre> <p>Carry out a phonon workflow, consisting of:</p> <ol> <li> <p>Generation of supercells.</p> </li> <li> <p>Static calculations on supercells</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.tblite.core.static_job</li> </ul> </li> <li> <p>Calculation of thermodynamic properties.</p> </li> </ol> <p>Note</p> <p>Phonon calculations rely on a structure that is tightly converged. We suggest running a pre-relaxation with <code>opt_params: {\"fmax\": 1e-3}</code> or tighter before running this workflow.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>symprec</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Precision for symmetry detection.</p> </li> <li> <code>min_lengths</code>               (<code>float | tuple[float, float, float] | None</code>, default:                   <code>20.0</code> )           \u2013            <p>Minimum length of each lattice dimension (A).</p> </li> <li> <code>supercell_matrix</code>               (<code>tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The supercell matrix to use. If specified, it will override any value specified by <code>min_lengths</code>.</p> </li> <li> <code>displacement</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Atomic displacement (A).</p> </li> <li> <code>t_step</code>               (<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Temperature step (K).</p> </li> <li> <code>t_min</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Min temperature (K).</p> </li> <li> <code>t_max</code>               (<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>Max temperature (K).</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.phonons.summarize_phonopy. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/tblite/phonons.py</code> <pre><code>@flow\n@requires(has_tblite, \"tblite must be installed. Refer to the quacc documentation.\")\n@requires(\n    has_phonopy, message=\"Phonopy must be installed. Run `pip install quacc[phonons]`\"\n)\n@requires(\n    has_seekpath, message=\"Seekpath must be installed. Run `pip install quacc[phonons]`\"\n)\ndef phonon_flow(\n    atoms: Atoms,\n    symprec: float = 1e-4,\n    min_lengths: float | tuple[float, float, float] | None = 20.0,\n    supercell_matrix: (\n        tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]] | None\n    ) = None,\n    displacement: float = 0.01,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Carry out a phonon workflow, consisting of:\n\n    1. Generation of supercells.\n\n    2. Static calculations on supercells\n        - name: \"static_job\"\n        - job: [quacc.recipes.tblite.core.static_job][]\n\n    3. Calculation of thermodynamic properties.\n\n    !!! Note\n\n        Phonon calculations rely on a structure that is tightly converged.\n        We suggest running a pre-relaxation with `opt_params: {\"fmax\": 1e-3}`\n        or tighter before running this workflow.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    symprec\n        Precision for symmetry detection.\n    min_lengths\n        Minimum length of each lattice dimension (A).\n    supercell_matrix\n        The supercell matrix to use. If specified, it will override any\n        value specified by `min_lengths`.\n    displacement\n        Atomic displacement (A).\n    t_step\n        Temperature step (K).\n    t_min\n        Min temperature (K).\n    t_max\n        Max temperature (K).\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    PhononSchema\n        Dictionary of results from [quacc.schemas.phonons.summarize_phonopy][].\n        See the type-hint for the data structure.\n    \"\"\"\n    static_job_ = customize_funcs(\n        [\"static_job\"],\n        [static_job],\n        param_defaults=None,\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    return phonon_subflow(\n        atoms,\n        static_job_,\n        symprec=symprec,\n        min_lengths=min_lengths,\n        supercell_matrix=supercell_matrix,\n        displacement=displacement,\n        t_step=t_step,\n        t_min=t_min,\n        t_max=t_max,\n        additional_fields={\"name\": \"TBLite Phonons\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html","title":"_base","text":"<p>Utility functions for TorchSim recipes.</p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.has_torchsim","title":"has_torchsim  <code>module-attribute</code>","text":"<pre><code>has_torchsim = bool(find_spec('torch_sim'))\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails","title":"AutobatcherDetails","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.autobatcher","title":"autobatcher  <code>instance-attribute</code>","text":"<pre><code>autobatcher: Literal[\n    \"BinningAutoBatcher\", \"InFlightAutoBatcher\"\n]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.max_atoms_to_try","title":"max_atoms_to_try  <code>instance-attribute</code>","text":"<pre><code>max_atoms_to_try: int | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.max_iterations","title":"max_iterations  <code>instance-attribute</code>","text":"<pre><code>max_iterations: int | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.max_memory_padding","title":"max_memory_padding  <code>instance-attribute</code>","text":"<pre><code>max_memory_padding: float | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.max_memory_scaler","title":"max_memory_scaler  <code>instance-attribute</code>","text":"<pre><code>max_memory_scaler: float | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.memory_scales_with","title":"memory_scales_with  <code>instance-attribute</code>","text":"<pre><code>memory_scales_with: Literal['n_atoms', 'n_atoms_x_density']\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDetails.memory_scaling_factor","title":"memory_scaling_factor  <code>instance-attribute</code>","text":"<pre><code>memory_scaling_factor: float | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict","title":"AutobatcherDict","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict.max_atoms_to_try","title":"max_atoms_to_try  <code>instance-attribute</code>","text":"<pre><code>max_atoms_to_try: int | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict.max_iterations","title":"max_iterations  <code>instance-attribute</code>","text":"<pre><code>max_iterations: int | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict.max_memory_padding","title":"max_memory_padding  <code>instance-attribute</code>","text":"<pre><code>max_memory_padding: float | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict.max_memory_scaler","title":"max_memory_scaler  <code>instance-attribute</code>","text":"<pre><code>max_memory_scaler: float | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict.memory_scales_with","title":"memory_scales_with  <code>instance-attribute</code>","text":"<pre><code>memory_scales_with: (\n    Literal[\"n_atoms\", \"n_atoms_x_density\"] | None\n)\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.AutobatcherDict.memory_scaling_factor","title":"memory_scaling_factor  <code>instance-attribute</code>","text":"<pre><code>memory_scaling_factor: float | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.CalculationOutput","title":"CalculationOutput","text":"<p>               Bases: <code>TypedDict</code></p> <p>Schema for the output of a TorchSim calculation.</p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.CalculationOutput.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: list[float]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.CalculationOutput.forces","title":"forces  <code>instance-attribute</code>","text":"<pre><code>forces: list[list[list[float]]] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.CalculationOutput.stress","title":"stress  <code>instance-attribute</code>","text":"<pre><code>stress: list[list[list[float]]] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimIntegrateSchema","title":"TorchSimIntegrateSchema","text":"<p>               Bases: <code>TorchSimSchema</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimIntegrateSchema.integrator","title":"integrator  <code>instance-attribute</code>","text":"<pre><code>integrator: Integrator\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimIntegrateSchema.integrator_kwargs","title":"integrator_kwargs  <code>instance-attribute</code>","text":"<pre><code>integrator_kwargs: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimIntegrateSchema.n_steps","title":"n_steps  <code>instance-attribute</code>","text":"<pre><code>n_steps: int\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimIntegrateSchema.temperature","title":"temperature  <code>instance-attribute</code>","text":"<pre><code>temperature: float | list[float]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimIntegrateSchema.timestep","title":"timestep  <code>instance-attribute</code>","text":"<pre><code>timestep: float\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema","title":"TorchSimOptSchema","text":"<p>               Bases: <code>TorchSimSchema</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.convergence_fn","title":"convergence_fn  <code>instance-attribute</code>","text":"<pre><code>convergence_fn: Literal['energy', 'force']\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.convergence_fn_kwargs","title":"convergence_fn_kwargs  <code>instance-attribute</code>","text":"<pre><code>convergence_fn_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.init_kwargs","title":"init_kwargs  <code>instance-attribute</code>","text":"<pre><code>init_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.max_steps","title":"max_steps  <code>instance-attribute</code>","text":"<pre><code>max_steps: int\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.optimizer","title":"optimizer  <code>instance-attribute</code>","text":"<pre><code>optimizer: Optimizer\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.optimizer_kwargs","title":"optimizer_kwargs  <code>instance-attribute</code>","text":"<pre><code>optimizer_kwargs: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimOptSchema.steps_between_swaps","title":"steps_between_swaps  <code>instance-attribute</code>","text":"<pre><code>steps_between_swaps: int\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema","title":"TorchSimSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms: list[Atoms]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.autobatcher","title":"autobatcher  <code>instance-attribute</code>","text":"<pre><code>autobatcher: AutobatcherDetails | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.dir_name","title":"dir_name  <code>instance-attribute</code>","text":"<pre><code>dir_name: str\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.model_kwargs","title":"model_kwargs  <code>instance-attribute</code>","text":"<pre><code>model_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.model_path","title":"model_path  <code>instance-attribute</code>","text":"<pre><code>model_path: str | Path\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.model_type","title":"model_type  <code>instance-attribute</code>","text":"<pre><code>model_type: TSModelType\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.output","title":"output  <code>instance-attribute</code>","text":"<pre><code>output: CalculationOutput\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.quacc_version","title":"quacc_version  <code>instance-attribute</code>","text":"<pre><code>quacc_version: str\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimSchema.trajectory_reporter","title":"trajectory_reporter  <code>instance-attribute</code>","text":"<pre><code>trajectory_reporter: TrajectoryReporterDetails | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimStaticSchema","title":"TorchSimStaticSchema","text":"<p>               Bases: <code>TorchSimSchema</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TorchSimStaticSchema.all_properties","title":"all_properties  <code>instance-attribute</code>","text":"<pre><code>all_properties: list[dict[str, list]]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails","title":"TrajectoryReporterDetails","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails.filenames","title":"filenames  <code>instance-attribute</code>","text":"<pre><code>filenames: list[str | Path] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, str] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails.prop_calculators","title":"prop_calculators  <code>instance-attribute</code>","text":"<pre><code>prop_calculators: dict[int, list[PropertyFn]]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails.state_frequency","title":"state_frequency  <code>instance-attribute</code>","text":"<pre><code>state_frequency: int\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails.state_kwargs","title":"state_kwargs  <code>instance-attribute</code>","text":"<pre><code>state_kwargs: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDetails.trajectory_kwargs","title":"trajectory_kwargs  <code>instance-attribute</code>","text":"<pre><code>trajectory_kwargs: dict[str, Any]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict","title":"TrajectoryReporterDict","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict.filenames","title":"filenames  <code>instance-attribute</code>","text":"<pre><code>filenames: str | Path | list[str | Path]\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, str] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict.prop_calculators","title":"prop_calculators  <code>instance-attribute</code>","text":"<pre><code>prop_calculators: dict[int, list[PropertyFn]] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict.state_frequency","title":"state_frequency  <code>instance-attribute</code>","text":"<pre><code>state_frequency: int | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict.state_kwargs","title":"state_kwargs  <code>instance-attribute</code>","text":"<pre><code>state_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.TrajectoryReporterDict.trajectory_kwargs","title":"trajectory_kwargs  <code>instance-attribute</code>","text":"<pre><code>trajectory_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.get_calculation_output","title":"get_calculation_output","text":"<pre><code>get_calculation_output(\n    state: SimState,\n    model: ModelInterface,\n    autobatcher: (\n        BinningAutoBatcher | InFlightAutoBatcher | bool\n    ) = False,\n) -&gt; CalculationOutput\n</code></pre> <p>Run a static calculation and return the output.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>SimState</code>)           \u2013            <p>The simulation state to calculate properties for.</p> </li> <li> <code>model</code>               (<code>ModelInterface</code>)           \u2013            <p>The model to use for the calculation.</p> </li> <li> <code>autobatcher</code>               (<code>BinningAutoBatcher | InFlightAutoBatcher | bool</code>, default:                   <code>False</code> )           \u2013            <p>Optional autobatcher for batching calculations. If an InFlightAutoBatcher is passed, it will be converted to a BinningAutoBatcher.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CalculationOutput</code>           \u2013            <p>The calculation output containing energy, forces, and stress.</p> </li> </ul> Source code in <code>quacc/recipes/torchsim/_base.py</code> <pre><code>@requires(has_torchsim, \"torch_sim is required for this function\")\ndef get_calculation_output(\n    state: ts.SimState,\n    model: ModelInterface,\n    autobatcher: BinningAutoBatcher | InFlightAutoBatcher | bool = False,\n) -&gt; CalculationOutput:\n    \"\"\"Run a static calculation and return the output.\n\n    Parameters\n    ----------\n    state : ts.SimState\n        The simulation state to calculate properties for.\n    model : ModelInterface\n        The model to use for the calculation.\n    autobatcher : BinningAutoBatcher | InFlightAutoBatcher | bool\n        Optional autobatcher for batching calculations. If an InFlightAutoBatcher\n        is passed, it will be converted to a BinningAutoBatcher.\n\n    Returns\n    -------\n    CalculationOutput\n        The calculation output containing energy, forces, and stress.\n    \"\"\"\n    # Convert InFlightAutoBatcher to BinningAutoBatcher for ts.static\n    if isinstance(autobatcher, InFlightAutoBatcher):\n        autobatcher = BinningAutoBatcher(\n            model=model,\n            memory_scales_with=autobatcher.memory_scales_with,\n            max_memory_scaler=autobatcher.max_memory_scaler,\n        )\n\n    properties = ts.static(system=state, model=model, autobatcher=autobatcher)\n\n    all_properties_lists = [\n        {name: t.tolist() for name, t in prop_dict.items()} for prop_dict in properties\n    ]\n    return properties_to_calculation_output(all_properties_lists)\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.pick_model","title":"pick_model","text":"<pre><code>pick_model(\n    model_type: TSModelType,\n    model: str | Path,\n    **model_kwargs: Any\n) -&gt; ModelInterface\n</code></pre> <p>Pick and instantiate a model based on the model type.</p> <p>Parameters:</p> <ul> <li> <code>model_type</code>               (<code>TSModelType</code>)           \u2013            <p>The type of model to instantiate.</p> </li> <li> <code>model</code>               (<code>str | Path</code>)           \u2013            <p>Path to the model file or checkpoint. For some models, string names may be allowed, such as \"uma-s-1\" for FairChemModel.</p> </li> <li> <code>**model_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the model constructor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModelInterface</code>           \u2013            <p>The instantiated model.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid model type is provided.</p> </li> </ul> Source code in <code>quacc/recipes/torchsim/_base.py</code> <pre><code>@requires(has_torchsim, \"torch_sim is required for this function\")\ndef pick_model(\n    model_type: TSModelType, model: str | Path, **model_kwargs: Any\n) -&gt; ModelInterface:\n    \"\"\"Pick and instantiate a model based on the model type.\n\n    Parameters\n    ----------\n    model_type : TSModelType\n        The type of model to instantiate.\n    model : str | Path\n        Path to the model file or checkpoint. For some models, string names may\n        be allowed, such as \"uma-s-1\" for FairChemModel.\n    **model_kwargs : Any\n        Additional keyword arguments to pass to the model constructor.\n\n    Returns\n    -------\n    ModelInterface\n        The instantiated model.\n\n    Raises\n    ------\n    ValueError\n        If an invalid model type is provided.\n    \"\"\"\n    if model_type == TSModelType.FAIRCHEMV1:\n        from torch_sim.models.fairchem_legacy import FairChemV1Model\n\n        return FairChemV1Model(model=model, **model_kwargs)\n    if model_type == TSModelType.FAIRCHEM:\n        from torch_sim.models.fairchem import FairChemModel\n\n        return FairChemModel(model=model, **model_kwargs)\n    if model_type == TSModelType.GRAPHPESWRAPPER:\n        from torch_sim.models.graphpes import GraphPESWrapper\n\n        return GraphPESWrapper(model=model, **model_kwargs)\n    if model_type == TSModelType.MACE:\n        from torch_sim.models.mace import MaceModel\n\n        return MaceModel(model=model, **model_kwargs)\n    if model_type == TSModelType.MATTERSIM:\n        from torch_sim.models.mattersim import MatterSimModel\n\n        return MatterSimModel(model=model, **model_kwargs)\n    if model_type == TSModelType.METATOMIC:\n        from torch_sim.models.metatomic import MetatomicModel\n\n        return MetatomicModel(model=model, **model_kwargs)\n    if model_type == TSModelType.NEQUIPFRAMEWORK:\n        from torch_sim.models.nequip_framework import NequIPFrameworkModel\n\n        return NequIPFrameworkModel(model=model, **model_kwargs)\n    if model_type == TSModelType.ORB:\n        from torch_sim.models.orb import OrbModel\n\n        return OrbModel(model=model, **model_kwargs)\n    if model_type == TSModelType.SEVENNET:\n        from torch_sim.models.sevennet import SevenNetModel\n\n        return SevenNetModel(model=model, **model_kwargs)\n    if model_type == TSModelType.LENNARD_JONES:\n        from torch_sim.models.lennard_jones import LennardJonesModel\n\n        return LennardJonesModel(**model_kwargs)\n    raise ValueError(f\"Invalid model type: {model_type}\")\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.process_binning_autobatcher_dict","title":"process_binning_autobatcher_dict","text":"<pre><code>process_binning_autobatcher_dict(\n    atoms: list[Atoms],\n    model: ModelInterface,\n    autobatcher_dict: AutobatcherDict | bool,\n) -&gt; tuple[\n    BinningAutoBatcher | bool, AutobatcherDetails | None\n]\n</code></pre> <p>Process the input dict into a BinningAutoBatcher and details dictionary.</p> Source code in <code>quacc/recipes/torchsim/_base.py</code> <pre><code>@requires(has_torchsim, \"torch_sim is required for this function\")\ndef process_binning_autobatcher_dict(\n    atoms: list[Atoms], model: ModelInterface, autobatcher_dict: AutobatcherDict | bool\n) -&gt; tuple[BinningAutoBatcher | bool, AutobatcherDetails | None]:\n    \"\"\"Process the input dict into a BinningAutoBatcher and details dictionary.\"\"\"\n    if isinstance(autobatcher_dict, bool):\n        # otherwise, configure the autobatcher, with the private runners method\n        state = ts.initialize_state(atoms, model.device, model.dtype)\n        autobatcher = ts.runners._configure_batches_iterator(\n            state, model, autobatcher=autobatcher_dict\n        )\n        # list means no autobatcher\n        if isinstance(autobatcher, list):\n            return False, None\n    else:\n        # pop max_iterations if present\n        autobatcher_dict.pop(\"max_iterations\", None)\n        autobatcher = BinningAutoBatcher(model=model, **autobatcher_dict)\n\n    autobatcher_details = _get_autobatcher_details(autobatcher)\n    return autobatcher, autobatcher_details\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.process_in_flight_autobatcher_dict","title":"process_in_flight_autobatcher_dict","text":"<pre><code>process_in_flight_autobatcher_dict(\n    atoms: list[Atoms],\n    model: ModelInterface,\n    autobatcher_dict: AutobatcherDict | bool,\n    max_iterations: int,\n) -&gt; tuple[\n    InFlightAutoBatcher | bool, AutobatcherDetails | None\n]\n</code></pre> <p>Process the input dict into a InFlightAutoBatcher and details dictionary.</p> Source code in <code>quacc/recipes/torchsim/_base.py</code> <pre><code>@requires(has_torchsim, \"torch_sim is required for this function\")\ndef process_in_flight_autobatcher_dict(\n    atoms: list[Atoms],\n    model: ModelInterface,\n    autobatcher_dict: AutobatcherDict | bool,\n    max_iterations: int,\n) -&gt; tuple[InFlightAutoBatcher | bool, AutobatcherDetails | None]:\n    \"\"\"Process the input dict into a InFlightAutoBatcher and details dictionary.\"\"\"\n    if isinstance(autobatcher_dict, bool):\n        state = ts.initialize_state(atoms, model.device, model.dtype)\n        # False means no autobatcher\n        if not autobatcher_dict:\n            return False, None\n        # otherwise, configure the autobatcher, with the private runners method\n        autobatcher = ts.runners._configure_in_flight_autobatcher(\n            state, model, autobatcher=autobatcher_dict, max_iterations=max_iterations\n        )\n    else:\n        autobatcher = InFlightAutoBatcher(model=model, **autobatcher_dict)\n\n    autobatcher_details = _get_autobatcher_details(autobatcher)\n    return autobatcher, autobatcher_details\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.process_trajectory_reporter_dict","title":"process_trajectory_reporter_dict","text":"<pre><code>process_trajectory_reporter_dict(\n    trajectory_reporter_dict: TrajectoryReporterDict | None,\n    runner: BaseRunner,\n    n_systems: int,\n) -&gt; tuple[TrajectoryReporter, TrajectoryReporterDetails]\n</code></pre> <p>Process the input dict into a TrajectoryReporter and details dictionary.</p> Source code in <code>quacc/recipes/torchsim/_base.py</code> <pre><code>@requires(has_torchsim, \"torch_sim is required for this function\")\ndef process_trajectory_reporter_dict(\n    trajectory_reporter_dict: TrajectoryReporterDict | None,\n    runner: BaseRunner,\n    n_systems: int,\n) -&gt; tuple[TrajectoryReporter, TrajectoryReporterDetails]:\n    \"\"\"Process the input dict into a TrajectoryReporter and details dictionary.\"\"\"\n    trajectory_reporter_dict = trajectory_reporter_dict or {}\n    trajectory_reporter_dict = deepcopy(trajectory_reporter_dict)\n    if \"filenames\" not in trajectory_reporter_dict:\n        trajectory_reporter_dict[\"filenames\"] = [\n            runner.tmpdir / f\"trajectory_{i}.h5md\" for i in range(n_systems)\n        ]\n    else:\n        trajectory_reporter_dict[\"filenames\"] = [\n            runner.tmpdir / filename\n            for filename in trajectory_reporter_dict[\"filenames\"]\n        ]\n    prop_calculators = trajectory_reporter_dict.pop(\"prop_calculators\", {})\n    prop_calculators_functions = {\n        i: {prop: PROPERTY_FN_REGISTRY[prop] for prop in props}\n        for i, props in prop_calculators.items()\n    }\n\n    # TODO: put in optional dependencies\n    trajectory_reporter = ts.TrajectoryReporter(\n        **trajectory_reporter_dict, prop_calculators=prop_calculators_functions\n    )\n\n    reporter_details = {\n        \"state_frequency\": trajectory_reporter.state_frequency,\n        \"trajectory_kwargs\": trajectory_reporter.trajectory_kwargs,\n        \"prop_calculators\": prop_calculators,\n        \"state_kwargs\": trajectory_reporter.state_kwargs,\n        \"metadata\": trajectory_reporter.metadata,\n        \"filenames\": trajectory_reporter.filenames,\n    }\n    return trajectory_reporter, reporter_details\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/_base.html#quacc.recipes.torchsim._base.properties_to_calculation_output","title":"properties_to_calculation_output","text":"<pre><code>properties_to_calculation_output(\n    all_properties_lists: list[dict[str, list]],\n) -&gt; CalculationOutput\n</code></pre> <p>Convert properties from ts.static to a CalculationOutput.</p> <p>Parameters:</p> <ul> <li> <code>all_properties_lists</code>               (<code>list[dict[str, list]]</code>)           \u2013            <p>List of property dictionaries from ts.static, with tensors converted to lists.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CalculationOutput</code>           \u2013            <p>The calculation output containing energy, forces, and stress.</p> </li> </ul> Source code in <code>quacc/recipes/torchsim/_base.py</code> <pre><code>def properties_to_calculation_output(\n    all_properties_lists: list[dict[str, list]],\n) -&gt; CalculationOutput:\n    \"\"\"Convert properties from ts.static to a CalculationOutput.\n\n    Parameters\n    ----------\n    all_properties_lists : list[dict[str, list]]\n        List of property dictionaries from ts.static, with tensors converted to lists.\n\n    Returns\n    -------\n    CalculationOutput\n        The calculation output containing energy, forces, and stress.\n    \"\"\"\n    energy = [prop_dict[\"potential_energy\"][0] for prop_dict in all_properties_lists]\n    forces = (\n        [prop_dict[\"forces\"] for prop_dict in all_properties_lists]\n        if \"forces\" in all_properties_lists[-1]\n        else None\n    )\n    stress = (\n        [prop_dict[\"stress\"][0] for prop_dict in all_properties_lists]\n        if \"stress\" in all_properties_lists[-1]\n        else None\n    )\n    return {\"energy\": energy, \"forces\": forces, \"stress\": stress}\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/core.html","title":"core","text":"<p>Core recipes for TorchSim.</p>"},{"location":"reference/quacc/recipes/torchsim/core.html#quacc.recipes.torchsim.core.has_torchsim","title":"has_torchsim  <code>module-attribute</code>","text":"<pre><code>has_torchsim = bool(find_spec('torch_sim'))\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/core.html#quacc.recipes.torchsim.core.md_job","title":"md_job","text":"<pre><code>md_job(\n    atoms: list[Atoms],\n    model_type: TSModelType,\n    model_path: str | Path,\n    integrator: Integrator,\n    *,\n    n_steps: int,\n    temperature: float | list,\n    timestep: float,\n    trajectory_reporter_dict: (\n        TrajectoryReporterDict | None\n    ) = None,\n    autobatcher_dict: AutobatcherDict | bool = False,\n    model_kwargs: dict[str, Any] | None = None,\n    **integrator_kwargs: Any\n) -&gt; TorchSimIntegrateSchema\n</code></pre> <p>Carry out a molecular dynamics calculation on a set of atoms.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>list[Atoms]</code>)           \u2013            <p>The list of atoms objects.</p> </li> <li> <code>model_type</code>               (<code>TSModelType</code>)           \u2013            <p>The type of model to use, limited to the types supported by TorchSim.</p> </li> <li> <code>model_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the model file or checkpoint.</p> </li> <li> <code>integrator</code>               (<code>Integrator</code>)           \u2013            <p>The TorchSim integrator to use.</p> </li> <li> <code>n_steps</code>               (<code>int</code>)           \u2013            <p>The maximum number of steps to run for each integration.</p> </li> <li> <code>temperature</code>               (<code>float | list</code>)           \u2013            <p>The temperature to use.</p> </li> <li> <code>timestep</code>               (<code>float</code>)           \u2013            <p>The timestep to use.</p> </li> <li> <code>trajectory_reporter_dict</code>               (<code>TrajectoryReporterDict | None</code>, default:                   <code>None</code> )           \u2013            <p>This dictionary defines the trajectory reporting behavior. This is a quacc-specific dictionary that allows for the configuration of the TrajectoryReporter. For a list of available keys, refer to the TorchSim TrajectoryReporter documentation or the TrajectoryReporterDict type-hint.</p> </li> <li> <code>autobatcher_dict</code>               (<code>AutobatcherDict | bool</code>, default:                   <code>False</code> )           \u2013            <p>This dictionary defines the autobatcher behavior. This is a quacc-specific dictionary that allows for the configuration of the autobatcher. For a list of available keys, refer to the TorchSim Autobatcher's documentation or the AutobatcherDict type-hint.</p> </li> <li> <code>model_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments passed to the model.</p> </li> <li> <code>**integrator_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the integrator step function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TorchSimIntegrateSchema</code>           \u2013            <p>A dictionary representing the final atoms configuration and metadata for the molecular dynamics schema. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/torchsim/core.py</code> <pre><code>@job\n@requires(has_torchsim, \"torch_sim is required for this function\")\ndef md_job(\n    atoms: list[Atoms],\n    model_type: TSModelType,\n    model_path: str | Path,\n    integrator: Integrator,\n    *,\n    n_steps: int,\n    temperature: float | list,\n    timestep: float,\n    trajectory_reporter_dict: TrajectoryReporterDict | None = None,\n    autobatcher_dict: AutobatcherDict | bool = False,\n    model_kwargs: dict[str, Any] | None = None,\n    **integrator_kwargs: Any,\n) -&gt; TorchSimIntegrateSchema:\n    \"\"\"\n    Carry out a molecular dynamics calculation on a set of atoms.\n\n    Parameters\n    ----------\n    atoms : list[Atoms]\n        The list of atoms objects.\n    model_type : TSModelType\n        The type of model to use, limited to the types supported by TorchSim.\n    model_path : str | Path\n        The path to the model file or checkpoint.\n    integrator : Integrator\n        The TorchSim integrator to use.\n    n_steps : int\n        The maximum number of steps to run for each integration.\n    temperature : float | list\n        The temperature to use.\n    timestep : float\n        The timestep to use.\n    trajectory_reporter_dict : TrajectoryReporterDict | None\n        This dictionary defines the trajectory reporting behavior. This is a\n        quacc-specific dictionary that allows for the configuration of the\n        TrajectoryReporter. For a list of available keys, refer to the TorchSim\n        TrajectoryReporter documentation or the TrajectoryReporterDict type-hint.\n    autobatcher_dict : AutobatcherDict | bool\n        This dictionary defines the autobatcher behavior. This is a quacc-specific\n        dictionary that allows for the configuration of the autobatcher. For a list of\n        available keys, refer to the TorchSim Autobatcher's documentation or the\n        AutobatcherDict type-hint.\n    model_kwargs : dict[str, Any] | None\n        Keyword arguments passed to the model.\n    **integrator_kwargs : Any\n        Keyword arguments to pass to the integrator step function.\n\n    Returns\n    -------\n    TorchSimIntegrateSchema\n        A dictionary representing the final atoms configuration and metadata for the\n        molecular dynamics schema. See the type-hint for the data structure.\n    \"\"\"\n    runner = BaseRunner()\n    runner.setup()\n\n    model = pick_model(model_type, model_path, **model_kwargs or {})\n\n    # Configure trajectory reporter\n    trajectory_reporter, trajectory_reporter_details = process_trajectory_reporter_dict(\n        trajectory_reporter_dict, runner, n_systems=len(atoms)\n    )\n\n    # Configure autobatcher\n    autobatcher, autobatcher_details = process_binning_autobatcher_dict(\n        atoms, model, autobatcher_dict=autobatcher_dict\n    )\n\n    state = ts.integrate(\n        system=atoms,\n        model=model,\n        integrator=integrator,\n        n_steps=n_steps,\n        temperature=temperature,\n        timestep=timestep,\n        trajectory_reporter=trajectory_reporter,\n        autobatcher=autobatcher,\n        **integrator_kwargs,\n    )\n\n    # Get final calculation output\n    calculation_output = get_calculation_output(state, model, autobatcher)\n\n    runner.cleanup()\n\n    return {\n        \"atoms\": state.to_atoms(),\n        \"dir_name\": str(runner.job_results_dir),\n        \"output\": calculation_output,\n        \"model_type\": model_type,\n        \"model_path\": model_path,\n        \"integrator\": integrator,\n        \"n_steps\": n_steps,\n        \"temperature\": temperature,\n        \"timestep\": timestep,\n        \"trajectory_reporter\": trajectory_reporter_details,\n        \"autobatcher\": autobatcher_details,\n        \"model_kwargs\": model_kwargs,\n        \"integrator_kwargs\": integrator_kwargs,\n        \"quacc_version\": __version__,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/core.html#quacc.recipes.torchsim.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: list[Atoms],\n    model_type: TSModelType,\n    model_path: str | Path,\n    optimizer: Optimizer,\n    *,\n    convergence_fn: Literal[\"energy\", \"force\"] = \"force\",\n    trajectory_reporter_dict: (\n        TrajectoryReporterDict | None\n    ) = None,\n    autobatcher_dict: AutobatcherDict | bool = False,\n    max_steps: int = 10000,\n    steps_between_swaps: int = 5,\n    init_kwargs: dict[str, Any] | None = None,\n    model_kwargs: dict[str, Any] | None = None,\n    convergence_fn_kwargs: dict[str, Any] | None = None,\n    **optimizer_kwargs: Any\n) -&gt; TorchSimOptSchema\n</code></pre> <p>Carry out a geometry optimization on a set of atoms.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>list[Atoms]</code>)           \u2013            <p>The list of atoms objects.</p> </li> <li> <code>model_type</code>               (<code>TSModelType</code>)           \u2013            <p>The type of model to use, limited to the types supported by TorchSim.</p> </li> <li> <code>model_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the model file or checkpoint.</p> </li> <li> <code>optimizer</code>               (<code>Optimizer</code>)           \u2013            <p>The TorchSim optimizer to use.</p> </li> <li> <code>convergence_fn</code>               (<code>Literal['energy', 'force']</code>, default:                   <code>'force'</code> )           \u2013            <p>The convergence function, either \"energy\" or \"force\". This will use either the ts.generate_energy_convergence_fn or ts.generate_force_convergence_fn function to interally generate the convergence function. Arguments can be supplied via the convergence_fn_kwargs argument. Used to select convergence function generators from quacc.schemas.torchsim.CONVERGENCE_FN_REGISTRY.</p> </li> <li> <code>trajectory_reporter_dict</code>               (<code>TrajectoryReporterDict | None</code>, default:                   <code>None</code> )           \u2013            <p>This dictionary defines the trajectory reporting behavior. This is a quacc-specific dictionary that allows for the configuration of the TrajectoryReporter. For a list of available keys, refer to the TorchSim TrajectoryReporter documentation or the TrajectoryReporterDict type-hint.</p> </li> <li> <code>autobatcher_dict</code>               (<code>AutobatcherDict | bool</code>, default:                   <code>False</code> )           \u2013            <p>This dictionary defines the autobatcher behavior. This is a quacc-specific dictionary that allows for the configuration of the autobatcher. For a list of available keys, refer to the TorchSim Autobatcher's documentation or the AutobatcherDict type-hint.</p> </li> <li> <code>max_steps</code>               (<code>int</code>, default:                   <code>10000</code> )           \u2013            <p>The maximum number of steps to run for each optimization.</p> </li> <li> <code>steps_between_swaps</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of steps to take before checking convergence and swapping out states.</p> </li> <li> <code>init_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments passed to the optimizer initialization function.</p> </li> <li> <code>model_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments passed to the model.</p> </li> <li> <code>convergence_fn_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments passed to the convergence function generator.</p> </li> <li> <code>**optimizer_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the optimizer step function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TorchSimOptSchema</code>           \u2013            <p>A dictionary representing the final atoms configuration and metadata geometry optimization schema. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/torchsim/core.py</code> <pre><code>@job\n@requires(has_torchsim, \"torch_sim is required for this function\")\ndef relax_job(\n    atoms: list[Atoms],\n    model_type: TSModelType,\n    model_path: str | Path,\n    optimizer: Optimizer,\n    *,\n    convergence_fn: Literal[\"energy\", \"force\"] = \"force\",\n    trajectory_reporter_dict: TrajectoryReporterDict | None = None,\n    autobatcher_dict: AutobatcherDict | bool = False,\n    max_steps: int = 10_000,\n    steps_between_swaps: int = 5,\n    init_kwargs: dict[str, Any] | None = None,\n    model_kwargs: dict[str, Any] | None = None,\n    convergence_fn_kwargs: dict[str, Any] | None = None,\n    **optimizer_kwargs: Any,\n) -&gt; TorchSimOptSchema:\n    \"\"\"\n    Carry out a geometry optimization on a set of atoms.\n\n    Parameters\n    ----------\n    atoms : list[Atoms]\n        The list of atoms objects.\n    model_type : TSModelType\n        The type of model to use, limited to the types supported by TorchSim.\n    model_path : str | Path\n        The path to the model file or checkpoint.\n    optimizer : Optimizer\n        The TorchSim optimizer to use.\n    convergence_fn : Literal[\"energy\", \"force\"]\n        The convergence function, either \"energy\" or \"force\". This will use either the\n        ts.generate_energy_convergence_fn or ts.generate_force_convergence_fn function\n        to interally generate the convergence function. Arguments can be supplied via\n        the convergence_fn_kwargs argument. Used to select convergence function\n        generators from quacc.schemas.torchsim.CONVERGENCE_FN_REGISTRY.\n    trajectory_reporter_dict : TrajectoryReporterDict | None\n        This dictionary defines the trajectory reporting behavior. This is a\n        quacc-specific dictionary that allows for the configuration of the\n        TrajectoryReporter. For a list of available keys, refer to the TorchSim\n        TrajectoryReporter documentation or the TrajectoryReporterDict type-hint.\n    autobatcher_dict : AutobatcherDict | bool\n        This dictionary defines the autobatcher behavior. This is a quacc-specific\n        dictionary that allows for the configuration of the autobatcher. For a list of\n        available keys, refer to the TorchSim Autobatcher's documentation or the\n        AutobatcherDict type-hint.\n    max_steps : int\n        The maximum number of steps to run for each optimization.\n    steps_between_swaps : int\n        Number of steps to take before checking convergence and swapping out states.\n    init_kwargs : dict[str, Any] | None\n        Keyword arguments passed to the optimizer initialization function.\n    model_kwargs : dict[str, Any] | None\n        Keyword arguments passed to the model.\n    convergence_fn_kwargs : dict[str, Any] | None\n        Keyword arguments passed to the convergence function generator.\n    **optimizer_kwargs : Any\n        Keyword arguments to pass to the optimizer step function.\n\n    Returns\n    -------\n    TorchSimOptSchema\n        A dictionary representing the final atoms configuration and metadata geometry\n        optimization schema. See the type-hint for the data structure.\n    \"\"\"\n    runner = BaseRunner()\n    runner.setup()\n\n    model = pick_model(model_type, model_path, **model_kwargs or {})\n\n    trajectory_reporter, trajectory_reporter_details = process_trajectory_reporter_dict(\n        trajectory_reporter_dict, runner, n_systems=len(atoms)\n    )\n\n    max_iterations = max_steps // steps_between_swaps\n    autobatcher, autobatcher_details = process_in_flight_autobatcher_dict(\n        atoms, model, autobatcher_dict=autobatcher_dict, max_iterations=max_iterations\n    )\n\n    convergence_fn_obj = CONVERGENCE_FN_REGISTRY[convergence_fn](\n        **convergence_fn_kwargs or {}\n    )\n\n    state = ts.optimize(\n        system=atoms,\n        model=model,\n        optimizer=optimizer,\n        convergence_fn=convergence_fn_obj,\n        trajectory_reporter=trajectory_reporter,\n        autobatcher=autobatcher,\n        max_steps=max_steps,\n        steps_between_swaps=steps_between_swaps,\n        init_kwargs=init_kwargs,\n        **optimizer_kwargs,\n    )\n\n    # Get final calculation output\n    calculation_output = get_calculation_output(state, model, autobatcher)\n\n    runner.cleanup()\n\n    return {\n        \"atoms\": state.to_atoms(),\n        \"dir_name\": str(runner.job_results_dir),\n        \"output\": calculation_output,\n        \"model_type\": model_type,\n        \"model_path\": model_path,\n        \"optimizer\": optimizer,\n        \"convergence_fn\": convergence_fn,\n        \"trajectory_reporter\": trajectory_reporter_details,\n        \"autobatcher\": autobatcher_details,\n        \"max_steps\": max_steps,\n        \"steps_between_swaps\": steps_between_swaps,\n        \"init_kwargs\": init_kwargs,\n        \"model_kwargs\": model_kwargs,\n        \"convergence_fn_kwargs\": convergence_fn_kwargs,\n        \"optimizer_kwargs\": optimizer_kwargs,\n        \"quacc_version\": __version__,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/torchsim/core.html#quacc.recipes.torchsim.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: list[Atoms],\n    model_type: TSModelType,\n    model_path: str | Path,\n    *,\n    trajectory_reporter_dict: (\n        TrajectoryReporterDict | None\n    ) = None,\n    autobatcher_dict: AutobatcherDict | bool = False,\n    model_kwargs: dict[str, Any] | None = None\n) -&gt; TorchSimStaticSchema\n</code></pre> <p>Carry out a static calculation on a set of atoms.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>list[Atoms]</code>)           \u2013            <p>The list of atoms objects.</p> </li> <li> <code>model_type</code>               (<code>TSModelType</code>)           \u2013            <p>The type of model to use, limited to the types supported by TorchSim.</p> </li> <li> <code>model_path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the model file or checkpoint.</p> </li> <li> <code>trajectory_reporter_dict</code>               (<code>TrajectoryReporterDict | None</code>, default:                   <code>None</code> )           \u2013            <p>This dictionary defines the trajectory reporting behavior. This is a quacc-specific dictionary that allows for the configuration of the TrajectoryReporter. For a list of available keys, refer to the TorchSim TrajectoryReporter documentation or the TrajectoryReporterDict type-hint.</p> </li> <li> <code>autobatcher_dict</code>               (<code>AutobatcherDict | bool</code>, default:                   <code>False</code> )           \u2013            <p>This dictionary defines the autobatcher behavior. This is a quacc-specific dictionary that allows for the configuration of the autobatcher. For a list of available keys, refer to the TorchSim Autobatcher's documentation or the AutobatcherDict type-hint.</p> </li> <li> <code>model_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments passed to the model.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TorchSimStaticSchema</code>           \u2013            <p>A dictionary representing the final atoms configuration and metadata for the static calculation schema. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/torchsim/core.py</code> <pre><code>@job\n@requires(has_torchsim, \"torch_sim is required for this function\")\ndef static_job(\n    atoms: list[Atoms],\n    model_type: TSModelType,\n    model_path: str | Path,\n    *,\n    trajectory_reporter_dict: TrajectoryReporterDict | None = None,\n    autobatcher_dict: AutobatcherDict | bool = False,\n    model_kwargs: dict[str, Any] | None = None,\n) -&gt; TorchSimStaticSchema:\n    \"\"\"\n    Carry out a static calculation on a set of atoms.\n\n    Parameters\n    ----------\n    atoms : list[Atoms]\n        The list of atoms objects.\n    model_type : TSModelType\n        The type of model to use, limited to the types supported by TorchSim.\n    model_path : str | Path\n        The path to the model file or checkpoint.\n    trajectory_reporter_dict : TrajectoryReporterDict | None\n        This dictionary defines the trajectory reporting behavior. This is a\n        quacc-specific dictionary that allows for the configuration of the\n        TrajectoryReporter. For a list of available keys, refer to the TorchSim\n        TrajectoryReporter documentation or the TrajectoryReporterDict type-hint.\n    autobatcher_dict : AutobatcherDict | bool\n        This dictionary defines the autobatcher behavior. This is a quacc-specific\n        dictionary that allows for the configuration of the autobatcher. For a list of\n        available keys, refer to the TorchSim Autobatcher's documentation or the\n        AutobatcherDict type-hint.\n    model_kwargs : dict[str, Any] | None\n        Keyword arguments passed to the model.\n\n    Returns\n    -------\n    TorchSimStaticSchema\n        A dictionary representing the final atoms configuration and metadata for the\n        static calculation schema. See the type-hint for the data structure.\n    \"\"\"\n    runner = BaseRunner()\n    runner.setup()\n\n    model = pick_model(model_type, model_path, **model_kwargs or {})\n\n    trajectory_reporter, trajectory_reporter_details = process_trajectory_reporter_dict(\n        trajectory_reporter_dict, runner, n_systems=len(atoms)\n    )\n\n    autobatcher, autobatcher_details = process_binning_autobatcher_dict(\n        atoms, model, autobatcher_dict=autobatcher_dict\n    )\n\n    all_properties = ts.static(\n        system=atoms,\n        model=model,\n        trajectory_reporter=trajectory_reporter,\n        autobatcher=autobatcher,\n    )\n\n    all_properties_lists = [\n        {name: t.tolist() for name, t in prop_dict.items()}\n        for prop_dict in all_properties\n    ]\n\n    # Extract calculation output from properties\n    calculation_output = properties_to_calculation_output(all_properties_lists)\n\n    runner.cleanup()\n\n    return {\n        \"atoms\": atoms,\n        \"dir_name\": str(runner.job_results_dir),\n        \"output\": calculation_output,\n        \"all_properties\": all_properties_lists,\n        \"model_type\": model_type,\n        \"model_path\": model_path,\n        \"trajectory_reporter\": trajectory_reporter_details,\n        \"autobatcher\": autobatcher_details,\n        \"model_kwargs\": model_kwargs,\n        \"quacc_version\": __version__,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/_base.html","title":"_base","text":"<p>Core recipes for VASP.</p>"},{"location":"reference/quacc/recipes/vasp/_base.html#quacc.recipes.vasp._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(\n    atoms: Atoms,\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    report_mp_corrections: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; VaspSchema\n</code></pre> <p>Base job function for VASP recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default parameters for the recipe.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> <li> <code>report_mp_corrections</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to report the Materials Project corrections in the results.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    report_mp_corrections: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; VaspSchema:\n    \"\"\"\n    Base job function for VASP recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    calc_defaults\n        Default parameters for the recipe.\n    calc_swaps\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n    report_mp_corrections\n        Whether to report the Materials Project corrections in the results.\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    calc = Vasp(atoms, preset=preset, **calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return VaspSummarize(\n        report_mp_corrections=report_mp_corrections, additional_fields=additional_fields\n    ).run(final_atoms)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/_base.html#quacc.recipes.vasp._base.run_and_summarize_opt","title":"run_and_summarize_opt","text":"<pre><code>run_and_summarize_opt(\n    atoms: Atoms,\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    report_mp_corrections: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | None = None,\n) -&gt; VaspASEOptSchema\n</code></pre> <p>Base job function for VASP recipes with ASE optimizers.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default parameters for the recipe.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> <li> <code>opt_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default arguments for the ASE optimizer.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for quacc.runners.ase.Runner.run_opt</p> </li> <li> <code>report_mp_corrections</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to report the Materials Project corrections in the results.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspASEOptSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/_base.py</code> <pre><code>def run_and_summarize_opt(\n    atoms: Atoms,\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    opt_defaults: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    report_mp_corrections: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | None = None,\n) -&gt; VaspASEOptSchema:\n    \"\"\"\n    Base job function for VASP recipes with ASE optimizers.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    calc_defaults\n        Default parameters for the recipe.\n    calc_swaps\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n    opt_defaults\n        Default arguments for the ASE optimizer.\n    opt_params\n        Dictionary of custom kwargs for [quacc.runners.ase.Runner.run_opt][]\n    report_mp_corrections\n        Whether to report the Materials Project corrections in the results.\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    VaspASEOptSchema\n        Dictionary of results\n    \"\"\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    calc = Vasp(atoms, preset=preset, **calc_flags)\n    dyn = Runner(atoms, calc, copy_files=copy_files).run_opt(**opt_flags)\n\n    return VaspSummarize(\n        report_mp_corrections=report_mp_corrections, additional_fields=additional_fields\n    ).ase_opt(dyn)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/_base.html#quacc.recipes.vasp._base.run_and_summarize_vib_and_thermo","title":"run_and_summarize_vib_and_thermo","text":"<pre><code>run_and_summarize_vib_and_thermo(\n    atoms: Atoms,\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    thermo_method: Literal[\n        \"ideal_gas\", \"harmonic\"\n    ] = \"harmonic\",\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    vib_kwargs: VibKwargs | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | None = None,\n) -&gt; VibThermoSchema\n</code></pre> <p>Base job function for VASP recipes with ASE vibrational analysis.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>energy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Energy of the system</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature of the system</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure of the system</p> </li> <li> <code>thermo_method</code>               (<code>Literal['ideal_gas', 'harmonic']</code>, default:                   <code>'harmonic'</code> )           \u2013            <p>Method to use for thermochemistry. Options are \"harmonic\" or \"ideal_gas\".</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default parameters for the recipe.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> <li> <code>vib_kwargs</code>               (<code>VibKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for quacc.runners.ase.Runner.run_vib</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/_base.py</code> <pre><code>def run_and_summarize_vib_and_thermo(\n    atoms: Atoms,\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    thermo_method: Literal[\"ideal_gas\", \"harmonic\"] = \"harmonic\",\n    preset: str | None = None,\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    vib_kwargs: VibKwargs | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | None = None,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Base job function for VASP recipes with ASE vibrational analysis.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    energy\n        Energy of the system\n    temperature\n        Temperature of the system\n    pressure\n        Pressure of the system\n    thermo_method\n        Method to use for thermochemistry. Options are \"harmonic\" or \"ideal_gas\".\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    calc_defaults\n        Default parameters for the recipe.\n    calc_swaps\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n    vib_kwargs\n        Dictionary of custom kwargs for [quacc.runners.ase.Runner.run_vib][]\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results\n    \"\"\"\n\n    # Set defaults\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    calc = Vasp(atoms, preset=preset, **calc_flags)\n    vib = Runner(atoms, calc, copy_files=copy_files).run_vib(vib_kwargs=vib_kwargs)\n    return VibSummarize(vib, additional_fields=additional_fields).vib_and_thermo(\n        thermo_method, energy=energy, temperature=temperature, pressure=pressure\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html","title":"core","text":"<p>Core recipes for VASP.</p>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.ase_relax_job","title":"ase_relax_job","text":"<pre><code>ase_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: (\n        SourceDirectory\n        | dict[SourceDirectory, Filenames]\n        | None\n    ) = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspASEOptSchema\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'DefaultSetGGA'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the quacc.calculators.vasp.vasp.Vasp calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspASEOptSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef ase_relax_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspASEOptSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    relax_cell\n        True if a volume relaxation should be performed. False if only the positions\n        should be updated.\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [quacc.calculators.vasp.vasp.Vasp][] calculator.\n\n    Returns\n    -------\n    VaspASEOptSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\"lcharg\": False, \"lwave\": False, \"nsw\": 0}\n    opt_defaults = {\"relax_cell\": relax_cell}\n    return run_and_summarize_opt(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        opt_defaults=opt_defaults,\n        opt_params=opt_params,\n        additional_fields={\"name\": \"VASP ASE Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.double_relax_flow","title":"double_relax_flow","text":"<pre><code>double_relax_flow(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    relax_cell: bool = True,\n    relax1_kwargs: dict[str, Any] | None = None,\n    relax2_kwargs: dict[str, Any] | None = None,\n) -&gt; DoubleRelaxSchema\n</code></pre> <p>Double-relax a structure. This is particularly useful for a few reasons:</p> <ol> <li> <p>To carry out a cheaper pre-relaxation before the high-quality run.</p> </li> <li> <p>To carry out a GGA calculation before a meta-GGA or hybrid calculation that requires the GGA wavefunction.</p> </li> <li> <p>To carry out volume relaxations where large changes in volume can require a second relaxation to resolve forces.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'DefaultSetGGA'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>relax1_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the first relaxation.</p> </li> <li> <code>relax2_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the second relaxation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DoubleRelaxSchema</code>           \u2013            <p>Dictionary of results from each step.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@flow\ndef double_relax_flow(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    relax_cell: bool = True,\n    relax1_kwargs: dict[str, Any] | None = None,\n    relax2_kwargs: dict[str, Any] | None = None,\n) -&gt; DoubleRelaxSchema:\n    \"\"\"\n    Double-relax a structure. This is particularly useful for a few reasons:\n\n    1. To carry out a cheaper pre-relaxation before the high-quality run.\n\n    2. To carry out a GGA calculation before a meta-GGA or hybrid calculation\n    that requires the GGA wavefunction.\n\n    3. To carry out volume relaxations where large changes in volume\n    can require a second relaxation to resolve forces.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    relax1_kwargs\n        Dictionary of custom kwargs for the first relaxation.\n    relax2_kwargs\n        Dictionary of custom kwargs for the second relaxation.\n\n    Returns\n    -------\n    DoubleRelaxSchema\n        Dictionary of results from each step.\n    \"\"\"\n    relax1_kwargs = relax1_kwargs or {}\n    relax2_kwargs = relax2_kwargs or {}\n\n    # Run first relaxation\n    summary1 = relax_job(atoms, preset=preset, relax_cell=relax_cell, **relax1_kwargs)\n\n    # Run second relaxation\n    summary2 = relax_job(\n        summary1[\"atoms\"],\n        preset=preset,\n        relax_cell=relax_cell,\n        copy_files=Copy({summary1[\"dir_name\"]: [\"WAVECAR*\"]}),\n        **relax2_kwargs,\n    )\n\n    return {\"relax1\": summary1, \"relax2\": summary2}\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.freq_job","title":"freq_job","text":"<pre><code>freq_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    thermo_method: Literal[\n        \"harmonic\", \"ideal_gas\"\n    ] = \"harmonic\",\n    vib_kwargs: VibKwargs | None = None,\n    copy_files: (\n        SourceDirectory\n        | dict[SourceDirectory, Filenames]\n        | None\n    ) = None,\n    **calc_kwargs\n) -&gt; VibThermoSchema\n</code></pre> <p>Run a frequency job and calculate thermochemistry.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'DefaultSetGGA'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>energy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Potential energy in eV. If 0, then the output is just the correction.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> <li> <code>thermo_method</code>               (<code>Literal['harmonic', 'ideal_gas']</code>, default:                   <code>'harmonic'</code> )           \u2013            <p>Method to use for thermochemistry. Options are \"harmonic\" or \"ideal_gas\".</p> </li> <li> <code>vib_kwargs</code>               (<code>VibKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the ase.vibrations.Vibrations class.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    thermo_method: Literal[\"harmonic\", \"ideal_gas\"] = \"harmonic\",\n    vib_kwargs: VibKwargs | None = None,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    **calc_kwargs,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Run a frequency job and calculate thermochemistry.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    energy\n        Potential energy in eV. If 0, then the output is just the correction.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    thermo_method\n        Method to use for thermochemistry. Options are \"harmonic\" or \"ideal_gas\".\n    vib_kwargs\n        Dictionary of kwargs for the [ase.vibrations.Vibrations][] class.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary of results\n    \"\"\"\n    calc_defaults = {\"ediff\": 1e-7, \"isym\": 0, \"lcharg\": False, \"lwave\": True, \"nsw\": 0}\n    vib_kwargs = vib_kwargs or {}\n\n    return run_and_summarize_vib_and_thermo(\n        atoms,\n        energy=energy,\n        temperature=temperature,\n        pressure=pressure,\n        thermo_method=thermo_method,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        vib_kwargs=vib_kwargs,\n        copy_files=copy_files,\n        additional_fields={\"name\": \"VASP Frequency and Thermo\"},\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.non_scf_job","title":"non_scf_job","text":"<pre><code>non_scf_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory,\n    preset: str | None = \"DefaultSetGGA\",\n    nbands_factor: float = 1.2,\n    kpts_mode: Literal[\"uniform\", \"line\"] = \"uniform\",\n    uniform_kppvol: float = 100,\n    line_kpt_density: float = 20,\n    calculate_optics: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Carry out a non-self-consistent field (NSCF) calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object.</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory</code>)           \u2013            <p>Directory of the prior job. Must contain a CHGCAR and vasprun.xml file.</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'DefaultSetGGA'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>nbands_factor</code>               (<code>float</code>, default:                   <code>1.2</code> )           \u2013            <p>A multiplicative factor used to adjust NBANDS when vasprun.xml(.gz) exists in prev_dir</p> </li> <li> <code>kpts_mode</code>               (<code>Literal['uniform', 'line']</code>, default:                   <code>'uniform'</code> )           \u2013            <p>Type of k-points mode. Options are \"uniform\" or \"line\".</p> </li> <li> <code>uniform_kppvol</code>               (<code>float</code>, default:                   <code>100</code> )           \u2013            <p>The k-point per volume density for the uniform k-point mode.</p> </li> <li> <code>line_kpt_density</code>               (<code>float</code>, default:                   <code>20</code> )           \u2013            <p>The k-point density for the line k-point mode.</p> </li> <li> <code>calculate_optics</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to calculate optical properties.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef non_scf_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory,\n    preset: str | None = \"DefaultSetGGA\",\n    nbands_factor: float = 1.2,\n    kpts_mode: Literal[\"uniform\", \"line\"] = \"uniform\",\n    uniform_kppvol: float = 100,\n    line_kpt_density: float = 20,\n    calculate_optics: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a non-self-consistent field (NSCF) calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object.\n    prev_dir\n        Directory of the prior job. Must contain a CHGCAR and vasprun.xml file.\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    nbands_factor\n        A multiplicative factor used to adjust NBANDS when vasprun.xml(.gz) exists in\n        prev_dir\n    kpts_mode\n        Type of k-points mode. Options are \"uniform\" or \"line\".\n    uniform_kppvol\n        The k-point per volume density for the uniform k-point mode.\n    line_kpt_density\n        The k-point density for the line k-point mode.\n    calculate_optics\n        Whether to calculate optical properties.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n\n    vasprun_path = zpath(str(Path(prev_dir, \"vasprun.xml\")))\n    vasprun = Vasprun(vasprun_path)\n\n    prior_nbands = vasprun.parameters[\"NBANDS\"]\n    calc_defaults: dict[str, Any] = {\n        \"icharg\": 11,\n        \"kspacing\": None,\n        \"lcharg\": False,\n        \"lorbit\": 11,\n        \"lwave\": False,\n        \"nsw\": 0,\n        \"nbands\": int(np.ceil(prior_nbands * nbands_factor)),\n    }\n    if kpts_mode == \"uniform\":\n        calc_defaults |= {\n            \"ismear\": -5,\n            \"isym\": 2,\n            \"pmg_kpts\": {\"kppvol\": uniform_kppvol},\n            \"nedos\": 6001,\n        }\n    elif kpts_mode == \"line\":\n        is_metal = vasprun.get_band_structure().is_metal()\n        calc_defaults |= {\n            \"ismear\": 1 if is_metal else 0,\n            \"isym\": 0,\n            \"pmg_kpts\": {\"line_density\": line_kpt_density},\n            \"sigma\": 0.2 if is_metal else 0.01,\n        }\n    else:\n        raise ValueError(\"Supported kpoint modes are 'uniform' and 'line' at present\")\n\n    if calculate_optics:\n        calc_defaults |= {\"cshift\": 1e-5, \"loptics\": True, \"lreal\": False}\n\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Non-SCF\"} | (additional_fields or {}),\n        copy_files={prev_dir: [\"CHGCAR*\", \"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    relax_cell: bool = False,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'DefaultSetGGA'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the quacc.calculators.vasp.vasp.Vasp calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    relax_cell: bool = False,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [quacc.calculators.vasp.vasp.Vasp][] calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"ediffg\": -0.02,\n        \"isif\": 3 if relax_cell else 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-6,\n    }\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/core.html#quacc.recipes.vasp.core.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Carry out a single-point calculation. If you want high quality forces, then you should set ISMEAR = 0 instead of ISMEAR = -5 (particularly for metals).</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'DefaultSetGGA'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    preset: str | None = \"DefaultSetGGA\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a single-point calculation. If you want high quality forces,\n    then you should set ISMEAR = 0 instead of ISMEAR = -5 (particularly for\n    metals).\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"ismear\": -5,\n        \"laechg\": True,\n        \"lcharg\": True,\n        \"lreal\": False,\n        \"lwave\": True,\n        \"nedos\": 3001,\n        \"nsw\": 0,\n    }\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/fairchem.html","title":"fairchem","text":"<p>Meta FAIR recipes</p> <p>Important</p> <p>Make sure that you use the appropriate version pseudpotentials: - OMat: v.54 - OMC: v.54</p>"},{"location":"reference/quacc/recipes/vasp/fairchem.html#quacc.recipes.vasp.fairchem.has_atomate2","title":"has_atomate2  <code>module-attribute</code>","text":"<pre><code>has_atomate2 = bool(find_spec('atomate2'))\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/fairchem.html#quacc.recipes.vasp.fairchem.has_fairchem","title":"has_fairchem  <code>module-attribute</code>","text":"<pre><code>has_fairchem = bool(find_spec('fairchem'))\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/fairchem.html#quacc.recipes.vasp.fairchem.has_fairchem_omat","title":"has_fairchem_omat  <code>module-attribute</code>","text":"<pre><code>has_fairchem_omat = has_fairchem and bool(\n    find_spec(\"fairchem.data.omat\")\n)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/fairchem.html#quacc.recipes.vasp.fairchem.omat_static_job","title":"omat_static_job","text":"<pre><code>omat_static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Carry out a static calculation with OMat settings.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/fairchem.py</code> <pre><code>@job\n@requires(\n    has_fairchem_omat,\n    \"fairchem-data-omat is not installed. Run `pip install quacc[fairchem]`\",\n)\ndef omat_static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a static calculation with OMat settings.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from fairchem.data.omat.vasp.sets import OMat24StaticSet\n\n    calc_defaults = MPtoASEConverter(atoms=atoms).convert_input_set(OMat24StaticSet())\n    calc_defaults |= {\"pp_version\": \"54\", \"incar_copilot\": \"ncore\"}\n\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"OMat Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/fairchem.html#quacc.recipes.vasp.fairchem.omc_static_job","title":"omc_static_job","text":"<pre><code>omc_static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Carry out a static calculation with OMC settings.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/fairchem.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[fairchem]`\")\ndef omc_static_job(\n    atoms: Atoms,\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a static calculation with OMC settings.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n\n    calc_defaults = _make_omc_inputs(atoms)\n    calc_defaults |= {\"pp_version\": \"54\", \"incar_copilot\": \"ncore\"}\n\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"OMC Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/matpes.html","title":"matpes","text":"<p>MatPES-compatible recipes</p> <p>Important</p> <p>Make sure that you use the MatPES-compatible pseudpotential versions (i.e. v.64)</p>"},{"location":"reference/quacc/recipes/vasp/matpes.html#quacc.recipes.vasp.matpes.has_atomate2","title":"has_atomate2  <code>module-attribute</code>","text":"<pre><code>has_atomate2 = bool(find_spec('atomate2'))\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/matpes.html#quacc.recipes.vasp.matpes.matpes_static_job","title":"matpes_static_job","text":"<pre><code>matpes_static_job(\n    atoms: Atoms,\n    *,\n    level: Literal[\"PBE\", \"r2SCAN\", \"HSE06\"],\n    kspacing: float | None = 0.22,\n    use_improvements: bool = False,\n    write_extra_files: bool = False,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to run a MatPES-compatible static calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>level</code>               (<code>Literal['PBE', 'r2SCAN', 'HSE06']</code>)           \u2013            <p>The level of theory: \"PBE\", \"r2SCAN\", \"HSE06\"</p> </li> <li> <code>kspacing</code>               (<code>float | None</code>, default:                   <code>0.22</code> )           \u2013            <p>The KSPACING parameter to use. Default: 0.22 as in the MatPES paper. This is likely too expensive in many cases.</p> </li> <li> <code>use_improvements</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to make the following improvements to the VASP settings: ALGO = All, EFERMI = MIDGAP, GGA_COMPAT = False, ISEARCH = 1, and ENAUG deleted.</p> </li> <li> <code>write_extra_files</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to write out the following IO files: LELF = True and NEDOS = 3001.</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/matpes.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef matpes_static_job(\n    atoms: Atoms,\n    *,\n    level: Literal[\"PBE\", \"r2SCAN\", \"HSE06\"],\n    kspacing: float | None = 0.22,\n    use_improvements: bool = False,\n    write_extra_files: bool = False,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to run a MatPES-compatible static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    level\n        The level of theory: \"PBE\", \"r2SCAN\", \"HSE06\"\n    kspacing\n        The KSPACING parameter to use. Default: 0.22 as in the MatPES\n        paper. This is likely too expensive in many cases.\n    use_improvements\n        Whether to make the following improvements to the VASP settings:\n        ALGO = All, EFERMI = MIDGAP, GGA_COMPAT = False, ISEARCH = 1,\n        and ENAUG deleted.\n    write_extra_files\n        Whether to write out the following IO files: LELF = True and NEDOS = 3001.\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from atomate2.vasp.jobs.matpes import MatPesGGAStaticMaker\n\n    maker = MatPesGGAStaticMaker()\n    maker.input_set_generator.auto_ispin = True\n    calc_defaults = MPtoASEConverter(atoms=atoms, prev_dir=prev_dir).convert_maker(\n        maker\n    )\n\n    # Set the user-defined KSPACING\n    calc_defaults |= {\"kspacing\": kspacing, \"incar_copilot\": \"nore\"}\n\n    # Set some parameters that we think are improvements to MatPES\n    if use_improvements:\n        calc_defaults |= {\n            \"algo\": \"all\",\n            \"efermi\": \"midgap\",\n            \"enaug\": None,\n            \"gga_compat\": False,\n            \"isearch\": 1,\n        }\n\n    # Write out optional files\n    if write_extra_files:\n        calc_defaults |= {\"lelf\": True, \"nedos\": 3001}\n\n    # Set the level of theory\n    del calc_defaults[\"gga\"]\n    if level.lower() == \"pbe\":\n        calc_defaults |= {\"xc\": \"pbe\", \"lwave\": True}\n    elif level.lower() == \"r2scan\":\n        calc_defaults |= {\"xc\": \"r2scan\"}\n    elif level.lower() == \"hse06\":\n        calc_defaults |= {\"algo\": \"normal\", \"xc\": \"hse06\"}\n        calc_defaults.pop(\"isearch\", None)\n    else:\n        raise ValueError(f\"Unsupported value for {level}\")\n\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": f\"MatPES {level} Static\"},\n        copy_files={prev_dir: [\"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mof_off.html","title":"mof_off","text":"<p>MOF-off-compatible VASP static calculation recipe.</p>"},{"location":"reference/quacc/recipes/vasp/mof_off.html#quacc.recipes.vasp.mof_off.has_atomate2","title":"has_atomate2  <code>module-attribute</code>","text":"<pre><code>has_atomate2 = bool(find_spec('atomate2'))\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mof_off.html#quacc.recipes.vasp.mof_off.mof_off_static_job","title":"mof_off_static_job","text":"<pre><code>mof_off_static_job(\n    atoms: Atoms,\n    *,\n    level: Literal[\"PBE\", \"r2SCAN\"],\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to run a MOF-Off-compatible static calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>level</code>               (<code>Literal['PBE', 'r2SCAN']</code>)           \u2013            <p>The level of theory: \"PBE\", \"r2SCAN\"</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mof_off.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mof_off_static_job(\n    atoms: Atoms,\n    *,\n    level: Literal[\"PBE\", \"r2SCAN\"],\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to run a MOF-Off-compatible static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    level\n        The level of theory: \"PBE\", \"r2SCAN\"\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    default_parameters = {\n        \"kspacing\": 0.4,\n        \"use_improvements\": True,\n        \"write_extra_files\": True,\n    }\n    calc_flags = recursive_dict_merge(default_parameters, calc_kwargs)\n\n    return matpes_static_job(atoms, level=level, prev_dir=prev_dir, **calc_flags)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html","title":"mp24","text":"<p>Materials Project-compatible recipes using the MP24 sets.</p> <p>Important</p> <p>Make sure that you use the Materials Project-compatible pseudpotential versions (i.e. v.64)</p>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.has_atomate2","title":"has_atomate2  <code>module-attribute</code>","text":"<pre><code>has_atomate2 = bool(find_spec('atomate2'))\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.MPMetaGGARelaxFlowSchema","title":"MPMetaGGARelaxFlowSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with the MP meta-GGA relaxation flows.</p>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.MPMetaGGARelaxFlowSchema.prerelax","title":"prerelax  <code>instance-attribute</code>","text":"<pre><code>prerelax: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.MPMetaGGARelaxFlowSchema.relax1","title":"relax1  <code>instance-attribute</code>","text":"<pre><code>relax1: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.MPMetaGGARelaxFlowSchema.relax2","title":"relax2  <code>instance-attribute</code>","text":"<pre><code>relax2: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.MPMetaGGARelaxFlowSchema.static","title":"static  <code>instance-attribute</code>","text":"<pre><code>static: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.mp_metagga_relax_flow","title":"mp_metagga_relax_flow","text":"<pre><code>mp_metagga_relax_flow(\n    atoms: Atoms,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; MPMetaGGARelaxFlowSchema\n</code></pre> <p>Materials Project r2SCAN workflow consisting of:</p> <ol> <li> <p>MP-compatible pre-relax</p> <ul> <li>name: \"mpa_prerelax_job\"</li> <li>job: quacc.recipes.vasp.mp24.mp_prerelax_job</li> </ul> </li> <li> <p>MP-compatible relax</p> <ul> <li>name: \"mp_metagga_relax_job\"</li> <li>job: quacc.recipes.vasp.mp24.mp_metagga_relax_job</li> </ul> </li> <li> <p>MP-compatible static</p> <ul> <li>name: \"mp_metagga_static_job\"</li> <li>job: quacc.recipes.vasp.mp24.mp_metagga_static_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the structure.</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictinoary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MPMetaGGARelaxFlowSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp24.py</code> <pre><code>@flow\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_metagga_relax_flow(\n    atoms: Atoms,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; MPMetaGGARelaxFlowSchema:\n    \"\"\"\n    Materials Project r2SCAN workflow consisting of:\n\n    1. MP-compatible pre-relax\n        - name: \"mpa_prerelax_job\"\n        - job: [quacc.recipes.vasp.mp24.mp_prerelax_job][]\n\n    2. MP-compatible relax\n        - name: \"mp_metagga_relax_job\"\n        - job: [quacc.recipes.vasp.mp24.mp_metagga_relax_job][]\n\n    3. MP-compatible static\n        - name: \"mp_metagga_static_job\"\n        - job: [quacc.recipes.vasp.mp24.mp_metagga_static_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictinoary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    MPMetaGGARelaxFlowSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    (mp_prerelax_job_, mp_metagga_relax_job_, mp_metagga_static_job_) = customize_funcs(\n        [\"mp_prerelax_job\", \"mp_metagga_relax_job\", \"mp_metagga_static_job\"],\n        [mp_prerelax_job, mp_metagga_relax_job, mp_metagga_static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    # Run the prerelax\n    prerelax_results = mp_prerelax_job_(atoms)\n\n    # Run the relax\n    relax_results = mp_metagga_relax_job_(\n        prerelax_results[\"atoms\"], prev_dir=prerelax_results[\"dir_name\"]\n    )\n\n    # Run the second relax\n    double_relax_results = mp_metagga_relax_job_(\n        relax_results[\"atoms\"], prev_dir=relax_results[\"dir_name\"]\n    )\n\n    # Run the static\n    static_results = mp_metagga_static_job_(\n        double_relax_results[\"atoms\"], prev_dir=double_relax_results[\"dir_name\"]\n    )\n\n    return {\n        \"prerelax\": prerelax_results,\n        \"relax1\": relax_results,\n        \"relax2\": double_relax_results,\n        \"static\": static_results,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.mp_metagga_relax_job","title":"mp_metagga_relax_job","text":"<pre><code>mp_metagga_relax_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to relax a structure with Materials Project r2SCAN workflow settings. By default, this uses an r2SCAN relax step.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp24.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_metagga_relax_job(\n    atoms: Atoms, prev_dir: SourceDirectory | None = None, **calc_kwargs\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a structure with Materials Project r2SCAN workflow settings. By default, this uses\n    an r2SCAN relax step.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results.\n    \"\"\"\n    from atomate2.vasp.jobs.mp import MP24RelaxMaker\n\n    calc_defaults = MPtoASEConverter(atoms=atoms, prev_dir=prev_dir).convert_maker(\n        MP24RelaxMaker()\n    )\n    calc_defaults[\"incar_copilot\"] = \"ncore\"\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        report_mp_corrections=True,\n        additional_fields={\"name\": \"MP r2SCAN Relax\"},\n        copy_files={prev_dir: [\"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.mp_metagga_static_job","title":"mp_metagga_static_job","text":"<pre><code>mp_metagga_static_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to run a static calculation on a structure with r2SCAN workflow Materials Project settings. By default, this uses an r2SCAN static step.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to <code>ase.calculators.vasp.vasp.Vasp</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp24.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_metagga_static_job(\n    atoms: Atoms, prev_dir: SourceDirectory | None = None, **calc_kwargs\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to run a static calculation on a structure with r2SCAN workflow Materials Project settings.\n    By default, this uses an r2SCAN static step.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Dictionary of custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to `ase.calculators.vasp.vasp.Vasp`.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from atomate2.vasp.jobs.mp import MP24StaticMaker\n\n    calc_defaults = MPtoASEConverter(atoms=atoms, prev_dir=prev_dir).convert_maker(\n        MP24StaticMaker()\n    )\n    calc_defaults[\"incar_copilot\"] = \"ncore\"\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        report_mp_corrections=True,\n        additional_fields={\"name\": \"MP r2SCAN Static\"},\n        copy_files={prev_dir: [\"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp24.html#quacc.recipes.vasp.mp24.mp_prerelax_job","title":"mp_prerelax_job","text":"<pre><code>mp_prerelax_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to pre-relax a structure with Materials Project r2SCAN workflow settings. By default, this uses a PBEsol pre-relax step.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp24.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_prerelax_job(\n    atoms: Atoms, prev_dir: SourceDirectory | None = None, **calc_kwargs\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to pre-relax a structure with Materials Project r2SCAN workflow settings. By default, this\n    uses a PBEsol pre-relax step.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    from atomate2.vasp.jobs.mp import MP24PreRelaxMaker\n\n    calc_defaults = MPtoASEConverter(atoms=atoms, prev_dir=prev_dir).convert_maker(\n        MP24PreRelaxMaker()\n    )\n    calc_defaults[\"incar_copilot\"] = \"ncore\"\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        report_mp_corrections=True,\n        additional_fields={\"name\": \"MP PBESol Pre-Relax\"},\n        copy_files={prev_dir: [\"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html","title":"mp_legacy","text":"<p>Materials Project-compatible recipes using the original MP settings.</p> <p>Important</p> <p>Make sure that you use the Materials Project-compatible pseudpotential versions. The GGA workflows use the old (no version) PAW PBE potentials.</p>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.has_atomate2","title":"has_atomate2  <code>module-attribute</code>","text":"<pre><code>has_atomate2 = bool(find_spec('atomate2'))\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.MPGGARelaxFlowSchema","title":"MPGGARelaxFlowSchema","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hint associated with the MP GGA relaxation flows.</p>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.MPGGARelaxFlowSchema.relax1","title":"relax1  <code>instance-attribute</code>","text":"<pre><code>relax1: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.MPGGARelaxFlowSchema.relax2","title":"relax2  <code>instance-attribute</code>","text":"<pre><code>relax2: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.MPGGARelaxFlowSchema.static","title":"static  <code>instance-attribute</code>","text":"<pre><code>static: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.mp_gga_relax_flow","title":"mp_gga_relax_flow","text":"<pre><code>mp_gga_relax_flow(\n    atoms: Atoms,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; MPGGARelaxFlowSchema\n</code></pre> <p>Materials Project GGA workflow consisting of:</p> <ol> <li> <p>MP-compatible relax</p> <ul> <li>name: \"mp_gga_relax_job\"</li> <li>job: quacc.recipes.vasp.mp_legacy.mp_gga_relax_job</li> </ul> </li> <li> <p>MP-compatible (second) relax</p> <ul> <li>name: \"mp_gga_relax_job\"</li> <li>job: quacc.recipes.vasp.mp_legacy.mp_gga_relax_job</li> </ul> </li> <li> <p>MP-compatible static</p> <ul> <li>name: \"mp_gga_static_job\"</li> <li>job: quacc.recipes.vasp.mp_legacy.mp_gga_static_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the structure.</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictinoary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MPGGARelaxFlowSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp_legacy.py</code> <pre><code>@flow\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_gga_relax_flow(\n    atoms: Atoms,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; MPGGARelaxFlowSchema:\n    \"\"\"\n    Materials Project GGA workflow consisting of:\n\n    1. MP-compatible relax\n        - name: \"mp_gga_relax_job\"\n        - job: [quacc.recipes.vasp.mp_legacy.mp_gga_relax_job][]\n\n    2. MP-compatible (second) relax\n        - name: \"mp_gga_relax_job\"\n        - job: [quacc.recipes.vasp.mp_legacy.mp_gga_relax_job][]\n\n    3. MP-compatible static\n        - name: \"mp_gga_static_job\"\n        - job: [quacc.recipes.vasp.mp_legacy.mp_gga_static_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object for the structure.\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictinoary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    MPGGARelaxFlowSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    (mp_gga_relax_job_, mp_gga_static_job_) = customize_funcs(\n        [\"mp_gga_relax_job\", \"mp_gga_static_job\"],\n        [mp_gga_relax_job, mp_gga_static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    # Run the relax\n    relax_results = mp_gga_relax_job_(atoms)\n\n    # Run the second relax\n    double_relax_results = mp_gga_relax_job_(\n        relax_results[\"atoms\"], prev_dir=relax_results[\"dir_name\"]\n    )\n\n    # Run the static\n    static_results = mp_gga_static_job_(\n        double_relax_results[\"atoms\"], prev_dir=double_relax_results[\"dir_name\"]\n    )\n\n    return {\n        \"relax1\": relax_results,\n        \"relax2\": double_relax_results,\n        \"static\": static_results,\n    }\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.mp_gga_relax_job","title":"mp_gga_relax_job","text":"<pre><code>mp_gga_relax_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to relax a structure with the original Materials Project GGA(+U) settings.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp_legacy.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_gga_relax_job(\n    atoms: Atoms, prev_dir: SourceDirectory | None = None, **calc_kwargs\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a structure with the original Materials Project GGA(+U) settings.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results.\n    \"\"\"\n    from atomate2.vasp.jobs.mp import MPGGARelaxMaker\n\n    calc_defaults = MPtoASEConverter(atoms=atoms, prev_dir=prev_dir).convert_maker(\n        MPGGARelaxMaker()\n    )\n    calc_defaults[\"incar_copilot\"] = \"ncore\"\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        report_mp_corrections=True,\n        additional_fields={\"name\": \"MP GGA Relax\"},\n        copy_files={prev_dir: [\"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/mp_legacy.html#quacc.recipes.vasp.mp_legacy.mp_gga_static_job","title":"mp_gga_static_job","text":"<pre><code>mp_gga_static_job(\n    atoms: Atoms,\n    prev_dir: SourceDirectory | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to run a static calculation on a structure with the original Materials Project GGA(+U) settings.</p> <p>This is also the settings compatible with the MPtrj dataset.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>prev_dir</code>               (<code>SourceDirectory | None</code>, default:                   <code>None</code> )           \u2013            <p>A previous directory for a prior step in the workflow.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/mp_legacy.py</code> <pre><code>@job\n@requires(has_atomate2, \"atomate2 is not installed. Run `pip install quacc[mp]`\")\ndef mp_gga_static_job(\n    atoms: Atoms, prev_dir: SourceDirectory | None = None, **calc_kwargs\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to run a static calculation on a structure with the original Materials Project GGA(+U) settings.\n\n    This is also the settings compatible with the MPtrj dataset.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    prev_dir\n        A previous directory for a prior step in the workflow.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n    \"\"\"\n    from atomate2.vasp.jobs.mp import MPGGAStaticMaker\n\n    calc_defaults = MPtoASEConverter(atoms=atoms, prev_dir=prev_dir).convert_maker(\n        MPGGAStaticMaker()\n    )\n    calc_defaults[\"incar_copilot\"] = \"ncore\"\n    return run_and_summarize(\n        atoms,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        report_mp_corrections=True,\n        additional_fields={\"name\": \"MP GGA Static\"},\n        copy_files={prev_dir: [\"WAVECAR*\"]} if prev_dir else None,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html","title":"qmof","text":"<p>QMOF-compatible recipes.</p> <p>This set of recipes is meant to be compatible with the QMOF Database workflow. Reference: https://doi.org/10.1016/j.matt.2021.02.015</p>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.QMOFRelaxSchema","title":"QMOFRelaxSchema","text":"<p>               Bases: <code>VaspSchema</code></p> <p>Type hint associated with the QMOF relaxation jobs.</p>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.QMOFRelaxSchema.double_relax","title":"double_relax  <code>instance-attribute</code>","text":"<pre><code>double_relax: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.QMOFRelaxSchema.position_relax_lowacc","title":"position_relax_lowacc  <code>instance-attribute</code>","text":"<pre><code>position_relax_lowacc: VaspSchema\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.QMOFRelaxSchema.prerelax_lowacc","title":"prerelax_lowacc  <code>instance-attribute</code>","text":"<pre><code>prerelax_lowacc: VaspSchema | None\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.QMOFRelaxSchema.volume_relax_lowacc","title":"volume_relax_lowacc  <code>instance-attribute</code>","text":"<pre><code>volume_relax_lowacc: VaspSchema | None\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/qmof.html#quacc.recipes.vasp.qmof.qmof_relax_job","title":"qmof_relax_job","text":"<pre><code>qmof_relax_job(\n    atoms: Atoms,\n    relax_cell: bool = True,\n    run_prerelax: bool = True,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs\n) -&gt; QMOFRelaxSchema\n</code></pre> <p>Relax a structure in a multi-step process for increased computational efficiency. This is all done in a single compute job. Settings are such that they are compatible with the QMOF Database.</p> <ol> <li> <p>A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.</p> </li> <li> <p>Position relaxation with default ENCUT and coarse k-point grid.</p> </li> <li> <p>Optional: volume relaxation with coarse k-point grid.</p> </li> <li> <p>Double relaxation using production-quality settings.</p> </li> <li> <p>Static calculation.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>True if a volume relaxation should be performed. False if only the positions should be updated.</p> </li> <li> <code>run_prerelax</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, a pre-relax will be carried out with BFGSLineSearch. Recommended if starting from hypothetical structures or materials with very high starting forces.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QMOFRelaxSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/qmof.py</code> <pre><code>@job\ndef qmof_relax_job(\n    atoms: Atoms,\n    relax_cell: bool = True,\n    run_prerelax: bool = True,\n    copy_files: SourceDirectory | Copy | None = None,\n    **calc_kwargs,\n) -&gt; QMOFRelaxSchema:\n    \"\"\"\n    Relax a structure in a multi-step process for increased computational efficiency.\n    This is all done in a single compute job. Settings are such that they are compatible\n    with the QMOF Database.\n\n    1. A \"pre-relaxation\" with BFGSLineSearch to resolve very high forces.\n\n    2. Position relaxation with default ENCUT and coarse k-point grid.\n\n    3. Optional: volume relaxation with coarse k-point grid.\n\n    4. Double relaxation using production-quality settings.\n\n    5. Static calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    relax_cell\n        True if a volume relaxation should be performed. False if only the\n        positions should be updated.\n    run_prerelax\n        If True, a pre-relax will be carried out with BFGSLineSearch.\n        Recommended if starting from hypothetical structures or materials with\n        very high starting forces.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    QMOFRelaxSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    copy_files = None\n\n    # 1. Pre-relaxation\n    if run_prerelax:\n        summary1 = _prerelax(atoms, **calc_kwargs)\n        atoms = summary1[\"atoms\"]\n        copy_files = {summary1[\"dir_name\"]: [\"WAVECAR*\"]}\n\n    # 2. Position relaxation (loose)\n    summary2 = _loose_relax_positions(atoms, copy_files=copy_files, **calc_kwargs)\n    atoms = summary2[\"atoms\"]\n    copy_files = {summary2[\"dir_name\"]: [\"WAVECAR*\"]}\n\n    # 3. Optional: Volume relaxation (loose)\n    if relax_cell:\n        summary3 = _loose_relax_cell(atoms, copy_files=copy_files, **calc_kwargs)\n        atoms = summary3[\"atoms\"]\n        copy_files = {summary3[\"dir_name\"]: [\"WAVECAR*\"]}\n\n    # 4. Double Relaxation\n    # This is done for two reasons: a) because it can\n    # resolve repadding issues when dV is large; b) because we can use LREAL =\n    # Auto for the first relaxation and the default LREAL for the second.\n    summary4 = _double_relax(\n        atoms, relax_cell=relax_cell, copy_files=copy_files, **calc_kwargs\n    )\n    atoms = summary4[-1][\"atoms\"]\n    copy_files = {summary4[-1][\"dir_name\"]: [\"WAVECAR*\"]}\n\n    # 5. Static Calculation\n    summary5 = _static(atoms, copy_files=copy_files, **calc_kwargs)\n    summary5[\"prerelax_lowacc\"] = summary1 if run_prerelax else None\n    summary5[\"position_relax_lowacc\"] = summary2\n    summary5[\"volume_relax_lowacc\"] = summary3 if relax_cell else None\n    summary5[\"double_relax\"] = summary4\n\n    return summary5\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html","title":"slabs","text":"<p>Recipes for slabs.</p>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.bulk_to_slabs_flow","title":"bulk_to_slabs_flow","text":"<pre><code>bulk_to_slabs_flow(\n    atoms: Atoms,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n    run_static: bool = True,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; list[VaspSchema]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab generation</p> </li> <li> <p>Slab relaxations</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.vasp.slabs.relax_job</li> </ul> </li> <li> <p>Optional slab statics</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.vasp.slabs.static_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>make_slabs_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_slabs_from_bulk</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run static calculations.</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>           \u2013            <p>List of dictionary results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef bulk_to_slabs_flow(\n    atoms: Atoms,\n    make_slabs_kwargs: dict[str, Any] | None = None,\n    run_static: bool = True,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; list[VaspSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab generation\n\n    2. Slab relaxations\n        - name: \"relax_job\"\n        - job: [quacc.recipes.vasp.slabs.relax_job][]\n\n    3. Optional slab statics\n        - name: \"static_job\"\n        - job: [quacc.recipes.vasp.slabs.static_job][]\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    make_slabs_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_slabs_from_bulk][]\n    run_static\n        Whether to run static calculations.\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionary results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    relax_job_, static_job_ = customize_funcs(\n        [\"relax_job\", \"static_job\"],\n        [relax_job, static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    return bulk_to_slabs_subflow(\n        atoms,\n        relax_job_,\n        static_job=static_job_ if run_static else None,\n        make_slabs_kwargs=make_slabs_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.relax_job","title":"relax_job","text":"<pre><code>relax_job(\n    atoms: Atoms,\n    preset: str | None = \"SlabSetPBE\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to relax a slab.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'SlabSetPBE'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    preset: str | None = \"SlabSetPBE\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to relax a slab.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"auto_dipole\": True,\n        \"ediffg\": -0.02,\n        \"isif\": 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Slab Relax\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.slab_to_ads_flow","title":"slab_to_ads_flow","text":"<pre><code>slab_to_ads_flow(\n    slab: Atoms,\n    adsorbate: Atoms,\n    run_static: bool = True,\n    make_ads_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: (\n        dict[str, Callable | None] | None\n    ) = None,\n) -&gt; list[VaspSchema]\n</code></pre> <p>Workflow consisting of:</p> <ol> <li> <p>Slab-adsorbate generation</p> </li> <li> <p>Slab-adsorbate relaxations</p> <ul> <li>name: \"relax_job\"</li> <li>job: quacc.recipes.vasp.slabs.relax_job</li> </ul> </li> <li> <p>Optional slab-adsorbate statics</p> <ul> <li>name: \"static_job\"</li> <li>job: quacc.recipes.vasp.slabs.static_job</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>slab</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the slab structure.</p> </li> <li> <code>adsorbate</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object for the adsorbate.</p> </li> <li> <code>run_static</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run static calculations.</p> </li> <li> <code>make_ads_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to quacc.atoms.slabs.make_adsorbate_structures</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom parameters to pass to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are dictionaries of parameters.</p> </li> <li> <code>job_decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each Job in the Flow. This is a dictionary where the keys are the names of the jobs and the values are decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[VaspSchema]</code>           \u2013            <p>List of dictionaries of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@flow\ndef slab_to_ads_flow(\n    slab: Atoms,\n    adsorbate: Atoms,\n    run_static: bool = True,\n    make_ads_kwargs: dict[str, Any] | None = None,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    job_decorators: dict[str, Callable | None] | None = None,\n) -&gt; list[VaspSchema]:\n    \"\"\"\n    Workflow consisting of:\n\n    1. Slab-adsorbate generation\n\n    2. Slab-adsorbate relaxations\n        - name: \"relax_job\"\n        - job: [quacc.recipes.vasp.slabs.relax_job][]\n\n    3. Optional slab-adsorbate statics\n        - name: \"static_job\"\n        - job: [quacc.recipes.vasp.slabs.static_job][]\n\n    Parameters\n    ----------\n    slab\n        Atoms object for the slab structure.\n    adsorbate\n        Atoms object for the adsorbate.\n    run_static\n        Whether to run static calculations.\n    make_ads_kwargs\n        Additional keyword arguments to pass to [quacc.atoms.slabs.make_adsorbate_structures][]\n    job_params\n        Custom parameters to pass to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are dictionaries of parameters.\n    job_decorators\n        Custom decorators to apply to each Job in the Flow. This is a dictionary where\n        the keys are the names of the jobs and the values are decorators.\n\n    Returns\n    -------\n    list[VaspSchema]\n        List of dictionaries of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    relax_job_, static_job_ = customize_funcs(\n        [\"relax_job\", \"static_job\"],\n        [relax_job, static_job],\n        param_swaps=job_params,\n        decorators=job_decorators,\n    )\n\n    return slab_to_ads_subflow(\n        slab,\n        adsorbate,\n        relax_job_,\n        static_job=static_job_ if run_static else None,\n        make_ads_kwargs=make_ads_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/recipes/vasp/slabs.html#quacc.recipes.vasp.slabs.static_job","title":"static_job","text":"<pre><code>static_job(\n    atoms: Atoms,\n    preset: str | None = \"SlabSetPBE\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs\n) -&gt; VaspSchema\n</code></pre> <p>Function to carry out a single-point calculation on a slab.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'SlabSetPBE'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp. All of the ASE Vasp calculator keyword arguments are supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>quacc/recipes/vasp/slabs.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    preset: str | None = \"SlabSetPBE\",\n    copy_files: SourceDirectory | Copy | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Function to carry out a single-point calculation on a slab.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp][]. All of the ASE\n        Vasp calculator keyword arguments are supported.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run][].\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"auto_dipole\": True,\n        \"ismear\": -5,\n        \"laechg\": True,\n        \"lcharg\": True,\n        \"lreal\": False,\n        \"lvhar\": True,\n        \"lwave\": True,\n        \"nedos\": 3001,\n        \"nsw\": 0,\n    }\n    return run_and_summarize(\n        atoms,\n        preset=preset,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"VASP Slab Static\"} | (additional_fields or {}),\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/quacc/runners/_base.html","title":"_base","text":"<p>Base class for runners.</p>"},{"location":"reference/quacc/runners/_base.html#quacc.runners._base.BaseRunner","title":"BaseRunner  <code>dataclass</code>","text":"<pre><code>BaseRunner(atoms: Atoms | None = None)\n</code></pre> <p>A base class for runners that sets up the calculation and cleans up the scratch directory.</p> <p>Attributes:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | None</code>)           \u2013            <p>Atoms object with calculator attached (or no Atoms object at all).</p> </li> </ul>"},{"location":"reference/quacc/runners/_base.html#quacc.runners._base.BaseRunner.atoms","title":"atoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>atoms: Atoms | None = None\n</code></pre>"},{"location":"reference/quacc/runners/_base.html#quacc.runners._base.BaseRunner.cleanup","title":"cleanup","text":"<pre><code>cleanup() -&gt; None\n</code></pre> <p>Perform cleanup operations on the runtime directory.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/runners/_base.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"\n    Perform cleanup operations on the runtime directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    calc_cleanup(self.atoms, self.tmpdir, self.job_results_dir)\n</code></pre>"},{"location":"reference/quacc/runners/_base.html#quacc.runners._base.BaseRunner.setup","title":"setup","text":"<pre><code>setup(\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; None\n</code></pre> <p>Perform setup operations on the runtime directory.</p> <p>Parameters:</p> <ul> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy to runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/runners/_base.py</code> <pre><code>def setup(self, copy_files: SourceDirectory | Copy | None = None) -&gt; None:\n    \"\"\"\n    Perform setup operations on the runtime directory.\n\n    Parameters\n    ----------\n    copy_files\n        Files to copy to runtime directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.tmpdir, self.job_results_dir = calc_setup(\n        self.atoms, copy_files=copy_files\n    )\n</code></pre>"},{"location":"reference/quacc/runners/ase.html","title":"ase","text":"<p>Utility functions for running ASE calculators with ASE-based methods.</p>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.has_geodesic_interpolate","title":"has_geodesic_interpolate  <code>module-attribute</code>","text":"<pre><code>has_geodesic_interpolate = bool(\n    find_spec(\"geodesic_interpolate\")\n)\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.has_sella","title":"has_sella  <code>module-attribute</code>","text":"<pre><code>has_sella = bool(find_spec('sella'))\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner","title":"Runner","text":"<pre><code>Runner(\n    atoms: Atoms | list[Atoms],\n    calculator: BaseCalculator,\n    copy_files: SourceDirectory | Copy | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseRunner</code></p> <p>Run various types of calculations in a scratch directory and copy the results back to the original directory. Note: This function does not modify the atoms object in-place.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | list[Atoms]</code>)           \u2013            <p>The Atoms object to run calculations on. A list[Atoms] is used for NEB.</p> </li> <li> <code>calculator</code>               (<code>BaseCalculator</code>)           \u2013            <p>The instantiated ASE calculator object to attach to the Atoms object.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms | list[Atoms],\n    calculator: BaseCalculator,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Runner object.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run calculations on. A list[Atoms] is used for NEB.\n    calculator\n        The instantiated ASE calculator object to attach to the Atoms object.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if isinstance(atoms, list):\n        self.atoms = [image.copy() for image in atoms]\n        for image in self.atoms:\n            image.calc = deepcopy(calculator)\n    else:\n        self.atoms = atoms.copy()\n        self.atoms.calc = calculator\n        self.setup(copy_files=copy_files)\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = [(copy()) for image in atoms]\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner.run_calc","title":"run_calc","text":"<pre><code>run_calc(\n    properties: list[str] | None = None,\n    geom_file: str | None = None,\n) -&gt; Atoms\n</code></pre> <p>This is a wrapper around <code>atoms.calc.calculate()</code>.</p> <p>Parameters:</p> <ul> <li> <code>geom_file</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The filename of the log file that contains the output geometry, used to update the atoms object's positions and cell after a job. It is better to specify this rather than relying on ASE to update the positions, as the latter behavior varies between codes.</p> </li> <li> <code>properties</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of properties to obtain. Defaults to [\"energy\", \"forces\"]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>The updated Atoms object.</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_calc(\n    self, properties: list[str] | None = None, geom_file: str | None = None\n) -&gt; Atoms:\n    \"\"\"\n    This is a wrapper around `atoms.calc.calculate()`.\n\n    Parameters\n    ----------\n    geom_file\n        The filename of the log file that contains the output geometry, used to\n        update the atoms object's positions and cell after a job. It is better\n        to specify this rather than relying on ASE to update the positions, as the\n        latter behavior varies between codes.\n    properties\n        A list of properties to obtain. Defaults to [\"energy\", \"forces\"]\n\n    Returns\n    -------\n    Atoms\n        The updated Atoms object.\n    \"\"\"\n    if not properties:\n        properties = (\n            [\"energy\"]\n            if isinstance(self.atoms.calc, Gaussian)\n            else [\"energy\", \"forces\"]\n        )  # TODO: Use GaussianOptimizer to avoid this hack\n\n    # Run calculation\n    try:\n        self.atoms.calc.calculate(\n            self.atoms, properties=properties, system_changes=calculator.all_changes\n        )\n    except Exception as exception:\n        terminate(self.tmpdir, exception)\n\n    # Most ASE calculators do not update the atoms object in-place with a call\n    # to .get_potential_energy(), which is important if an internal optimizer is\n    # used. This section is done to ensure that the atoms object is updated to\n    # the final geometry if `geom_file` is provided.\n    # Note: We have to be careful to make sure we don't lose the calculator\n    # object, as this contains important information such as the parameters\n    # and output properties (e.g. final magnetic moments).\n    if geom_file:\n        atoms_new = read(zpath(str(self.tmpdir / geom_file)))\n\n        # Make sure the atom indices didn't get updated somehow (sanity check).\n        # If this happens, there is a serious problem.\n        if (\n            np.array_equal(\n                atoms_new.get_atomic_numbers(), self.atoms.get_atomic_numbers()\n            )\n            is False\n        ):\n            raise ValueError(\n                \"Atomic numbers do not match between atoms and geom_file.\"\n            )\n\n        self.atoms.positions = atoms_new.positions\n        self.atoms.cell = atoms_new.cell\n\n    # Perform cleanup operations\n    self.cleanup()\n\n    return self.atoms\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner.run_md","title":"run_md","text":"<pre><code>run_md(\n    dynamics: MolecularDynamics,\n    dynamics_kwargs: dict[str, Any] | None = None,\n    steps: int = 1000,\n    maxwell_boltzmann_kwargs: (\n        MaxwellBoltzmanDistributionKwargs | None\n    ) = None,\n    set_com_stationary: bool = False,\n    set_zero_rotation: bool = False,\n) -&gt; MolecularDynamics\n</code></pre> <p>Run an ASE-based MD in a scratch directory and copy the results back to the original directory.</p> <p>Parameters:</p> <ul> <li> <code>dynamics</code>               (<code>MolecularDynamics</code>)           \u2013            <p>MolecularDynamics class to use, from <code>ase.md.md.MolecularDynamics</code>.</p> </li> <li> <code>dynamics_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the dynamics. Takes all valid kwargs for ASE MolecularDynamics classes.</p> </li> <li> <code>steps</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Maximum number of steps to run</p> </li> <li> <code>maxwell_boltzmann_kwargs</code>               (<code>MaxwellBoltzmanDistributionKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>If specified, a <code>MaxwellBoltzmannDistribution</code> will be applied to the atoms based on <code>ase.md.velocitydistribution.MaxwellBoltzmannDistribution</code> with the specified keyword arguments.</p> </li> <li> <code>set_com_stationary</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to set the center-of-mass momentum to zero. This would be applied after any <code>MaxwellBoltzmannDistribution</code> is set.</p> </li> <li> <code>set_zero_rotation</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to set the total angular momentum to zero. This would be applied after any <code>MaxwellBoltzmannDistribution</code> is set.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MolecularDymamics</code>           \u2013            <p>The ASE MolecularDynamics object.</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_md(\n    self,\n    dynamics: MolecularDynamics,\n    dynamics_kwargs: dict[str, Any] | None = None,\n    steps: int = 1000,\n    maxwell_boltzmann_kwargs: MaxwellBoltzmanDistributionKwargs | None = None,\n    set_com_stationary: bool = False,\n    set_zero_rotation: bool = False,\n) -&gt; MolecularDynamics:\n    \"\"\"\n    Run an ASE-based MD in a scratch directory and copy the results back to\n    the original directory.\n\n    Parameters\n    ----------\n    dynamics\n        MolecularDynamics class to use, from `ase.md.md.MolecularDynamics`.\n    dynamics_kwargs\n        Dictionary of kwargs for the dynamics. Takes all valid kwargs for ASE\n        MolecularDynamics classes.\n    steps\n        Maximum number of steps to run\n    maxwell_boltzmann_kwargs\n        If specified, a `MaxwellBoltzmannDistribution` will be applied to the atoms\n        based on `ase.md.velocitydistribution.MaxwellBoltzmannDistribution` with the\n        specified keyword arguments.\n    set_com_stationary\n        Whether to set the center-of-mass momentum to zero. This would be applied after\n        any `MaxwellBoltzmannDistribution` is set.\n    set_zero_rotation\n        Whether to set the total angular momentum to zero. This would be applied after\n        any `MaxwellBoltzmannDistribution` is set.\n\n    Returns\n    -------\n    MolecularDymamics\n        The ASE MolecularDynamics object.\n    \"\"\"\n\n    # Set defaults\n    dynamics_kwargs = dynamics_kwargs or {}\n    maxwell_boltzmann_kwargs = maxwell_boltzmann_kwargs or {}\n    dynamics_kwargs[\"logfile\"] = self.tmpdir / \"md.log\"\n\n    if maxwell_boltzmann_kwargs:\n        MaxwellBoltzmannDistribution(self.atoms, **maxwell_boltzmann_kwargs)\n    if set_com_stationary:\n        Stationary(self.atoms)\n    if set_zero_rotation:\n        ZeroRotation(self.atoms)\n\n    return self.run_opt(\n        fmax=None,\n        max_steps=steps,\n        optimizer=dynamics,\n        optimizer_kwargs=dynamics_kwargs,\n    )\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner.run_neb","title":"run_neb","text":"<pre><code>run_neb(\n    relax_cell: bool = False,\n    fmax: float = 0.01,\n    max_steps: int | None = 1000,\n    optimizer: type[Optimizer] = NEBOptimizer,\n    optimizer_kwargs: dict[str, Any] | None = None,\n    neb_kwargs: dict[str, Any] | None = None,\n    run_kwargs: dict[str, Any] | None = None,\n) -&gt; Dynamics\n</code></pre> <p>Run an NEB calculation.</p> <p>Parameters:</p> <ul> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the unit cell shape and volume.</p> </li> <li> <code>fmax</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> <code>max_steps</code>               (<code>int | None</code>, default:                   <code>1000</code> )           \u2013            <p>Maximum number of steps to take.</p> </li> <li> <code>optimizer</code>               (<code>type[Optimizer]</code>, default:                   <code>NEBOptimizer</code> )           \u2013            <p>Optimizer class to use.</p> </li> <li> <code>optimizer_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE Optimizer classes.</p> </li> <li> <code>neb_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the NEB class.</p> </li> <li> <code>run_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the <code>run()</code> method of the optimizer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dynamics</code>           \u2013            <p>The ASE Dynamics object following an NEB calculation.</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_neb(\n    self,\n    relax_cell: bool = False,\n    fmax: float = 0.01,\n    max_steps: int | None = 1000,\n    optimizer: type[Optimizer] = NEBOptimizer,\n    optimizer_kwargs: dict[str, Any] | None = None,\n    neb_kwargs: dict[str, Any] | None = None,\n    run_kwargs: dict[str, Any] | None = None,\n) -&gt; Dynamics:\n    \"\"\"\n    Run an NEB calculation.\n\n    Parameters\n    ----------\n    relax_cell\n        Whether to relax the unit cell shape and volume.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use.\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE\n        Optimizer classes.\n    neb_kwargs\n        Dictionary of kwargs for the NEB class.\n    run_kwargs\n        Dictionary of kwargs for the `run()` method of the optimizer.\n\n    Returns\n    -------\n    Dynamics\n        The ASE Dynamics object following an NEB calculation.\n    \"\"\"\n    images = self.atoms\n    run_kwargs = run_kwargs or {}\n    neb_kwargs = neb_kwargs or {}\n    traj_filename = \"opt.traj\"\n\n    # Create a parent temporary directory for the NEB run\n    neb_tmpdir, neb_results_dir = calc_setup(None)\n\n    # Adjust optimizer_kwargs to use the parent directory\n    optimizer_kwargs = recursive_dict_merge(\n        {\n            \"logfile\": str(neb_tmpdir / \"opt.log\"),\n            \"restart\": str(neb_tmpdir / \"opt.json\"),\n        },\n        optimizer_kwargs,\n    )\n\n    if \"trajectory\" in optimizer_kwargs:\n        msg = \"Quacc does not support setting the `trajectory` kwarg.\"\n        raise ValueError(msg)\n\n    if optimizer == BFGSLineSearch:\n        raise ValueError(\"BFGSLineSearch is not allowed as optimizer with NEB.\")\n\n    # Copy atoms so we don't modify it in-place\n    neb = NEB(images, **neb_kwargs)\n\n    # Perform staging operations\n    for i, image in enumerate(images):\n        image_tmpdir = neb_tmpdir / f\"image_{i}\"\n        image_tmpdir.mkdir()\n        image.calc.directory = image_tmpdir\n\n    # Define the Trajectory object\n    traj_file = neb_tmpdir / traj_filename\n    traj = Trajectory(traj_file, \"w\", atoms=neb)\n\n    # Set volume relaxation constraints, if relevant\n    if relax_cell:\n        for i in range(len(images)):\n            if images[i].pbc.any():\n                images[i] = FrechetCellFilter(images[i])\n\n    dyn = optimizer(neb, **optimizer_kwargs)\n    dyn.attach(traj.write)\n    dyn.run(fmax, max_steps)\n    traj.close()\n\n    calc_cleanup(None, neb_tmpdir, neb_results_dir)\n    traj.filename = zpath(str(neb_results_dir / traj_filename))\n    dyn.trajectory = traj\n\n    return dyn\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner.run_opt","title":"run_opt","text":"<pre><code>run_opt(\n    relax_cell: bool = False,\n    fmax: float | None = 0.01,\n    max_steps: int = 1000,\n    optimizer: type[Dynamics] = BFGS,\n    optimizer_kwargs: dict[str, Any] | None = None,\n    store_intermediate_results: bool = False,\n    fn_hook: Callable | None = None,\n    run_kwargs: dict[str, Any] | None = None,\n    filter_kwargs: dict[str, Any] | None = None,\n) -&gt; Optimizer\n</code></pre> <p>This is a wrapper around the optimizers in ASE.</p> <p>Parameters:</p> <ul> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the unit cell shape and volume.</p> </li> <li> <code>fmax</code>               (<code>float | None</code>, default:                   <code>0.01</code> )           \u2013            <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> <code>max_steps</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Maximum number of steps to take.</p> </li> <li> <code>optimizer</code>               (<code>type[Dynamics]</code>, default:                   <code>BFGS</code> )           \u2013            <p>Optimizer class to use.</p> </li> <li> <code>optimizer_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE Optimizer classes. Refer to <code>_set_sella_kwargs</code> for Sella-related kwargs and how they are set.</p> </li> <li> <code>store_intermediate_results</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to store the files generated at each intermediate step in the optimization. If enabled, they will be stored in a directory named <code>stepN</code> where <code>N</code> is the step number, starting at 0.</p> </li> <li> <code>fn_hook</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>A custom function to call after each step of the optimization. The function must take the instantiated dynamics class as its only argument.</p> </li> <li> <code>run_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the <code>run()</code> method of the optimizer.</p> </li> <li> <code>filter_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the <code>FrechetCellFilter</code> if relax_cell is True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optimizer</code>           \u2013            <p>The ASE Optimizer object following an optimization.</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_opt(\n    self,\n    relax_cell: bool = False,\n    fmax: float | None = 0.01,\n    max_steps: int = 1000,\n    optimizer: type[Dynamics] = BFGS,\n    optimizer_kwargs: dict[str, Any] | None = None,\n    store_intermediate_results: bool = False,\n    fn_hook: Callable | None = None,\n    run_kwargs: dict[str, Any] | None = None,\n    filter_kwargs: dict[str, Any] | None = None,\n) -&gt; Optimizer:\n    \"\"\"\n    This is a wrapper around the optimizers in ASE.\n\n    Parameters\n    ----------\n    relax_cell\n        Whether to relax the unit cell shape and volume.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use.\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer. Takes all valid kwargs for ASE\n        Optimizer classes. Refer to `_set_sella_kwargs` for Sella-related\n        kwargs and how they are set.\n    store_intermediate_results\n        Whether to store the files generated at each intermediate step in the\n        optimization. If enabled, they will be stored in a directory named\n        `stepN` where `N` is the step number, starting at 0.\n    fn_hook\n        A custom function to call after each step of the optimization.\n        The function must take the instantiated dynamics class as\n        its only argument.\n    run_kwargs\n        Dictionary of kwargs for the `run()` method of the optimizer.\n    filter_kwargs\n        Dictionary of kwargs for the `FrechetCellFilter` if relax_cell is True.\n\n    Returns\n    -------\n    Optimizer\n        The ASE Optimizer object following an optimization.\n    \"\"\"\n    # Set defaults\n    merged_optimizer_kwargs = recursive_dict_merge(\n        {\n            \"logfile\": self.tmpdir / \"opt.log\",\n            \"restart\": str(self.tmpdir / \"opt.json\"),\n        },\n        optimizer_kwargs,\n    )\n    run_kwargs = run_kwargs or {}\n    filter_kwargs = filter_kwargs or {}\n    traj_filename = \"opt.traj\"\n\n    # Check if trajectory kwarg is specified\n    if \"trajectory\" in merged_optimizer_kwargs:\n        msg = \"Quacc does not support setting the `trajectory` kwarg.\"\n        raise ValueError(msg)\n\n    # Handle optimizer kwargs\n    if (\n        issubclass(optimizer, SciPyOptimizer | MolecularDynamics)\n        or optimizer.__name__ == \"IRC\"\n    ):\n        # https://gitlab.com/ase/ase/-/issues/1476\n        # https://gitlab.com/ase/ase/-/merge_requests/3310\n        merged_optimizer_kwargs.pop(\"restart\", None)\n    if optimizer.__name__ == \"Sella\":\n        self._set_sella_kwargs(merged_optimizer_kwargs)\n\n    # Define the Trajectory object\n    traj_file = self.tmpdir / traj_filename\n    traj = Trajectory(traj_file, \"w\", atoms=self.atoms)\n    merged_optimizer_kwargs[\"trajectory\"] = traj\n\n    # Set volume relaxation constraints, if relevant\n    if relax_cell and self.atoms.pbc.any():\n        self.atoms = FrechetCellFilter(self.atoms, **filter_kwargs)\n\n    # Define run kwargs\n    full_run_kwargs = {\"steps\": max_steps, **run_kwargs}\n    if not issubclass(optimizer, MolecularDynamics):\n        full_run_kwargs[\"fmax\"] = fmax\n\n    # Run optimization\n    try:\n        with traj, optimizer(self.atoms, **merged_optimizer_kwargs) as dyn:\n            if issubclass(optimizer, SciPyOptimizer):\n                # https://gitlab.com/ase/ase/-/issues/1475\n                dyn.run(**full_run_kwargs)\n            else:\n                for i, _ in enumerate(dyn.irun(**full_run_kwargs)):\n                    if store_intermediate_results:\n                        self._copy_intermediate_files(\n                            i,\n                            files_to_ignore=[\n                                traj_file,\n                                merged_optimizer_kwargs.get(\"restart\"),\n                                merged_optimizer_kwargs.get(\"logfile\"),\n                            ],\n                        )\n                    if fn_hook:\n                        fn_hook(dyn)\n    except Exception as exception:\n        terminate(self.tmpdir, exception)\n\n    # Perform cleanup operations\n    self.cleanup()\n    traj.filename = zpath(str(self.job_results_dir / traj_filename))\n    dyn.trajectory = traj\n\n    return dyn\n</code></pre>"},{"location":"reference/quacc/runners/ase.html#quacc.runners.ase.Runner.run_vib","title":"run_vib","text":"<pre><code>run_vib(vib_kwargs: VibKwargs | None = None) -&gt; Vibrations\n</code></pre> <p>Run an ASE-based vibration analysis in a scratch directory and copy the results back to the original directory. This can be useful if file I/O is slow in the working directory, so long as file transfer speeds are reasonable.</p> <p>This is a wrapper around the vibrations module in ASE.</p> <p>Parameters:</p> <ul> <li> <code>vib_kwargs</code>               (<code>VibKwargs | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the ase.vibrations.Vibrations class.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vibrations</code>           \u2013            <p>The updated Vibrations module</p> </li> </ul> Source code in <code>quacc/runners/ase.py</code> <pre><code>def run_vib(self, vib_kwargs: VibKwargs | None = None) -&gt; Vibrations:\n    \"\"\"\n    Run an ASE-based vibration analysis in a scratch directory and copy the results back\n    to the original directory. This can be useful if file I/O is slow in the working\n    directory, so long as file transfer speeds are reasonable.\n\n    This is a wrapper around the vibrations module in ASE.\n\n    Parameters\n    ----------\n    vib_kwargs\n        Dictionary of kwargs for the [ase.vibrations.Vibrations][] class.\n\n    Returns\n    -------\n    Vibrations\n        The updated Vibrations module\n    \"\"\"\n    # Set defaults\n    vib_kwargs = vib_kwargs or {}\n\n    # Run calculation\n    vib = Vibrations(self.atoms, name=str(self.tmpdir / \"vib\"), **vib_kwargs)\n    try:\n        vib.run()\n    except Exception as exception:\n        terminate(self.tmpdir, exception)\n\n    # Summarize run\n    vib.summary(log=str(self.tmpdir / \"vib_summary.log\"))\n\n    # Perform cleanup operations\n    self.cleanup()\n\n    return vib\n</code></pre>"},{"location":"reference/quacc/runners/generic.html","title":"generic","text":"<p>Class to run generic commands in a subprocess.</p>"},{"location":"reference/quacc/runners/generic.html#quacc.runners.generic.GenericRunner","title":"GenericRunner","text":"<pre><code>GenericRunner(\n    command: str,\n    copy_files: SourceDirectory | Copy | None = None,\n    environment: dict[str, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseRunner</code></p> <p>A class to run generic (IO) commands in a subprocess. Inherits from BaseRunner, which handles setup and cleanup of the calculation.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The command to run in the subprocess.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy to the runtime directory.</p> </li> <li> <code>environment</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables to set for the subprocess. If None, the current environment is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/runners/generic.py</code> <pre><code>def __init__(\n    self,\n    command: str,\n    copy_files: SourceDirectory | Copy | None = None,\n    environment: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the `GenericRunner` with the command and optional copy files and environment variables.\n\n    Parameters\n    ----------\n    command\n        The command to run in the subprocess.\n    copy_files\n        Files to copy to the runtime directory.\n    environment\n        Environment variables to set for the subprocess. If None, the current environment is used.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.command: Final[list[str]] = split(command)\n    self.environment = environment\n\n    super().__init__()\n\n    self.setup(copy_files=copy_files)\n</code></pre>"},{"location":"reference/quacc/runners/generic.html#quacc.runners.generic.GenericRunner.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: Final[list[str]] = split(command)\n</code></pre>"},{"location":"reference/quacc/runners/generic.html#quacc.runners.generic.GenericRunner.environment","title":"environment  <code>instance-attribute</code>","text":"<pre><code>environment = environment\n</code></pre>"},{"location":"reference/quacc/runners/generic.html#quacc.runners.generic.GenericRunner.filepaths","title":"filepaths  <code>class-attribute</code>","text":"<pre><code>filepaths: dict[str, SourceDirectory | None] = {\n    \"fd_out\": None,\n    \"fd_err\": None,\n}\n</code></pre>"},{"location":"reference/quacc/runners/generic.html#quacc.runners.generic.GenericRunner.run_cmd","title":"run_cmd","text":"<pre><code>run_cmd() -&gt; CompletedProcess\n</code></pre> <p>Run a command in a subprocess.</p> <p>Returns:</p> <ul> <li> <code>CompletedProcess</code>           \u2013            <p>The result of the subprocess execution.</p> </li> </ul> Source code in <code>quacc/runners/generic.py</code> <pre><code>def run_cmd(self) -&gt; CompletedProcess:\n    \"\"\"\n    Run a command in a subprocess.\n\n    Returns\n    -------\n    CompletedProcess\n        The result of the subprocess execution.\n    \"\"\"\n    with ExitStack() as stack:\n        files = {\n            name: stack.enter_context(Path(self.tmpdir, path).open(\"w\"))\n            for name, path in self.filepaths.items()\n            if path is not None\n        }\n\n        cmd_results = run(\n            self.command,\n            cwd=self.tmpdir,\n            shell=False,\n            check=True,\n            env=self.environment if self.environment is not None else os.environ,\n            stdout=files.get(\"fd_out\", PIPE),\n            stderr=files.get(\"fd_err\", PIPE),\n            text=True,\n        )\n\n    self.cleanup()\n    return cmd_results\n</code></pre>"},{"location":"reference/quacc/runners/phonons.html","title":"phonons","text":""},{"location":"reference/quacc/runners/phonons.html#quacc.runners.phonons.has_phonopy","title":"has_phonopy  <code>module-attribute</code>","text":"<pre><code>has_phonopy = bool(find_spec('phonopy'))\n</code></pre>"},{"location":"reference/quacc/runners/phonons.html#quacc.runners.phonons.has_seekpath","title":"has_seekpath  <code>module-attribute</code>","text":"<pre><code>has_seekpath = bool(find_spec('seekpath'))\n</code></pre>"},{"location":"reference/quacc/runners/phonons.html#quacc.runners.phonons.PhonopyRunner","title":"PhonopyRunner","text":"<pre><code>PhonopyRunner()\n</code></pre> <p>               Bases: <code>BaseRunner</code></p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/runners/phonons.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the PhonopyRunner.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.setup()\n</code></pre>"},{"location":"reference/quacc/runners/phonons.html#quacc.runners.phonons.PhonopyRunner.run_phonopy","title":"run_phonopy","text":"<pre><code>run_phonopy(\n    phonon: Phonopy,\n    forces: NDArray,\n    symmetrize: bool = False,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n) -&gt; Phonopy\n</code></pre> <p>Run a phonopy calculation in a temporary directory and copy the results to the job results directory.</p> <p>Parameters:</p> <ul> <li> <code>phonon</code>               (<code>Phonopy</code>)           \u2013            <p>Phonopy object</p> </li> <li> <code>forces</code>               (<code>NDArray</code>)           \u2013            <p>Forces on the atoms</p> </li> <li> <code>symmetrize</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to symmetrize the force constants</p> </li> <li> <code>t_step</code>               (<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Temperature step</p> </li> <li> <code>t_min</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Minimum temperature</p> </li> <li> <code>t_max</code>               (<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>Maximum temperature</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Phonopy</code>           \u2013            <p>The phonopy object with the results.</p> </li> </ul> Source code in <code>quacc/runners/phonons.py</code> <pre><code>@requires(has_phonopy, \"Phonopy is not installed.\")\n@requires(has_seekpath, \"Seekpath is not installed\")\ndef run_phonopy(\n    self,\n    phonon: Phonopy,\n    forces: NDArray,\n    symmetrize: bool = False,\n    t_step: float = 10,\n    t_min: float = 0,\n    t_max: float = 1000,\n) -&gt; Phonopy:\n    \"\"\"\n    Run a phonopy calculation in a temporary directory and\n    copy the results to the job results directory.\n\n    Parameters\n    ----------\n    phonon\n        Phonopy object\n    forces\n        Forces on the atoms\n    symmetrize\n        Whether to symmetrize the force constants\n    t_step\n        Temperature step\n    t_min\n        Minimum temperature\n    t_max\n        Maximum temperature\n\n    Returns\n    -------\n    Phonopy\n        The phonopy object with the results.\n    \"\"\"\n\n    # Run phonopy\n    phonon.forces = forces\n    phonon.produce_force_constants()\n\n    if symmetrize:\n        phonon.symmetrize_force_constants()\n        phonon.symmetrize_force_constants_by_space_group()\n\n    phonon.run_mesh(with_eigenvectors=True)\n    phonon.run_total_dos()\n    phonon.run_thermal_properties(t_step=t_step, t_max=t_max, t_min=t_min)\n    phonon.auto_band_structure(\n        write_yaml=True,\n        filename=Path(self.tmpdir, \"phonopy_auto_band_structure.yaml\"),\n    )\n    phonon.save(\n        Path(self.tmpdir, \"phonopy.yaml\"), settings={\"force_constants\": True}\n    )\n    phonon.directory = self.job_results_dir\n\n    # Perform cleanup operations\n    self.cleanup()\n\n    return phonon\n</code></pre>"},{"location":"reference/quacc/runners/prep.html","title":"prep","text":"<p>Prepration for runners.</p>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.calc_cleanup","title":"calc_cleanup","text":"<pre><code>calc_cleanup(\n    atoms: Atoms | None,\n    tmpdir: Path | str,\n    job_results_dir: Path | str,\n) -&gt; None\n</code></pre> <p>Perform cleanup operations for a calculation, including gzipping files, copying files back to the original directory, and removing the tmpdir.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | None</code>)           \u2013            <p>The Atoms object after the calculation. Must have a calculator attached. If None, no modifications to the calculator's directory will be made.</p> </li> <li> <code>tmpdir</code>               (<code>Path | str</code>)           \u2013            <p>The path to the tmpdir, where the calculation will be run. It will be deleted after the calculation is complete.</p> </li> <li> <code>job_results_dir</code>               (<code>Path | str</code>)           \u2013            <p>The path to the job_results_dir, where the files will ultimately be stored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def calc_cleanup(\n    atoms: Atoms | None, tmpdir: Path | str, job_results_dir: Path | str\n) -&gt; None:\n    \"\"\"\n    Perform cleanup operations for a calculation, including gzipping files, copying\n    files back to the original directory, and removing the tmpdir.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object after the calculation. Must have a calculator\n        attached. If None, no modifications to the calculator's directory will be made.\n    tmpdir\n        The path to the tmpdir, where the calculation will be run. It will be\n        deleted after the calculation is complete.\n    job_results_dir\n        The path to the job_results_dir, where the files will ultimately be\n        stored.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    job_results_dir, tmpdir = Path(job_results_dir), Path(tmpdir)\n    settings = get_settings()\n\n    # Safety check\n    tmpdir_base = (settings.SCRATCH_DIR or settings.RESULTS_DIR).resolve()\n    if not (\n        tmpdir.is_relative_to(tmpdir_base)\n        and tmpdir.relative_to(tmpdir_base).parts[0].startswith(\"tmp-\")\n    ):\n        msg = f\"{tmpdir} does not appear to be a tmpdir... exiting for safety!\"\n        raise ValueError(msg)\n\n    # Update the calculator's directory\n    if atoms is not None:\n        atoms.calc.directory = job_results_dir\n\n    # Gzip files in tmpdir\n    if settings.GZIP_FILES:\n        gzip_dir(tmpdir)\n\n    # Move files from tmpdir to job_results_dir.\n    LOGGER.info(f\"Moving {tmpdir} contents to {job_results_dir}\")\n    job_results_dir.mkdir(parents=True, exist_ok=True)\n    for file_name in os.listdir(tmpdir):\n        move(tmpdir / file_name, job_results_dir / file_name)\n\n    if not any(tmpdir.iterdir()):\n        tmpdir.rmdir()\n\n    LOGGER.info(f\"Calculation results stored at {job_results_dir}\")\n\n    # Remove symlink to tmpdir\n    if os.name != \"nt\" and settings.SCRATCH_DIR:\n        symlink_path = settings.RESULTS_DIR / f\"symlink-{tmpdir.name}\"\n        symlink_path.unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.calc_setup","title":"calc_setup","text":"<pre><code>calc_setup(\n    atoms: Atoms | None,\n    copy_files: SourceDirectory | Copy | None = None,\n) -&gt; tuple[Path, Path]\n</code></pre> <p>Perform staging operations for a calculation, including copying files to the scratch directory, setting the calculator's directory, decompressing files, and creating a symlink to the scratch directory.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms | None</code>)           \u2013            <p>The Atoms object to run the calculation on. Must have a calculator attached. If None, no modifications to the calculator's directory will be made.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | Copy | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>The path to the unique tmpdir, where the calculation will be run. It will be deleted after the calculation is complete. By default, this will be located within <code>QuaccSettings.SCRATCH_DIR</code>, but if that is not set, it will be located within the <code>QuaccSettings.RESULTS_DIR</code>. For convenience, a symlink to this directory will be made in the <code>QuaccSettings.RESULTS_DIR</code>.</p> </li> <li> <code>Path</code>           \u2013            <p>The path to the results_dir, where the files will ultimately be stored. By default, this will be the <code>QuaccSettings.RESULTS_DIR</code>, but if <code>QuaccSettings.CREATE_UNIQUE_DIR</code> is set, it will be a unique directory within the <code>QuaccSettings.RESULTS_DIR</code>.</p> </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def calc_setup(\n    atoms: Atoms | None, copy_files: SourceDirectory | Copy | None = None\n) -&gt; tuple[Path, Path]:\n    \"\"\"\n    Perform staging operations for a calculation, including copying files to the scratch\n    directory, setting the calculator's directory, decompressing files, and creating a\n    symlink to the scratch directory.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to run the calculation on. Must have a calculator\n        attached. If None, no modifications to the calculator's directory will be made.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    Path\n        The path to the unique tmpdir, where the calculation will be run. It will be\n        deleted after the calculation is complete. By default, this will be\n        located within `QuaccSettings.SCRATCH_DIR`, but if that is not set, it will\n        be located within the `QuaccSettings.RESULTS_DIR`. For convenience, a symlink\n        to this directory will be made in the `QuaccSettings.RESULTS_DIR`.\n    Path\n        The path to the results_dir, where the files will ultimately be stored.\n        By default, this will be the `QuaccSettings.RESULTS_DIR`, but if\n        `QuaccSettings.CREATE_UNIQUE_DIR` is set, it will be a unique directory\n        within the `QuaccSettings.RESULTS_DIR`.\n    \"\"\"\n    # Create a tmpdir for the calculation\n    settings = get_settings()\n    tmpdir_base = (settings.SCRATCH_DIR or settings.RESULTS_DIR).resolve()\n\n    if settings.NESTED_RESULTS:\n        # Define the results directory.\n        # When NESTED_RESULTS is active, the context module provides both a root\n        # directory (directory_context) and a relative path (context_path) that\n        # mirrors the flow/subflow/job nesting.\n        if Path(get_directory_context()).is_relative_to(settings.RESULTS_DIR):\n            # The directory context is already under RESULTS_DIR (normal case).\n            job_results_dir = settings.RESULTS_DIR / Path(get_directory_context())\n            job_results_dir = job_results_dir / get_context_path()\n        else:\n            # RESULTS_DIR was overridden (e.g. via swap_settings); use it as the\n            # base and append only the context path.\n            job_results_dir = settings.RESULTS_DIR / get_context_path()\n\n        # Create a temporary directory with the same internal structure as job results, but with \"tmp-\" in its\n        # top-level directory name. Place it at `tmpdir_base`.\n        tmpdir = tmpdir_base / Path(\n            \"tmp-\" + str(job_results_dir.relative_to(settings.RESULTS_DIR))\n        )\n        tmpdir.mkdir(parents=True, exist_ok=True)\n    else:\n        tmpdir = make_unique_dir(base_path=tmpdir_base, prefix=\"tmp-quacc-\")\n        job_results_dir = settings.RESULTS_DIR.resolve()\n        if settings.CREATE_UNIQUE_DIR:\n            job_results_dir /= f\"{tmpdir.name.split('tmp-')[-1]}\"\n\n    LOGGER.info(f\"Calculation will run at {tmpdir}\")\n\n    # Set the calculator's directory\n    if atoms is not None:\n        atoms.calc.directory = tmpdir\n\n    # Create a symlink to the tmpdir\n    if os.name != \"nt\" and settings.SCRATCH_DIR:\n        symlink_path = settings.RESULTS_DIR / f\"symlink-{tmpdir.name}\"\n        symlink_path.symlink_to(tmpdir, target_is_directory=True)\n\n    # Copy files to tmpdir and decompress them if needed\n    if copy_files is not None:\n        if hasattr(copy_files, \"do_copy\"):\n            copy_files.do_copy(tmpdir)\n        elif isinstance(copy_files, dict):\n            for k, v in copy_files.items():\n                copy_decompress_files(k, v, tmpdir)\n\n    return tmpdir.resolve(), job_results_dir.resolve()\n</code></pre>"},{"location":"reference/quacc/runners/prep.html#quacc.runners.prep.terminate","title":"terminate","text":"<pre><code>terminate(tmpdir: Path | str, exception: Exception) -&gt; None\n</code></pre> <p>Terminate a calculation and move files to a failed directory.</p> <p>Parameters:</p> <ul> <li> <code>tmpdir</code>               (<code>Path | str</code>)           \u2013            <p>The path to the tmpdir, where the calculation was run.</p> </li> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>The exception that caused the calculation to fail.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>JobFailure</code>             \u2013            <p>The exception that caused the calculation to fail plus additional metadata.</p> </li> </ul> Source code in <code>quacc/runners/prep.py</code> <pre><code>def terminate(tmpdir: Path | str, exception: Exception) -&gt; None:\n    \"\"\"\n    Terminate a calculation and move files to a failed directory.\n\n    Parameters\n    ----------\n    tmpdir\n        The path to the tmpdir, where the calculation was run.\n    exception\n        The exception that caused the calculation to fail.\n\n    Returns\n    -------\n    None\n\n    Raises\n    -------\n    JobFailure\n        The exception that caused the calculation to fail plus additional\n        metadata.\n    \"\"\"\n    settings = get_settings()\n    tmpdir = Path(tmpdir)\n    job_failed_dir = tmpdir.with_name(\"failed-\" + tmpdir.name.replace(\"tmp-\", \"\"))\n    tmpdir.rename(job_failed_dir)\n\n    msg = f\"Calculation failed! Files stored at {job_failed_dir}\"\n    LOGGER.info(msg)\n\n    if os.name != \"nt\" and settings.SCRATCH_DIR:\n        old_symlink_path = settings.RESULTS_DIR / f\"symlink-{tmpdir.name}\"\n        symlink_path = settings.RESULTS_DIR / f\"symlink-{job_failed_dir.name}\"\n        old_symlink_path.unlink(missing_ok=True)\n        symlink_path.symlink_to(job_failed_dir, target_is_directory=True)\n\n    raise JobFailure(job_failed_dir, message=msg, parent_error=exception) from exception\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html","title":"ase","text":"<p>Schemas for storing ASE-based data.</p>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize","title":"Summarize","text":"<pre><code>Summarize(\n    directory: str | Path | None = None,\n    move_magmoms: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n)\n</code></pre> <p>Get tabulated results from an Atoms object and calculator and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the directory where the calculation was run and results were stored.</p> </li> <li> <code>move_magmoms</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to move the final magmoms of the original Atoms object to the initial magmoms of the returned Atoms object, if relevant.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def __init__(\n    self,\n    directory: str | Path | None = None,\n    move_magmoms: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Summarize object.\n\n    Parameters\n    ----------\n    directory\n        Path to the directory where the calculation was run and results were stored.\n    move_magmoms\n        Whether to move the final magmoms of the original Atoms object to the\n        initial magmoms of the returned Atoms object, if relevant.\n    additional_fields\n        Additional fields to add to the task document.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.directory = directory\n    self.move_magmoms = move_magmoms\n    self.additional_fields = additional_fields or {}\n    self._settings = get_settings()\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.additional_fields","title":"additional_fields  <code>instance-attribute</code>","text":"<pre><code>additional_fields = additional_fields or {}\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.directory","title":"directory  <code>instance-attribute</code>","text":"<pre><code>directory = directory\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.move_magmoms","title":"move_magmoms  <code>instance-attribute</code>","text":"<pre><code>move_magmoms = move_magmoms\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.md","title":"md","text":"<pre><code>md(\n    dyn: MolecularDynamics,\n    trajectory: list[Atoms] | None = None,\n) -&gt; DynSchema\n</code></pre> <p>Get tabulated results from an ASE MD run.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>               (<code>MolecularDynamics</code>)           \u2013            <p>ASE MolecularDynamics object.</p> </li> <li> <code>trajectory</code>               (<code>list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>ASE Trajectory object or list[Atoms] from reading a trajectory file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DynSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def md(\n    self, dyn: MolecularDynamics, trajectory: list[Atoms] | None = None\n) -&gt; DynSchema:\n    \"\"\"\n    Get tabulated results from an ASE MD run.\n\n    Parameters\n    ----------\n    dyn\n        ASE MolecularDynamics object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file.\n\n    Returns\n    -------\n    DynSchema\n        Dictionary representation of the task document\n    \"\"\"\n    # Check and set up variables\n    base_task_doc = self.opt(dyn, trajectory=trajectory, check_convergence=False)\n    del base_task_doc[\"converged\"]\n\n    # Clean up the opt parameters\n    parameters_md = base_task_doc.pop(\"parameters_opt\")\n    parameters_md.pop(\"logfile\", None)\n\n    trajectory_log = []\n    for t, atoms in enumerate(base_task_doc[\"trajectory\"]):\n        trajectory_log.append(\n            {\n                \"kinetic_energy\": atoms.get_kinetic_energy(),\n                \"temperature\": atoms.get_temperature(),\n                \"time\": t * parameters_md[\"timestep\"],\n            }\n        )\n\n    md_fields = {\"parameters_md\": parameters_md, \"trajectory_log\": trajectory_log}\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = base_task_doc | md_fields | self.additional_fields\n\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.neb","title":"neb","text":"<pre><code>neb(\n    dyn: Optimizer,\n    n_images: int,\n    n_iter_return: int = -1,\n    trajectory: (\n        TrajectoryWriter | list[Atoms] | None\n    ) = None,\n) -&gt; OptSchema\n</code></pre> <p>Summarize the NEB run results and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>               (<code>Optimizer</code>)           \u2013            <p>ASE Optimizer object used for the NEB run.</p> </li> <li> <code>n_images</code>               (<code>int</code>)           \u2013            <p>Number of images in the NEB run.</p> </li> <li> <code>n_iter_return</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            <p>Number of iterations to return. If -1, all iterations are returned.</p> </li> <li> <code>trajectory</code>               (<code>TrajectoryWriter | list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>Trajectory of the NEB run, either as a Trajectory object or a list of Atoms objects.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>A dictionary containing the summarized NEB run results.</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def neb(\n    self,\n    dyn: Optimizer,\n    n_images: int,\n    n_iter_return: int = -1,\n    trajectory: TrajectoryWriter | list[Atoms] | None = None,\n) -&gt; OptSchema:\n    \"\"\"\n    Summarize the NEB run results and store them in a database-friendly format.\n\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object used for the NEB run.\n    n_images\n        Number of images in the NEB run.\n    n_iter_return\n        Number of iterations to return. If -1, all iterations are returned.\n    trajectory\n        Trajectory of the NEB run, either as a Trajectory object or a list of Atoms objects.\n\n    Returns\n    -------\n    OptSchema\n        A dictionary containing the summarized NEB run results.\n    \"\"\"\n\n    # Get trajectory\n    atoms_trajectory = (\n        trajectory or read(dyn.trajectory, index=\":\")\n        if isinstance(dyn.trajectory, (str, Path))\n        else read(dyn.trajectory.filename, index=\":\")\n    )\n\n    if n_iter_return == -1:\n        atoms_trajectory = atoms_trajectory[-(n_images):]\n    else:\n        atoms_trajectory = _get_nth_iteration(\n            atoms_trajectory,\n            int(len(atoms_trajectory) / n_images),\n            n_images,\n            n_iter_return,\n        )\n    trajectory_results = [atoms.calc.results for atoms in atoms_trajectory]\n    ts_index = (\n        np.argmax(\n            [\n                result[\"energy\"]\n                for result in trajectory_results[-(n_images - 1) : -1]\n            ]\n        )\n        + 1\n    )\n    ts_atoms = atoms_trajectory[ts_index]\n    base_task_doc = atoms_to_metadata(atoms_trajectory[0])\n\n    # Clean up the opt parameters\n    parameters_opt = dyn.todict()\n    parameters_opt.pop(\"logfile\", None)\n    parameters_opt.pop(\"restart\", None)\n\n    opt_fields = {\n        \"parameters_opt\": parameters_opt,\n        \"trajectory\": atoms_trajectory,\n        \"trajectory_results\": trajectory_results,\n        \"ts_atoms\": ts_atoms,\n    }\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = base_task_doc | opt_fields | self.additional_fields\n\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.opt","title":"opt","text":"<pre><code>opt(\n    dyn: Optimizer,\n    trajectory: list[Atoms] | None = None,\n    check_convergence: bool | DefaultSetting = QuaccDefault,\n) -&gt; OptSchema\n</code></pre> <p>Get tabulated results from an ASE optimization.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>               (<code>Optimizer</code>)           \u2013            <p>ASE Optimizer object.</p> </li> <li> <code>trajectory</code>               (<code>list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>ASE Trajectory object or list[Atoms] from reading a trajectory file.</p> </li> <li> <code>check_convergence</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether to check the convergence of the calculation. Defaults to True in settings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def opt(\n    self,\n    dyn: Optimizer,\n    trajectory: list[Atoms] | None = None,\n    check_convergence: bool | DefaultSetting = QuaccDefault,\n) -&gt; OptSchema:\n    \"\"\"\n    Get tabulated results from an ASE optimization.\n\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file.\n    check_convergence\n        Whether to check the convergence of the calculation. Defaults to True in\n        settings.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    # Check and set up variables\n    check_convergence = (\n        self._settings.CHECK_CONVERGENCE\n        if check_convergence == QuaccDefault\n        else check_convergence\n    )\n\n    # Get trajectory\n    atoms_trajectory = (\n        trajectory or read(dyn.trajectory, index=\":\")\n        if isinstance(dyn.trajectory, (str, Path))\n        else read(dyn.trajectory.filename, index=\":\")\n    )\n    trajectory_results = [atoms.calc.results for atoms in atoms_trajectory]\n\n    initial_atoms = atoms_trajectory[0]\n    final_atoms = get_final_atoms_from_dynamics(dyn)\n    directory = self.directory or final_atoms.calc.directory\n\n    # Check convergence\n    gradient = (\n        dyn.optimizable.get_gradient() if hasattr(dyn, \"optimizable\") else None\n    )\n    is_converged = dyn.converged(gradient)\n    if check_convergence and not is_converged:\n        msg = f\"Optimization did not converge. Refer to {directory}\"\n        raise RuntimeError(msg)\n\n    # Base task doc\n    base_task_doc = self.run(final_atoms, initial_atoms)\n\n    # Clean up the opt parameters\n    parameters_opt = dyn.todict()\n    parameters_opt.pop(\"logfile\", None)\n    parameters_opt.pop(\"restart\", None)\n\n    opt_fields = {\n        \"parameters_opt\": parameters_opt,\n        \"converged\": is_converged,\n        \"trajectory\": atoms_trajectory,\n        \"trajectory_results\": trajectory_results,\n    }\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = base_task_doc | opt_fields | self.additional_fields\n\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.Summarize.run","title":"run","text":"<pre><code>run(final_atoms: Atoms, input_atoms: Atoms) -&gt; RunSchema\n</code></pre> <p>Get tabulated results from a standard ASE run.</p> <p>Parameters:</p> <ul> <li> <code>final_atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms following a calculation. A calculator must be attached.</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>Input ASE Atoms object to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def run(self, final_atoms: Atoms, input_atoms: Atoms) -&gt; RunSchema:\n    \"\"\"\n    Get tabulated results from a standard ASE run.\n\n    Parameters\n    ----------\n    final_atoms\n        ASE Atoms following a calculation. A calculator must be attached.\n    input_atoms\n        Input ASE Atoms object to store.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary representation of the task document\n    \"\"\"\n\n    # Check and set up variables\n    if not final_atoms.calc:\n        msg = \"ASE Atoms object has no attached calculator.\"\n        raise ValueError(msg)\n    if not final_atoms.calc.results:\n        msg = \"ASE Atoms object's calculator has no results.\"\n        raise ValueError(msg)\n\n    directory = self.directory or final_atoms.calc.directory\n\n    # Generate input atoms metadata\n    input_atoms_metadata = atoms_to_metadata(input_atoms) if input_atoms else {}\n\n    # Generate the base of the task document\n    inputs = {\n        \"parameters\": final_atoms.calc.parameters,\n        \"nid\": get_uri(directory).split(\":\")[0],\n        \"dir_name\": directory,\n        \"input_atoms\": input_atoms_metadata,\n        \"quacc_version\": __version__,\n    }\n    results = {\"results\": final_atoms.calc.results}\n\n    # Prepare atoms for the next run\n    atoms_to_store = prep_next_run(final_atoms, move_magmoms=self.move_magmoms)\n\n    # Generate final atoms metadata\n    final_atoms_metadata = atoms_to_metadata(atoms_to_store) if final_atoms else {}\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = (\n        final_atoms_metadata | inputs | results | self.additional_fields\n    )\n\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.VibSummarize","title":"VibSummarize","text":"<pre><code>VibSummarize(\n    vib_object: Vibrations | VibrationsData,\n    directory: str | Path | None = None,\n    additional_fields: dict[str, Any] | None = None,\n)\n</code></pre> <p>Summarize an ASE Vibrations analysis.</p> <p>Parameters:</p> <ul> <li> <code>vib_object</code>               (<code>Vibrations | VibrationsData</code>)           \u2013            <p>Instantiated ASE Vibrations object.</p> </li> <li> <code>directory</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the directory where the results will be stored.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def __init__(\n    self,\n    vib_object: Vibrations | VibrationsData,\n    directory: str | Path | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Summarize object.\n\n    Parameters\n    ----------\n    vib_object\n        Instantiated ASE Vibrations object.\n    directory\n        Path to the directory where the results will be stored.\n    additional_fields\n        Additional fields to add to the task document.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.vib_object = vib_object\n    self.directory = directory or \".\"\n    self.additional_fields = additional_fields or {}\n    self._settings = get_settings()\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.VibSummarize.additional_fields","title":"additional_fields  <code>instance-attribute</code>","text":"<pre><code>additional_fields = additional_fields or {}\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.VibSummarize.directory","title":"directory  <code>instance-attribute</code>","text":"<pre><code>directory = directory or '.'\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.VibSummarize.vib_object","title":"vib_object  <code>instance-attribute</code>","text":"<pre><code>vib_object = vib_object\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.VibSummarize.vib","title":"vib","text":"<pre><code>vib(*, is_molecule: bool) -&gt; VibSchema\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and store them in a database- friendly format.</p> <p>Parameters:</p> <ul> <li> <code>is_molecule</code>               (<code>bool</code>)           \u2013            <p>Whether the Atoms object is a molecule. If True, the vibrational modes are sorted by their absolute value and the 3N-5 or 3N-6 modes are taken. If False, all vibrational modes are taken.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def vib(self, *, is_molecule: bool) -&gt; VibSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations object and store them in a database-\n    friendly format.\n\n    Parameters\n    ----------\n    is_molecule\n        Whether the Atoms object is a molecule. If True, the vibrational modes are\n        sorted by their absolute value and the 3N-5 or 3N-6 modes are taken. If False,\n        all vibrational modes are taken.\n\n    Returns\n    -------\n    VibSchema\n        Dictionary representation of the task document\n    \"\"\"\n    # Tabulate input parameters\n    vib_freqs_raw = self.vib_object.get_frequencies().tolist()\n    vib_energies_raw = self.vib_object.get_energies().tolist()\n    if isinstance(self.vib_object, VibrationsData):\n        atoms = self.vib_object._atoms\n        directory = self.directory\n        inputs = {\"nid\": get_uri(directory).split(\":\")[0], \"dir_name\": directory}\n    else:\n        atoms = self.vib_object.atoms\n        directory = self.directory or atoms.calc.directory\n        inputs = {\n            \"parameters\": atoms.calc.parameters,\n            \"parameters_vib\": {\n                \"delta\": self.vib_object.delta,\n                \"direction\": self.vib_object.direction,\n                \"method\": self.vib_object.method,\n                \"ndof\": self.vib_object.ndof,\n                \"nfree\": self.vib_object.nfree,\n            },\n            \"nid\": get_uri(directory).split(\":\")[0],\n            \"dir_name\": directory,\n            \"quacc_version\": __version__,\n        }\n\n    # Convert imaginary modes to negative values for DB storage\n    for i, f in enumerate(vib_freqs_raw):\n        if np.imag(f) &gt; 0:\n            vib_freqs_raw[i] = -np.abs(f)\n            vib_energies_raw[i] = -np.abs(vib_energies_raw[i])\n        else:\n            vib_freqs_raw[i] = np.abs(f)\n            vib_energies_raw[i] = np.abs(vib_energies_raw[i])\n\n    # Get the true vibrational modes\n    atoms_metadata = atoms_to_metadata(atoms)\n\n    natoms = len(atoms)\n    if natoms == 1:\n        vib_freqs = []\n        vib_energies = []\n    elif is_molecule:\n        is_linear = (\n            PointGroupData()\n            .from_molecule(AseAtomsAdaptor().get_molecule(atoms))\n            .linear\n            if atoms.pbc.any()\n            else atoms_metadata[\"molecule_metadata\"][\"symmetry\"][\"linear\"]\n        )\n\n        # Sort by absolute value\n        vib_freqs_raw_sorted = vib_freqs_raw.copy()\n        vib_energies_raw_sorted = vib_energies_raw.copy()\n        vib_freqs_raw_sorted.sort(key=np.abs)\n        vib_energies_raw_sorted.sort(key=np.abs)\n\n        # Cut the 3N-5 or 3N-6 modes based on their absolute value\n        n_modes = 3 * natoms - 5 if is_linear else 3 * natoms - 6\n        vib_freqs = vib_freqs_raw_sorted[-n_modes:]\n        vib_energies = vib_energies_raw_sorted[-n_modes:]\n    else:\n        vib_freqs = vib_freqs_raw\n        vib_energies = vib_energies_raw\n\n    imag_vib_freqs = [f for f in vib_freqs if f &lt; 0]\n\n    vib_results = {\n        \"results\": {\n            \"imag_vib_freqs\": imag_vib_freqs,\n            \"n_imag\": len(imag_vib_freqs),\n            \"vib_energies\": vib_energies,\n            \"vib_freqs\": vib_freqs,\n            \"vib_energies_raw\": vib_energies_raw,\n            \"vib_freqs_raw\": vib_freqs_raw,\n        }\n    }\n    unsorted_task_doc = (\n        atoms_metadata | inputs | vib_results | self.additional_fields\n    )\n\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/ase.html#quacc.schemas.ase.VibSummarize.vib_and_thermo","title":"vib_and_thermo","text":"<pre><code>vib_and_thermo(\n    thermo_method: Literal[\"ideal_gas\", \"harmonic\"],\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n) -&gt; VibThermoSchema\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and thermochemistry.</p> <p>Parameters:</p> <ul> <li> <code>thermo_method</code>               (<code>Literal['ideal_gas', 'harmonic']</code>)           \u2013            <p>Method to use for thermochemistry calculations. If None, no thermochemistry calculations are performed.</p> </li> <li> <code>energy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Potential energy in eV used as the reference point for thermochemistry calculations.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in K for thermochemistry calculations.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in atm for thermochemistry calculations</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/ase.py</code> <pre><code>def vib_and_thermo(\n    self,\n    thermo_method: Literal[\"ideal_gas\", \"harmonic\"],\n    energy: float = 0.0,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations object and thermochemistry.\n\n    Parameters\n    ----------\n    thermo_method\n        Method to use for thermochemistry calculations. If None, no thermochemistry\n        calculations are performed.\n    energy\n        Potential energy in eV used as the reference point for thermochemistry calculations.\n    temperature\n        Temperature in K for thermochemistry calculations.\n    pressure\n        Pressure in atm for thermochemistry calculations\n\n    Returns\n    -------\n    VibThermoSchema\n        Dictionary representation of the task document\n    \"\"\"\n    atoms = (\n        self.vib_object._atoms\n        if isinstance(self.vib_object, VibrationsData)\n        else self.vib_object.atoms\n    )\n    is_molecule = bool(thermo_method == \"ideal_gas\")\n\n    # Generate vib data\n    vib_schema = self.vib(is_molecule=is_molecule)\n\n    # Generate thermo data\n    thermo_summary = ThermoSummarize(\n        atoms,\n        vib_schema[\"results\"][\"vib_freqs_raw\"],\n        energy=energy,\n        additional_fields=self.additional_fields,\n    )\n    if thermo_method == \"ideal_gas\":\n        thermo_schema = thermo_summary.ideal_gas(\n            temperature=temperature, pressure=pressure\n        )\n    elif thermo_method == \"harmonic\":\n        thermo_schema = thermo_summary.harmonic(\n            temperature=temperature, pressure=pressure\n        )\n    else:\n        raise ValueError(f\"Unsupported thermo_method: {thermo_method}.\")\n\n    # Merge the vib and thermo data\n    unsorted_task_doc = recursive_dict_merge(vib_schema, thermo_schema)\n\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/atoms.html","title":"atoms","text":"<p>Schemas for storing metadata about Atoms objects.</p>"},{"location":"reference/quacc/schemas/atoms.html#quacc.schemas.atoms.atoms_to_metadata","title":"atoms_to_metadata","text":"<pre><code>atoms_to_metadata(\n    atoms: Atoms,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; AtomsSchema\n</code></pre> <p>Convert an ASE Atoms object to a dict suitable for storage in MongoDB.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object to store in {\"atoms\": atoms}</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AtomsSchema</code>           \u2013            <p>Dict of metadata about the Atoms object.</p> </li> </ul> Source code in <code>quacc/schemas/atoms.py</code> <pre><code>def atoms_to_metadata(\n    atoms: Atoms, additional_fields: dict[str, Any] | None = None\n) -&gt; AtomsSchema:\n    \"\"\"\n    Convert an ASE Atoms object to a dict suitable for storage in MongoDB.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object to store in {\"atoms\": atoms}\n    additional_fields\n        Additional fields to add to the document.\n\n    Returns\n    -------\n    AtomsSchema\n        Dict of metadata about the Atoms object.\n    \"\"\"\n    additional_fields = additional_fields or {}\n    atoms = copy_atoms(atoms)\n    results = {}\n    atoms.calc = None\n\n    # Strip the dummy atoms, if present\n    if \"X\" in atoms.get_chemical_symbols():\n        del atoms[[atom.index for atom in atoms if atom.symbol == \"X\"]]\n\n    # Get Pymatgen Structure/Molecule metadata\n    if atoms.pbc.any():\n        structure = AseAtomsAdaptor().get_structure(atoms)\n        structure_metadata = StructureMetadata().from_structure(structure).model_dump()\n        results[\"structure_metadata\"] = structure_metadata\n    else:\n        mol = AseAtomsAdaptor().get_molecule(atoms, charge_spin_check=False)\n        molecule_metadata = MoleculeMetadata().from_molecule(mol).model_dump()\n        for key in [\"charge\", \"spin_multiplicity\", \"nelectrons\"]:\n            del molecule_metadata[key]\n        results[\"molecule_metadata\"] = molecule_metadata\n\n    # Store Atoms object\n    results[\"atoms\"] = atoms\n\n    return results | additional_fields\n</code></pre>"},{"location":"reference/quacc/schemas/phonons.html","title":"phonons","text":"<p>Summarizer for phonopy.</p>"},{"location":"reference/quacc/schemas/phonons.html#quacc.schemas.phonons.has_phonopy","title":"has_phonopy  <code>module-attribute</code>","text":"<pre><code>has_phonopy = bool(find_spec('phonopy'))\n</code></pre>"},{"location":"reference/quacc/schemas/phonons.html#quacc.schemas.phonons.summarize_phonopy","title":"summarize_phonopy","text":"<pre><code>summarize_phonopy(\n    phonon: Phonopy,\n    input_atoms: Atoms,\n    directory: str | Path,\n    parameters: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; PhononSchema\n</code></pre> <p>Summarize a Phonopy object.</p> <p>Parameters:</p> <ul> <li> <code>phonon</code>               (<code>Phonopy</code>)           \u2013            <p>Phonopy object</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>Input atoms object</p> </li> <li> <code>directory</code>               (<code>str | Path</code>)           \u2013            <p>Directory where the results are stored.</p> </li> <li> <code>parameters</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Calculator parameters used to generate the phonon object.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhononSchema</code>           \u2013            <p>The PhononSchema.</p> </li> </ul> Source code in <code>quacc/schemas/phonons.py</code> <pre><code>@requires(has_phonopy, \"This schema relies on phonopy\")\ndef summarize_phonopy(\n    phonon: Phonopy,\n    input_atoms: Atoms,\n    directory: str | Path,\n    parameters: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; PhononSchema:\n    \"\"\"\n    Summarize a Phonopy object.\n\n    Parameters\n    ----------\n    phonon\n        Phonopy object\n    input_atoms\n        Input atoms object\n    directory\n        Directory where the results are stored.\n    parameters\n        Calculator parameters used to generate the phonon object.\n    additional_fields\n        Additional fields to add to the document.\n\n    Returns\n    -------\n    PhononSchema\n        The PhononSchema.\n    \"\"\"\n    additional_fields = additional_fields or {}\n\n    inputs = {\n        \"parameters\": parameters,\n        \"nid\": get_uri(directory).split(\":\")[0],\n        \"dir_name\": directory,\n        \"phonopy_metadata\": {\"version\": phonon.version},\n        \"quacc_version\": __version__,\n    }\n\n    results = {\n        \"results\": {\n            \"thermal_properties\": phonon.get_thermal_properties_dict(),\n            \"mesh_properties\": phonon.get_mesh_dict(),\n            \"total_dos\": phonon.get_total_dos_dict(),\n            \"force_constants\": phonon.force_constants,\n        }\n    }\n\n    atoms_metadata = atoms_to_metadata(input_atoms)\n    unsorted_task_doc = atoms_metadata | inputs | results | additional_fields\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/prep.html","title":"prep","text":"<p>Utility functions for dealing with Atoms.</p>"},{"location":"reference/quacc/schemas/prep.html#quacc.schemas.prep.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/schemas/prep.html#quacc.schemas.prep.prep_next_run","title":"prep_next_run","text":"<pre><code>prep_next_run(\n    atoms: Atoms, move_magmoms: bool = False\n) -&gt; Atoms\n</code></pre> <p>Prepares the Atoms object for a new run by stripping off the calculator and assigning a unique ID.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>move_magmoms</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to move the magnetic moments from the calculator results to the initial magnetic moments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>Updated Atoms object.</p> </li> </ul> Source code in <code>quacc/schemas/prep.py</code> <pre><code>def prep_next_run(atoms: Atoms, move_magmoms: bool = False) -&gt; Atoms:\n    \"\"\"\n    Prepares the Atoms object for a new run by stripping off the calculator and\n    assigning a unique ID.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    move_magmoms\n        Whether to move the magnetic moments from the calculator results to the\n        initial magnetic moments.\n\n    Returns\n    -------\n    Atoms\n        Updated Atoms object.\n    \"\"\"\n    atoms = copy_atoms(atoms)\n\n    if (\n        move_magmoms\n        and hasattr(atoms, \"calc\")\n        and getattr(atoms.calc, \"results\", None) is not None\n    ):\n        atoms.set_initial_magnetic_moments(\n            atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n        )\n\n    # Clear off the calculator so we can run a new job. If we don't do this,\n    # then something like atoms *= (2,2,2) still has a calculator attached,\n    # which is a bit confusing.\n    atoms.calc = None\n\n    # Give the Atoms object a unique ID. This will be helpful for querying\n    # later. Also store any old IDs somewhere else for future reference. Note:\n    # Keep this at the end of the function so that the ID is assigned based on\n    # the returned Atoms object.\n    if atoms.info.get(\"_id\", None) is not None:\n        if atoms.info.get(\"_old_ids\") is None:\n            atoms.info[\"_old_ids\"] = []\n        atoms.info[\"_old_ids\"].append(atoms.info[\"_id\"])\n    atoms.info[\"_id\"] = get_atoms_id(atoms)\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/schemas/prep.html#quacc.schemas.prep.set_magmoms","title":"set_magmoms","text":"<pre><code>set_magmoms(\n    atoms: Atoms,\n    elemental_mags_dict: dict[str, float] | None = None,\n    elemental_mags_default: float = 1.0,\n    copy_magmoms: bool = True,\n    mag_cutoff: float | None = 0.05,\n) -&gt; Atoms\n</code></pre> <p>Sets the initial magnetic moments in the Atoms object.</p> <p>This function deserves particular attention. The following logic is applied: - If there is a converged set of magnetic moments, those are moved to the initial magmoms if copy_magmoms is True. - If there is no converged set of magnetic moments but the user has set initial magmoms, those are simply used as is. - If there are no converged magnetic moments or initial magnetic moments, then the default magnetic moments from the preset elemental_mags_dict (if specified) are set as the initial magnetic moments. - For any of the above scenarios, if mag_cutoff is not None, the newly set initial magnetic moments are checked. If all have a magnitude below mag_cutoff, then they are all set to 0 (no spin polarization).</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>elemental_mags_dict</code>               (<code>dict[str, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of elemental symbols and their corresponding magnetic moments to set. If None, no default values will be used.</p> </li> <li> <code>elemental_mags_default</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Default magnetic moment on an element if no magnetic moment is specified in the elemental_mags_dict. Only used if elemental_mags_dict is not None. This kwarg is mainly a convenience so that you don't need to list every single element in the elemental_mags_dict.</p> </li> <li> <code>copy_magmoms</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to copy the magnetic moments from the converged set of magnetic moments to the initial magnetic moments.</p> </li> <li> <code>mag_cutoff</code>               (<code>float | None</code>, default:                   <code>0.05</code> )           \u2013            <p>Magnitude below which the magnetic moments are considered to be zero. If None, no cutoff will be applied</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>Atoms object</p> </li> </ul> Source code in <code>quacc/schemas/prep.py</code> <pre><code>def set_magmoms(\n    atoms: Atoms,\n    elemental_mags_dict: dict[str, float] | None = None,\n    elemental_mags_default: float = 1.0,\n    copy_magmoms: bool = True,\n    mag_cutoff: float | None = 0.05,\n) -&gt; Atoms:  # sourcery skip\n    \"\"\"\n    Sets the initial magnetic moments in the Atoms object.\n\n    This function deserves particular attention. The following logic is applied:\n    - If there is a converged set of magnetic moments, those are moved to the\n    initial magmoms if copy_magmoms is True.\n    - If there is no converged set of magnetic moments but the user has set initial magmoms, those are simply used\n    as is.\n    - If there are no converged magnetic moments or initial magnetic\n    moments, then the default magnetic moments from the preset\n    elemental_mags_dict (if specified) are set as the initial magnetic moments.\n    - For any of the above scenarios, if mag_cutoff is not None, the newly set\n    initial magnetic moments are checked. If all have a magnitude below\n    mag_cutoff, then they are all set to 0 (no spin polarization).\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    elemental_mags_dict\n        Dictionary of elemental symbols and their corresponding magnetic moments\n        to set. If None, no default values will be used.\n    elemental_mags_default\n        Default magnetic moment on an element if no magnetic moment is specified\n        in the elemental_mags_dict. Only used if elemental_mags_dict is not\n        None. This kwarg is mainly a convenience so that you don't need to list\n        every single element in the elemental_mags_dict.\n    copy_magmoms\n        Whether to copy the magnetic moments from the converged set of magnetic\n        moments to the initial magnetic moments.\n    mag_cutoff\n        Magnitude below which the magnetic moments are considered to be zero. If\n        None, no cutoff will be applied\n\n    Returns\n    -------\n    Atoms\n        Atoms object\n    \"\"\"\n    # Handle the magnetic moments Check if a prior job was run and pull the\n    # prior magmoms\n    if hasattr(atoms, \"calc\") and getattr(atoms.calc, \"results\", None) is not None:\n        mags = atoms.calc.results.get(\"magmoms\", [0.0] * len(atoms))\n        # Note: It is important that we set mags to 0.0 here rather than None if\n        # the calculator has no magmoms because: 1) ispin=1 might be set, and 2)\n        # we do not want the preset magmoms to be used.\n    else:\n        mags = None\n\n    # Check if the user has set any initial magmoms\n    has_initial_mags = atoms.has(\"initial_magmoms\")\n\n    # If there are no initial magmoms set and this is not a follow-up job, we\n    # may need to add some from the preset yaml.\n    if mags is None:\n        if not has_initial_mags:\n            # If the preset dictionary has default magmoms, set those by\n            # element. If the element isn't in the magmoms dict then set it to\n            # mag_default.\n            if elemental_mags_dict:\n                initial_mags = np.array(\n                    [\n                        elemental_mags_dict.get(atom.symbol, elemental_mags_default)\n                        for atom in atoms\n                    ]\n                )\n                atoms.set_initial_magnetic_moments(initial_mags)\n        else:\n            pass\n    elif copy_magmoms:\n        atoms.set_initial_magnetic_moments(mags)\n\n    # If all the set mags are below mag_cutoff, set them to 0\n    if mag_cutoff:\n        has_new_initial_mags = atoms.has(\"initial_magmoms\")\n        new_initial_mags = atoms.get_initial_magnetic_moments()\n        if has_new_initial_mags and np.all(np.abs(new_initial_mags) &lt; mag_cutoff):\n            atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\n    return atoms\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html","title":"thermo","text":"<p>Schemas for storing thermo data.</p>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize","title":"ThermoSummarize","text":"<pre><code>ThermoSummarize(\n    atoms: Atoms,\n    vib_freqs: list[float | complex],\n    energy: float = 0.0,\n    additional_fields: dict[str, Any] | None = None,\n)\n</code></pre> <p>Summarize an ASE thermochemistry object for storage in a database.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object.</p> </li> <li> <code>vib_freqs</code>               (<code>list[float | complex]</code>)           \u2013            <p>Vibrational frequencies.</p> </li> <li> <code>energy</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Potential energy used for a reference in thermochemistry calculations.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to store in the document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/schemas/thermo.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    vib_freqs: list[float | complex],\n    energy: float = 0.0,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the ThermoSummarize object.\n\n    Parameters\n    ----------\n    atoms\n        ASE Atoms object.\n    vib_freqs\n        Vibrational frequencies.\n    energy\n        Potential energy used for a reference in thermochemistry calculations.\n    additional_fields\n        Additional fields to store in the document.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.atoms = atoms.copy()\n    # Make sure vibrational freqs are imaginary, not negative\n    vib_freqs_ = vib_freqs.copy()\n    for i, f in enumerate(vib_freqs_):\n        if not isinstance(f, complex) and f &lt; 0:\n            vib_freqs_[i] = complex(0 - f * 1j)\n    self.vib_freqs = vib_freqs_\n    self.vib_energies = [f * invcm for f in self.vib_freqs]\n    self.energy = energy\n    self.additional_fields = additional_fields or {}\n    self._settings = get_settings()\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.additional_fields","title":"additional_fields  <code>instance-attribute</code>","text":"<pre><code>additional_fields = additional_fields or {}\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = copy()\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy = energy\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.vib_energies","title":"vib_energies  <code>instance-attribute</code>","text":"<pre><code>vib_energies = [(f * invcm) for f in (vib_freqs)]\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.vib_freqs","title":"vib_freqs  <code>instance-attribute</code>","text":"<pre><code>vib_freqs = vib_freqs_\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.harmonic","title":"harmonic","text":"<pre><code>harmonic(\n    temperature: float = 298.15, pressure: float = 1.0\n) -&gt; ThermoSchema\n</code></pre> <p>Get tabulated results from an ASE HarmonicThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ThermoSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/thermo.py</code> <pre><code>def harmonic(\n    self, temperature: float = 298.15, pressure: float = 1.0\n) -&gt; ThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE HarmonicThermo object and store them in a\n    database-friendly format.\n\n    Parameters\n    ----------\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n\n    Returns\n    -------\n    ThermoSchema\n        Dictionary representation of the task document\n    \"\"\"\n    # Generate the ASE HarmonicThermo object\n    harmonic_thermo = self._make_harmonic_thermo()\n\n    # Tabulate inputs and outputs\n    inputs = {\n        \"parameters_thermo\": {\n            \"temperature\": temperature,\n            \"pressure\": pressure,\n            \"vib_freqs\": [e / invcm for e in harmonic_thermo.vib_energies],\n            \"vib_energies\": harmonic_thermo.vib_energies.tolist(),\n            \"n_imag\": harmonic_thermo.n_imag,\n            \"method\": \"harmonic\",\n        },\n        \"quacc_version\": __version__,\n    }\n\n    results = {\n        \"results\": {\n            \"energy\": harmonic_thermo.potentialenergy,\n            \"helmholtz_energy\": harmonic_thermo.get_helmholtz_energy(temperature),\n            \"internal_energy\": harmonic_thermo.get_internal_energy(temperature),\n            \"entropy\": harmonic_thermo.get_entropy(temperature),\n            \"zpe\": harmonic_thermo.get_ZPE_correction(),\n        }\n    }\n\n    unsorted_task_doc = (\n        atoms_to_metadata(self.atoms) | inputs | results | self.additional_fields\n    )\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/thermo.html#quacc.schemas.thermo.ThermoSummarize.ideal_gas","title":"ideal_gas","text":"<pre><code>ideal_gas(\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    spin_multiplicity: int | None = None,\n) -&gt; ThermoSchema\n</code></pre> <p>Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Spin multiplicity of the system. If not provided, will attempt to detect from the Atoms object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ThermoSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/thermo.py</code> <pre><code>def ideal_gas(\n    self,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    spin_multiplicity: int | None = None,\n) -&gt; ThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE IdealGasThermo object and store them in a\n    database-friendly format.\n\n    Parameters\n    ----------\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    spin_multiplicity\n        Spin multiplicity of the system. If not provided, will attempt to detect\n        from the Atoms object.\n\n    Returns\n    -------\n    ThermoSchema\n        Dictionary representation of the task document\n    \"\"\"\n    if any(self.atoms.pbc):\n        LOGGER.warning(\n            \"Removing PBCs for thermochemistry. Make sure your molecule does not cut across images.\"\n        )\n        self.atoms.pbc = False\n\n    # Get the spin multiplicity\n    if spin_multiplicity is None:\n        spin_multiplicity = get_spin_multiplicity_attribute(self.atoms)\n        LOGGER.warning(\n            f\"Using a spin multiplicity of {spin_multiplicity} for IdealGasThermo.\"\n        )\n\n    # Generate the ASE IdealGasThermo object\n    igt = self._make_ideal_gas(spin_multiplicity=spin_multiplicity)\n\n    # Tabulate inputs and outputs\n    inputs = {\n        \"parameters_thermo\": {\n            \"temperature\": temperature,\n            \"pressure\": pressure,\n            \"sigma\": igt.sigma,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"vib_freqs\": [e / invcm for e in igt.vib_energies],\n            \"vib_energies\": igt.vib_energies.tolist(),\n            \"n_imag\": igt.n_imag,\n            \"method\": \"ideal_gas\",\n        },\n        \"quacc_version\": __version__,\n    }\n\n    results = {\n        \"results\": {\n            \"energy\": igt.potentialenergy,\n            \"enthalpy\": igt.get_enthalpy(temperature),\n            \"entropy\": igt.get_entropy(temperature, pressure * 10**5),\n            \"gibbs_energy\": igt.get_gibbs_energy(temperature, pressure * 10**5),\n            \"zpe\": igt.get_ZPE_correction(),\n        }\n    }\n\n    unsorted_task_doc = (\n        atoms_to_metadata(igt.atoms) | inputs | results | self.additional_fields\n    )\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html","title":"torchsim","text":""},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.CONVERGENCE_FN_REGISTRY","title":"CONVERGENCE_FN_REGISTRY  <code>module-attribute</code>","text":"<pre><code>CONVERGENCE_FN_REGISTRY: dict[str, Callable] = {\n    \"energy\": generate_energy_convergence_fn,\n    \"force\": generate_force_convergence_fn,\n}\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PROPERTY_FN_REGISTRY","title":"PROPERTY_FN_REGISTRY  <code>module-attribute</code>","text":"<pre><code>PROPERTY_FN_REGISTRY: dict[str, Callable] = {\n    \"potential_energy\": lambda state: energy,\n    \"forces\": lambda state: forces,\n    \"stress\": lambda state: stress,\n    \"kinetic_energy\": lambda state: calc_kinetic_energy(\n        velocities=velocities, masses=masses\n    ),\n    \"temperature\": lambda state: calc_temperature(),\n    \"max_force\": lambda state: system_wise_max_force(state),\n}\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn","title":"PropertyFn","text":"<p>               Bases: <code>StrEnum</code></p> <p>Because we are not able to pass live python functions through workflow serialization, it is necessary to have an alternative mechanism. While the functions included here are quite basic, this gives users a place to patch in their own functions while maintaining compatibility.</p>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn.ENERGY","title":"ENERGY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENERGY = 'energy'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn.FORCES","title":"FORCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORCES = 'forces'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn.KINETIC_ENERGY","title":"KINETIC_ENERGY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KINETIC_ENERGY = 'kinetic_energy'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn.MAX_FORCE","title":"MAX_FORCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAX_FORCE = 'max_force'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn.STRESS","title":"STRESS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STRESS = 'stress'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.PropertyFn.TEMPERATURE","title":"TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE = 'temperature'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType","title":"TSModelType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for model types.</p>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.FAIRCHEM","title":"FAIRCHEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAIRCHEM = 'FairChemModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.FAIRCHEMV1","title":"FAIRCHEMV1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAIRCHEMV1 = 'FairChemV1Model'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.GRAPHPESWRAPPER","title":"GRAPHPESWRAPPER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GRAPHPESWRAPPER = 'GraphPESWrapper'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.LENNARD_JONES","title":"LENNARD_JONES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LENNARD_JONES = 'LennardJonesModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.MACE","title":"MACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MACE = 'MaceModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.MATTERSIM","title":"MATTERSIM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MATTERSIM = 'MatterSimModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.METATOMIC","title":"METATOMIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METATOMIC = 'MetatomicModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.NEQUIPFRAMEWORK","title":"NEQUIPFRAMEWORK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEQUIPFRAMEWORK = 'NequIPFrameworkModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.ORB","title":"ORB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORB = 'OrbModel'\n</code></pre>"},{"location":"reference/quacc/schemas/torchsim.html#quacc.schemas.torchsim.TSModelType.SEVENNET","title":"SEVENNET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEVENNET = 'SevenNetModel'\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html","title":"vasp","text":"<p>Schemas for VASP.</p>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize","title":"VaspSummarize","text":"<pre><code>VaspSummarize(\n    directory: str | Path | None = None,\n    move_magmoms: bool = True,\n    run_bader: bool | DefaultSetting = QuaccDefault,\n    run_chargemol: bool | DefaultSetting = QuaccDefault,\n    check_convergence: bool | DefaultSetting = QuaccDefault,\n    report_mp_corrections: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n)\n</code></pre> <p>Get tabulated results from a VASP run and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to VASP outputs. A value of None specifies the calculator directory.</p> </li> <li> <code>move_magmoms</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to move the final magmoms of the original Atoms object to the initial magmoms of the returned Atoms object.</p> </li> <li> <code>run_bader</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether a Bader analysis should be performed. Will not run if bader executable is not in PATH even if bader is set to True. Defaults to VASP_BADER in settings.</p> </li> <li> <code>run_chargemol</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether a Chargemol analysis should be performed. Will not run if chargemol executable is not in PATH even if chargmeol is set to True. Defaults to VASP_CHARGEMOL in settings.</p> </li> <li> <code>check_convergence</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether to throw an error if convergence is not reached. Defaults to True in settings.</p> </li> <li> <code>report_mp_corrections</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to apply the MP corrections to the task document. Defaults to False.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def __init__(\n    self,\n    directory: str | Path | None = None,\n    move_magmoms: bool = True,\n    run_bader: bool | DefaultSetting = QuaccDefault,\n    run_chargemol: bool | DefaultSetting = QuaccDefault,\n    check_convergence: bool | DefaultSetting = QuaccDefault,\n    report_mp_corrections: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the VASP summarizer.\n\n    Parameters\n    ----------\n    directory\n        Path to VASP outputs. A value of None specifies the calculator directory.\n    move_magmoms\n        Whether to move the final magmoms of the original Atoms object to the\n        initial magmoms of the returned Atoms object.\n    run_bader\n        Whether a Bader analysis should be performed. Will not run if bader\n        executable is not in PATH even if bader is set to True. Defaults to\n        VASP_BADER in settings.\n    run_chargemol\n        Whether a Chargemol analysis should be performed. Will not run if chargemol\n        executable is not in PATH even if chargmeol is set to True. Defaults to\n        VASP_CHARGEMOL in settings.\n    check_convergence\n        Whether to throw an error if convergence is not reached. Defaults to True in\n        settings.\n    report_mp_corrections\n        Whether to apply the MP corrections to the task document. Defaults to False.\n    additional_fields\n        Additional fields to add to the task document.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.directory = directory\n    self.move_magmoms = move_magmoms\n    self.run_bader = run_bader\n    self.run_chargemol = run_chargemol\n    self.check_convergence = check_convergence\n    self.report_mp_corrections = report_mp_corrections\n    self.additional_fields = additional_fields or {}\n    self._settings = get_settings()\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.additional_fields","title":"additional_fields  <code>instance-attribute</code>","text":"<pre><code>additional_fields = additional_fields or {}\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.check_convergence","title":"check_convergence  <code>instance-attribute</code>","text":"<pre><code>check_convergence = check_convergence\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.directory","title":"directory  <code>instance-attribute</code>","text":"<pre><code>directory = directory\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.move_magmoms","title":"move_magmoms  <code>instance-attribute</code>","text":"<pre><code>move_magmoms = move_magmoms\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.report_mp_corrections","title":"report_mp_corrections  <code>instance-attribute</code>","text":"<pre><code>report_mp_corrections = report_mp_corrections\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.run_bader","title":"run_bader  <code>instance-attribute</code>","text":"<pre><code>run_bader = run_bader\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.run_chargemol","title":"run_chargemol  <code>instance-attribute</code>","text":"<pre><code>run_chargemol = run_chargemol\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.ase_opt","title":"ase_opt","text":"<pre><code>ase_opt(\n    optimizer: Optimizer,\n    trajectory: list[Atoms] | None = None,\n) -&gt; VaspASEOptSchema\n</code></pre> <p>Summarize an ASE-based VASP optimization.</p> <p>Parameters:</p> <ul> <li> <code>optimizer</code>               (<code>Optimizer</code>)           \u2013            <p>The ASE optimizer object</p> </li> <li> <code>trajectory</code>               (<code>list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in dyn.trajectory.filename.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspASEOptSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def ase_opt(\n    self, optimizer: Optimizer, trajectory: list[Atoms] | None = None\n) -&gt; VaspASEOptSchema:\n    \"\"\"\n    Summarize an ASE-based VASP optimization.\n\n    Parameters\n    ----------\n    optimizer\n        The ASE optimizer object\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file. If\n        None, the trajectory must be found in dyn.trajectory.filename.\n\n    Returns\n    -------\n    VaspASEOptSchema\n        Dictionary representation of the task document\n    \"\"\"\n    final_atoms = get_final_atoms_from_dynamics(optimizer)\n    directory = Path(self.directory or final_atoms.calc.directory)\n\n    opt_run_summary = Summarize(\n        directory=directory,\n        move_magmoms=self.move_magmoms,\n        additional_fields=self.additional_fields,\n    ).opt(\n        optimizer, trajectory=trajectory, check_convergence=self.check_convergence\n    )\n\n    vasp_summary = self.run(final_atoms)\n    unsorted_task_doc = recursive_dict_merge(vasp_summary, opt_run_summary)\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize.run","title":"run","text":"<pre><code>run(final_atoms: Atoms) -&gt; VaspSchema\n</code></pre> <p>Get tabulated results from a VASP run and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>final_atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object following a calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def run(self, final_atoms: Atoms) -&gt; VaspSchema:\n    \"\"\"\n    Get tabulated results from a VASP run and store them in a database-friendly format.\n\n    Parameters\n    ----------\n    final_atoms\n        ASE Atoms object following a calculation.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary representation of the task document\n    \"\"\"\n    run_bader = (\n        self._settings.VASP_BADER\n        if self.run_bader == QuaccDefault\n        else self.run_bader\n    )\n    run_chargemol = (\n        self._settings.VASP_CHARGEMOL\n        if self.run_chargemol == QuaccDefault\n        else self.run_chargemol\n    )\n    check_convergence = (\n        self._settings.CHECK_CONVERGENCE\n        if self.check_convergence == QuaccDefault\n        else self.check_convergence\n    )\n    directory = Path(self.directory or final_atoms.calc.directory)\n    additional_fields = self.additional_fields or {}\n\n    # Fetch all tabulated results from VASP outputs files. Fortunately, emmet\n    # already has a handy function for this\n    vasp_task_model = TaskDoc.from_directory(directory)\n\n    # Get MP corrections\n    if self.report_mp_corrections:\n        mp_compat = MaterialsProject2020Compatibility()\n        try:\n            corrected_entry = mp_compat.process_entry(\n                vasp_task_model.structure_entry, on_error=\"raise\"\n            )\n            vasp_task_model.entry = corrected_entry\n        except CompatibilityError as err:\n            LOGGER.warning(err)\n\n    # Convert the VASP task model to a dictionary\n    vasp_task_doc = vasp_task_model.model_dump()\n\n    # Check for calculation convergence\n    if check_convergence and vasp_task_doc[\"state\"] != \"successful\":\n        raise RuntimeError(\n            f\"VASP calculation did not converge. Will not store task data. Refer to {directory}\"\n        )\n    poscar_path = directory / \"POSCAR\"\n    initial_atoms = read(zpath(str(poscar_path)))\n    base_task_doc = Summarize(\n        directory=directory,\n        move_magmoms=self.move_magmoms,\n        additional_fields=self.additional_fields,\n    ).run(final_atoms, initial_atoms)\n\n    if nsteps := len([f for f in os.listdir(directory) if f.startswith(\"step\")]):\n        intermediate_vasp_task_docs = {\n            \"steps\": {\n                n: TaskDoc.from_directory(directory / f\"step{n}\").model_dump()\n                for n in range(nsteps)\n                if (directory / f\"step{n}\").is_dir()\n            }\n        }\n    else:\n        intermediate_vasp_task_docs = {}\n\n    # Get Bader analysis\n    if run_bader:\n        try:\n            bader_results = bader_runner(directory)\n            vasp_task_doc[\"bader\"] = bader_results\n        except FileNotFoundError:\n            pass\n        except Exception:\n            LOGGER.warning(\"Bader analysis could not be performed.\", exc_info=True)\n\n    # Get the Chargemol analysis\n    if run_chargemol:\n        try:\n            chargemol_results = chargemol_runner(directory)\n            vasp_task_doc[\"chargemol\"] = chargemol_results\n        except FileNotFoundError:\n            pass\n        except Exception:\n            LOGGER.warning(\n                \"Chargemol analysis could not be performed.\", exc_info=True\n            )\n\n    # Make task document\n    unsorted_task_doc = (\n        intermediate_vasp_task_docs\n        | vasp_task_doc\n        | base_task_doc\n        | additional_fields\n    )\n    return clean_dict(unsorted_task_doc)\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.bader_runner","title":"bader_runner","text":"<pre><code>bader_runner(path: Path | str) -&gt; BaderSchema\n</code></pre> <p>Runs a Bader partial charge and spin moment analysis using the VASP output files in the given path. This function requires that <code>bader</code> is located in your PATH environment variable. See http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path | str</code>)           \u2013            <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaderSchema</code>           \u2013            <p>Dictionary containing the Bader analysis summary</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def bader_runner(path: Path | str) -&gt; BaderSchema:\n    \"\"\"\n    Runs a Bader partial charge and spin moment analysis using the VASP output\n    files in the given path. This function requires that `bader` is located in\n    your PATH environment variable. See\n    http://theory.cm.utexas.edu/henkelman/code/bader for the bader code.\n\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located. Must include CHGCAR,\n        AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not --\n        it doesn't matter. If None, the current working directory is used.\n\n    Returns\n    -------\n    BaderSchema\n        Dictionary containing the Bader analysis summary\n    \"\"\"\n    # Make sure files are present\n    relevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\n    for f in relevant_files:\n        if not Path(path, f).exists() and not Path(path, f\"{f}.gz\").exists():\n            msg = f\"Could not find {f} in {path}.\"\n            raise FileNotFoundError(msg)\n\n    bader_stats = bader_analysis_from_path(path)\n\n    # Store the partial charge, which is much more useful than the raw charge\n    # and is more intuitive than the charge transferred. An atom with a positive\n    # partial charge is cationic, whereas an atom with a negative partial charge\n    # is anionic.\n    bader_stats[\"partial_charges\"] = [-c for c in bader_stats[\"charge_transfer\"]]\n\n    # Some cleanup of the returned dictionary\n    if \"magmom\" in bader_stats:\n        bader_stats[\"spin_moments\"] = bader_stats[\"magmom\"]\n    for k in [\"charge\", \"charge_transfer\", \"reference_used\", \"magmom\"]:\n        bader_stats.pop(k, None)\n\n    return bader_stats\n</code></pre>"},{"location":"reference/quacc/schemas/vasp.html#quacc.schemas.vasp.chargemol_runner","title":"chargemol_runner","text":"<pre><code>chargemol_runner(\n    path: Path | str,\n    atomic_densities_path: str | None = None,\n) -&gt; ChargemolSchema\n</code></pre> <p>Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files in the given path. This function requires that the chargemol executable, given by the name <code>Chargemol_09_26_2017_linux_parallel</code>, <code>Chargemol_09_26_2017_linux_serial</code>, or <code>chargemol</code> is in the system PATH environment variable. See https://sourceforge.net/projects/ddec/files for the Chargemol code.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path | str</code>)           \u2013            <p>The path where the VASP output files are located. Must include CHGCAR, AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not -- it doesn't matter. If None, the current working directory is used.</p> </li> <li> <code>atomic_densities_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path where the reference atomic densities are located for Chargemol. If None, we assume that this directory is defined in an environment variable named DDEC6_ATOMIC_DENSITIES_DIR. See the Chargemol documentation for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChargemolSchema</code>           \u2013            <p>Dictionary containing the Chargemol analysis summary</p> </li> </ul> Source code in <code>quacc/schemas/vasp.py</code> <pre><code>def chargemol_runner(\n    path: Path | str, atomic_densities_path: str | None = None\n) -&gt; ChargemolSchema:\n    \"\"\"\n    Runs a Chargemol (i.e. DDEC6 + CM5) analysis using the VASP output files in\n    the given path. This function requires that the chargemol executable, given\n    by the name `Chargemol_09_26_2017_linux_parallel`,\n    `Chargemol_09_26_2017_linux_serial`, or `chargemol` is in the system PATH\n    environment variable. See https://sourceforge.net/projects/ddec/files for\n    the Chargemol code.\n\n    Parameters\n    ----------\n    path\n        The path where the VASP output files are located. Must include CHGCAR,\n        AECCAR0, AECCAR2, and POTCAR files. These files can be gzip'd or not --\n        it doesn't matter. If None, the current working directory is used.\n    atomic_densities_path\n        The path where the reference atomic densities are located for Chargemol.\n        If None, we assume that this directory is defined in an environment\n        variable named DDEC6_ATOMIC_DENSITIES_DIR. See the Chargemol\n        documentation for more information.\n\n    Returns\n    -------\n    ChargemolSchema\n        Dictionary containing the Chargemol analysis summary\n    \"\"\"\n    # Make sure files are present\n    relevant_files = [\"AECCAR0\", \"AECCAR2\", \"CHGCAR\", \"POTCAR\"]\n    for f in relevant_files:\n        if not Path(path, f).exists() and not Path(path, f\"{f}.gz\").exists():\n            msg = f\"Could not find {f} in {path}.\"\n            raise FileNotFoundError(msg)\n\n    # Check environment variable\n    if atomic_densities_path is None and \"DDEC6_ATOMIC_DENSITIES_DIR\" not in os.environ:\n        msg = \"DDEC6_ATOMIC_DENSITIES_DIR environment variable not defined.\"\n        raise OSError(msg)\n\n    # Run Chargemol analysis\n    return ChargemolAnalysis(path=path, atomic_densities_path=atomic_densities_path)\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html","title":"dicts","text":"<p>Utility functions for dealing with dictionaries.</p>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.Remove","title":"Remove","text":"<pre><code>Remove()\n</code></pre> <p>A sentinel class used in quacc to mark a key in a dictionary for removal.</p> <p>Note: This is more robust than using <code>None</code> as the sentinel value because <code>None</code> is a valid value for many keyword arguments.</p> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def __init__(self):\n    raise NotImplementedError(\n        \"Remove is a sentinel class and should not be instantiated.\"\n    )\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.clean_dict","title":"clean_dict","text":"<pre><code>clean_dict(\n    start_dict: Mapping[str, Any],\n) -&gt; Mapping[str, Any]\n</code></pre> <p>Clean up a task document dictionary by removing all entries that are None and sorting the dictionary alphabetically by key.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>Dictionary to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Cleaned dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def clean_dict(start_dict: Mapping[str, Any]) -&gt; Mapping[str, Any]:\n    \"\"\"\n    Clean up a task document dictionary by removing all entries that are None and\n    sorting the dictionary alphabetically by key.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n\n    Returns\n    -------\n    dict\n        Cleaned dictionary\n    \"\"\"\n    return sort_dict(remove_dict_entries(start_dict, None))\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.recursive_dict_merge","title":"recursive_dict_merge","text":"<pre><code>recursive_dict_merge(\n    *dicts: Mapping[str, Any] | None,\n    remove_trigger: Any = Remove,\n    verbose: bool = False\n) -&gt; Mapping[str, Any]\n</code></pre> <p>Recursively merge several dictionaries, taking the latter in the list as higher preference. Also removes any entries that have a value of <code>remove_trigger</code> from the final dictionary. If a <code>None</code> is provided, it is assumed to be <code>{}</code>.</p> <p>This function should be used instead of the | operator when merging nested dictionaries, e.g. <code>{\"a\": {\"b\": 1}} | {\"a\": {\"c\": 2}}</code> will return <code>{\"a\": {\"c\": 2}}</code> whereas <code>recursive_dict_merge({\"a\": {\"b\": 1}}, {\"a\": {\"c\": 2}})</code> will return <code>{\"a\": {\"b\": 1, \"c\": 2}}</code>.</p> <p>Parameters:</p> <ul> <li> <code>*dicts</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>()</code> )           \u2013            <p>Dictionaries to merge</p> </li> <li> <code>remove_trigger</code>               (<code>Any</code>, default:                   <code>Remove</code> )           \u2013            <p>Value to that triggers removal of the entry</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to log warnings when overwriting keys</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Mapping[str, Any]</code>           \u2013            <p>Merged dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def recursive_dict_merge(\n    *dicts: Mapping[str, Any] | None,\n    remove_trigger: Any = Remove,\n    verbose: bool = False,\n) -&gt; Mapping[str, Any]:\n    \"\"\"\n    Recursively merge several dictionaries, taking the latter in the list as higher\n    preference. Also removes any entries that have a value of `remove_trigger` from the\n    final dictionary. If a `None` is provided, it is assumed to be `{}`.\n\n    This function should be used instead of the | operator when merging nested dictionaries,\n    e.g. `{\"a\": {\"b\": 1}} | {\"a\": {\"c\": 2}}` will return `{\"a\": {\"c\": 2}}` whereas\n    `recursive_dict_merge({\"a\": {\"b\": 1}}, {\"a\": {\"c\": 2}})` will return `{\"a\": {\"b\": 1, \"c\": 2}}`.\n\n    Parameters\n    ----------\n    *dicts\n        Dictionaries to merge\n    remove_trigger\n        Value to that triggers removal of the entry\n    verbose\n        Whether to log warnings when overwriting keys\n\n    Returns\n    -------\n    Mapping[str, Any]\n        Merged dictionary\n    \"\"\"\n    old_dict = dicts[0]\n    merged = {}\n    for i in range(len(dicts) - 1):\n        merged = _recursive_dict_pair_merge(old_dict, dicts[i + 1], verbose=verbose)\n        old_dict = deepcopy(merged)\n    return remove_dict_entries(merged, remove_trigger=remove_trigger)\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.remove_dict_entries","title":"remove_dict_entries","text":"<pre><code>remove_dict_entries(\n    start_dict: Mapping[str, Any], remove_trigger: Any\n) -&gt; Mapping[str, Any]\n</code></pre> <p>For a given dictionary, recursively remove all items that are the <code>remove_trigger</code>.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>Dictionary to clean</p> </li> <li> <code>remove_trigger</code>               (<code>Any</code>)           \u2013            <p>Value to that triggers removal of the entry</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Cleaned dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def remove_dict_entries(\n    start_dict: Mapping[str, Any], remove_trigger: Any\n) -&gt; Mapping[str, Any]:\n    \"\"\"\n    For a given dictionary, recursively remove all items that are the `remove_trigger`.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to clean\n    remove_trigger\n        Value to that triggers removal of the entry\n\n    Returns\n    -------\n    dict\n        Cleaned dictionary\n    \"\"\"\n    if isinstance(start_dict, Mapping):\n        return {\n            k: remove_dict_entries(v, remove_trigger)\n            for k, v in start_dict.items()\n            if v is not remove_trigger\n        }\n    return (\n        [remove_dict_entries(v, remove_trigger) for v in start_dict]\n        if isinstance(start_dict, list)\n        else start_dict\n    )\n</code></pre>"},{"location":"reference/quacc/utils/dicts.html#quacc.utils.dicts.sort_dict","title":"sort_dict","text":"<pre><code>sort_dict(\n    start_dict: Mapping[str, Any],\n) -&gt; Mapping[str, Any]\n</code></pre> <p>For a given dictionary, recursively sort all entries alphabetically by key.</p> <p>Parameters:</p> <ul> <li> <code>start_dict</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>Dictionary to sort</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Sorted dictionary</p> </li> </ul> Source code in <code>quacc/utils/dicts.py</code> <pre><code>def sort_dict(start_dict: Mapping[str, Any]) -&gt; Mapping[str, Any]:\n    \"\"\"\n    For a given dictionary, recursively sort all entries alphabetically by key.\n\n    Parameters\n    ----------\n    start_dict\n        Dictionary to sort\n\n    Returns\n    -------\n    dict\n        Sorted dictionary\n    \"\"\"\n    return {\n        k: sort_dict(dict(v)) if isinstance(v, Mapping) else v\n        for k, v in sorted(start_dict.items())\n    }\n</code></pre>"},{"location":"reference/quacc/utils/files.html","title":"files","text":"<p>Utility functions for file and path handling.</p>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.LOGGER","title":"LOGGER  <code>module-attribute</code>","text":"<pre><code>LOGGER = getLogger(__name__)\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.check_logfile","title":"check_logfile","text":"<pre><code>check_logfile(logfile: str | Path, check_str: str) -&gt; bool\n</code></pre> <p>Check if a logfile has a given string (case-insensitive). The compression suffix, e.g. <code>.gz</code>, is automatically handled and does not need to be specified.</p> <p>Parameters:</p> <ul> <li> <code>logfile</code>               (<code>str | Path</code>)           \u2013            <p>Path to the logfile.</p> </li> <li> <code>check_str</code>               (<code>str</code>)           \u2013            <p>String to check for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the string is found in the logfile, False otherwise.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def check_logfile(logfile: str | Path, check_str: str) -&gt; bool:\n    \"\"\"\n    Check if a logfile has a given string (case-insensitive).\n    The compression suffix, e.g. `.gz`, is automatically handled\n    and does not need to be specified.\n\n    Parameters\n    ----------\n    logfile\n        Path to the logfile.\n    check_str\n        String to check for.\n\n    Returns\n    -------\n    bool\n        True if the string is found in the logfile, False otherwise.\n    \"\"\"\n    logfile_path = Path(logfile).expanduser()\n    zlog = Path(zpath(str(logfile_path)))\n    with zopen(zlog, \"r\") as f:\n        for line in f:\n            clean_line = line if isinstance(line, str) else line.decode(\"utf-8\")\n            if check_str.lower() in clean_line.lower():\n                return True\n    return False\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.copy_decompress_files","title":"copy_decompress_files","text":"<pre><code>copy_decompress_files(\n    source_directory: SourceDirectory,\n    filenames: Filenames,\n    destination_directory: str | Path,\n) -&gt; None\n</code></pre> <p>Copy and decompress <code>filenames</code> from the <code>source_directory</code> to the <code>destination</code> directory.</p> <p>For example, to copy the files <code>CHGCAR</code> and <code>WAVECAR</code> from the <code>source_directory</code> to the <code>destination</code> directory, use the following:</p> <pre><code>copy_decompress_files(\n    source_directory=\"/path/to/source\",\n    filenames=[\"CHGCAR\", \"WAVECAR\"],\n    destination=\"/path/to/destination\",\n)\n</code></pre> <p>This function also supports glob patterns for any of the entries within <code>filenames</code>.</p> <p>For example, to copy and decompress all files in the <code>source_directory</code> with the extension <code>.gz</code> to the <code>destination</code> directory, use the following:</p> <pre><code>copy_decompress_files(\n    source_directory=\"/path/to/source\",\n    filenames=[\"*.gz\"],\n    destination=\"/path/to/destination\",\n)\n</code></pre> <p>If a directory is specified in <code>filenames</code>, that directory and its contents will be copied and decompressed to the <code>destination</code> directory.</p> <p>For example, to recursively copy the entire directory <code>prior_run</code> and decompress its files from the <code>source_directory</code> to the <code>destination</code> directory, use the following:</p> <pre><code>copy_decompress_files(\n    source_directory=\"/path/to/source\",\n    filenames=[\"prior_run\"],\n    destination=\"/path/to/destination\",\n)\n</code></pre> <p>Sometimes, you may want to copy a directory but only keep some of the files for the sake of saving space. In other words, you want to retain the tree structure of the files with respect to some parent directory. To do this, you can specify the tree to retain in the <code>filenames</code> argument. For example, to copy and decompress the files <code>prior_run/CHGCAR</code> and <code>prior_run/WAVECAR</code> from the <code>source_directory</code> to the <code>destination</code> directory while the tree structure, use the following:</p> <pre><code>copy_decompress_files(\n    source_directory=\"/path/to/source\",\n    filenames=[\"prior_run/CHGCAR\", \"prior_run/WAVECAR\"],\n    destination=\"/path/to/destination\",\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>source_directory</code>               (<code>SourceDirectory</code>)           \u2013            <p>Directory to copy files from.</p> </li> <li> <code>filenames</code>               (<code>Filenames</code>)           \u2013            <p>Files to copy and decompress. Glob patterns are supported.</p> </li> <li> <code>destination_directory</code>               (<code>str | Path</code>)           \u2013            <p>Destination directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def copy_decompress_files(\n    source_directory: SourceDirectory,\n    filenames: Filenames,\n    destination_directory: str | Path,\n) -&gt; None:\n    \"\"\"\n    Copy and decompress `filenames` from the `source_directory` to the `destination`\n    directory.\n\n    For example, to copy the files `CHGCAR` and `WAVECAR` from the `source_directory` to\n    the `destination` directory, use the following:\n\n    ```python\n    copy_decompress_files(\n        source_directory=\"/path/to/source\",\n        filenames=[\"CHGCAR\", \"WAVECAR\"],\n        destination=\"/path/to/destination\",\n    )\n    ```\n\n    This function also supports glob patterns for any of the entries within `filenames`.\n\n    For example, to copy and decompress all files in the `source_directory` with the\n    extension `.gz` to the `destination` directory, use the following:\n\n    ```python\n    copy_decompress_files(\n        source_directory=\"/path/to/source\",\n        filenames=[\"*.gz\"],\n        destination=\"/path/to/destination\",\n    )\n    ```\n\n    If a directory is specified in `filenames`, that directory and its contents will be\n    copied and decompressed to the `destination` directory.\n\n    For example, to recursively copy the entire directory `prior_run` and decompress its\n    files from the `source_directory` to the `destination` directory, use the following:\n\n    ```python\n    copy_decompress_files(\n        source_directory=\"/path/to/source\",\n        filenames=[\"prior_run\"],\n        destination=\"/path/to/destination\",\n    )\n    ```\n\n    Sometimes, you may want to copy a directory but only keep some of the files for the\n    sake of saving space. In other words, you want to retain the tree structure of the\n    files with respect to some parent directory. To do this, you can specify the\n    tree to retain in the `filenames` argument. For example, to copy and decompress the\n    files `prior_run/CHGCAR` and `prior_run/WAVECAR` from the `source_directory` to the\n    `destination` directory while the tree structure, use the following:\n\n    ```python\n    copy_decompress_files(\n        source_directory=\"/path/to/source\",\n        filenames=[\"prior_run/CHGCAR\", \"prior_run/WAVECAR\"],\n        destination=\"/path/to/destination\",\n    )\n    ```\n\n    Parameters\n    ----------\n    source_directory\n        Directory to copy files from.\n    filenames\n        Files to copy and decompress. Glob patterns are supported.\n    destination_directory\n        Destination directory.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    source_directory = Path(source_directory).expanduser()\n    destination_directory = Path(destination_directory).expanduser()\n\n    if not isinstance(filenames, list):\n        filenames = [filenames]\n\n    for f in filenames:\n        globs_found = list(source_directory.glob(str(f)))\n        if not globs_found:\n            LOGGER.warning(f\"Cannot find file {f} in {source_directory}\")\n        for source_filepath in globs_found:\n            destination_filepath = destination_directory / source_filepath.relative_to(\n                source_directory\n            )\n            Path(destination_filepath.parent).mkdir(parents=True, exist_ok=True)\n\n            if source_filepath.is_symlink():\n                continue\n            if source_filepath.is_file():\n                copy(source_filepath, destination_filepath)\n                decompress_file(destination_filepath)\n            elif source_filepath.is_dir():\n                copytree(\n                    source_filepath,\n                    destination_filepath,\n                    symlinks=True,\n                    dirs_exist_ok=True,\n                    ignore=ignore_patterns(\"error.*\"),\n                )\n                decompress_dir(destination_filepath)\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.find_recent_logfile","title":"find_recent_logfile","text":"<pre><code>find_recent_logfile(\n    directory: Path | str,\n    logfile_extensions: str | list[str],\n) -&gt; Path\n</code></pre> <p>Find the most recent logfile in a given directory.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The path to the directory to search</p> </li> <li> <code>logfile_extensions</code>               (<code>str | list[str]</code>)           \u2013            <p>The extension (or list of possible extensions) of the logfile to search for. For an exact match only, put in the full file name. Note that it is recommended that the extension starts with a period so that it is bound by the start of the extension (e.g. for extensions <code>.log</code> versus <code>.mylog</code>, you would expect <code>logfile_extensions=\".log\"</code> to match only the former and <code>logfile_extensions=\"log\"</code> to match both).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>logfile</code>           \u2013            <p>The path to the most recent logfile with the desired extension</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def find_recent_logfile(\n    directory: Path | str, logfile_extensions: str | list[str]\n) -&gt; Path:\n    \"\"\"\n    Find the most recent logfile in a given directory.\n\n    Parameters\n    ----------\n    directory\n        The path to the directory to search\n    logfile_extensions\n        The extension (or list of possible extensions) of the logfile to search\n        for. For an exact match only, put in the full file name. Note that it is\n        recommended that the extension starts with a period so that it is bound\n        by the start of the extension (e.g. for extensions `.log` versus\n        `.mylog`, you would expect `logfile_extensions=\".log\"` to match only\n        the former and `logfile_extensions=\"log\"` to match both).\n\n    Returns\n    -------\n    logfile\n        The path to the most recent logfile with the desired extension\n    \"\"\"\n    mod_time = 0.0\n    logfile = None\n    if isinstance(logfile_extensions, str):\n        logfile_extensions = [logfile_extensions]\n    for f in Path(directory).expanduser().iterdir():\n        f_path = Path(directory, f)\n        for ext in logfile_extensions:\n            if ext in \"\".join(f.suffixes) and f_path.stat().st_mtime &gt; mod_time:\n                mod_time = f_path.stat().st_mtime\n                logfile = f_path.resolve()\n    return logfile\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.get_uri","title":"get_uri","text":"<pre><code>get_uri(directory: str | Path) -&gt; str\n</code></pre> <p>Return the URI path for a directory.</p> <p>This allows files hosted on different file servers to have distinct locations.</p> <p>Adapted from Atomate2.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str | Path</code>)           \u2013            <p>A directory name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def get_uri(directory: str | Path) -&gt; str:\n    \"\"\"\n    Return the URI path for a directory.\n\n    This allows files hosted on different file servers to have distinct\n    locations.\n\n    Adapted from Atomate2.\n\n    Parameters\n    ----------\n    directory\n        A directory name.\n\n    Returns\n    -------\n    str\n        Full URI path, e.g., \"fileserver.host.com:/full/path/of/dir_name\".\n    \"\"\"\n    fullpath = Path(directory).expanduser().resolve()\n    hostname = socket.gethostname()\n    with contextlib.suppress(socket.gaierror, socket.herror):\n        hostname = socket.gethostbyaddr(hostname)[0]\n    return f\"{hostname}:{fullpath}\"\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.load_yaml_calc","title":"load_yaml_calc","text":"<pre><code>load_yaml_calc(yaml_path: str | Path) -&gt; dict[str, Any]\n</code></pre> <p>Loads a YAML file containing calculator settings. This YAML loader looks for a special flag \"parent\" in the YAML file. If this flag is present, the YAML file specified in the \"parent\" flag is loaded and its contents are inherited by the child YAML file. It is assumed that the parent YAML file is in the same directory as the child YAML file if only the filename is specified.</p> <p>Parameters:</p> <ul> <li> <code>yaml_path</code>               (<code>str | Path</code>)           \u2013            <p>Path to the YAML file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>The calculator configuration (i.e. settings).</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def load_yaml_calc(yaml_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Loads a YAML file containing calculator settings. This YAML loader looks for a\n    special flag \"parent\" in the YAML file. If this flag is present, the YAML file\n    specified in the \"parent\" flag is loaded and its contents are inherited by the child\n    YAML file. It is assumed that the parent YAML file is in the same directory as the\n    child YAML file if only the filename is specified.\n\n    Parameters\n    ----------\n    yaml_path\n        Path to the YAML file.\n\n    Returns\n    -------\n    dict\n        The calculator configuration (i.e. settings).\n    \"\"\"\n    yaml_path = Path(yaml_path).expanduser()\n\n    if not yaml_path.exists():\n        msg = f\"Cannot find {yaml_path}\"\n        raise FileNotFoundError(msg)\n\n    # Load YAML file\n    config = YAML().load(yaml_path)\n\n    # Inherit arguments from any parent YAML files but do not overwrite those in\n    # the child file.\n    for config_arg in deepcopy(config):\n        if \"parent\" in config_arg.lower():\n            if Path(config[config_arg]).suffix in (\".yml\", \".yaml\"):\n                yaml_parent_path = config[config_arg]\n            else:\n                yaml_parent_path = yaml_path.parent / f\"{config[config_arg]}.yaml\"\n            parent_config = load_yaml_calc(yaml_parent_path)\n\n            for k, v in parent_config.items():\n                if k not in config:\n                    config[k] = v\n                else:\n                    v_new = parent_config.get(k, {})\n                    for kk, vv in v_new.items():\n                        if kk not in config[k]:\n                            config[k][kk] = vv\n\n            del config[config_arg]\n\n    return config\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.make_unique_dir","title":"make_unique_dir","text":"<pre><code>make_unique_dir(\n    base_path: Path | str | None = None,\n    prefix: str | None = None,\n) -&gt; Path\n</code></pre> <p>Make a directory with a unique name.</p> <p>Parameters:</p> <ul> <li> <code>base_path</code>               (<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the base directory.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Prefix to add to the directory name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the job directory.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def make_unique_dir(\n    base_path: Path | str | None = None, prefix: str | None = None\n) -&gt; Path:\n    \"\"\"\n    Make a directory with a unique name.\n\n    Parameters\n    ----------\n    base_path\n        Path to the base directory.\n    prefix\n        Prefix to add to the directory name.\n\n    Returns\n    -------\n    Path\n        Path to the job directory.\n    \"\"\"\n    job_dir = Path(make_unique_name(prefix))\n    if base_path:\n        job_dir = Path(base_path, job_dir)\n    job_dir.mkdir(parents=True)\n\n    return job_dir\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.make_unique_name","title":"make_unique_name","text":"<pre><code>make_unique_name(prefix: str | None = None) -&gt; str\n</code></pre> <p>Create a unique name suitable for newly created files/folders.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Prefix to add to the name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A unique timestamped name.</p> </li> </ul> Source code in <code>quacc/utils/files.py</code> <pre><code>def make_unique_name(prefix: str | None = None) -&gt; str:\n    \"\"\"\n    Create a unique name suitable for newly created files/folders.\n\n    Parameters\n    ----------\n    prefix\n        Prefix to add to the name.\n\n    Returns\n    -------\n    str\n        A unique timestamped name.\n    \"\"\"\n    time_now = datetime.now(UTC).strftime(\"%Y-%m-%d-%H-%M-%S-%f\")\n    if prefix is None:\n        prefix = \"\"\n    return f\"{prefix}{time_now}-{randint(10000, 99999)}\"\n</code></pre>"},{"location":"reference/quacc/utils/files.html#quacc.utils.files.safe_decompress_dir","title":"safe_decompress_dir","text":"<pre><code>safe_decompress_dir(path: str | Path) -&gt; None\n</code></pre> <p>Recursively decompresses all files in a directory. This is a wrapper around the <code>decompress_file</code> function.</p> <p>Args:     path (str | Path): Path to parent directory.</p> Source code in <code>quacc/utils/files.py</code> <pre><code>def safe_decompress_dir(path: str | Path) -&gt; None:\n    \"\"\"\n    Recursively decompresses all files in a directory.\n    This is a wrapper around the `decompress_file` function.\n\n\n    Args:\n        path (str | Path): Path to parent directory.\n    \"\"\"\n    path = Path(path)\n    for parent, _, files in os.walk(path):\n        for f in files:\n            try:\n                decompress_file(Path(parent, f))\n            except FileNotFoundError:\n                LOGGER.debug(f\"Cannot find {f} in {parent}. Skipping.\")\n</code></pre>"},{"location":"reference/quacc/utils/kpts.html","title":"kpts","text":"<p>Utilities for k-point handling.</p>"},{"location":"reference/quacc/utils/kpts.html#quacc.utils.kpts.bandgap_to_kspacing","title":"bandgap_to_kspacing","text":"<pre><code>bandgap_to_kspacing(bandgap: float) -&gt; float\n</code></pre> <p>Takes the bandgap energy and computes the required KSPACING value. Refer to https://drive.google.com/file/d/1fUUx0wrrtMRcSss5yv3NiQuC7J5IiEKL/view</p> <p>Parameters:</p> <ul> <li> <code>bandgap</code>               (<code>float</code>)           \u2013            <p>The bandgap of the material in eV.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>kspacing</code>           \u2013            <p>Value of the KSPACING INCAR tag in inverse angstroms.</p> </li> </ul> Source code in <code>quacc/utils/kpts.py</code> <pre><code>def bandgap_to_kspacing(bandgap: float) -&gt; float:\n    \"\"\"\n    Takes the bandgap energy and computes the required KSPACING value.\n    Refer to https://drive.google.com/file/d/1fUUx0wrrtMRcSss5yv3NiQuC7J5IiEKL/view\n\n    Parameters\n    ----------\n    bandgap\n        The bandgap of the material in eV.\n\n    Returns\n    ----------\n    kspacing\n        Value of the KSPACING INCAR tag in inverse angstroms.\n    \"\"\"\n\n    deltak_min = 0.2\n    deltak_max = 0.45\n    a = 0.9\n    b = 2.35\n    c = 8.0\n\n    delta = a * (bandgap - b)\n    return 0.5 * (\n        deltak_min\n        + deltak_max\n        + (deltak_max - deltak_min) * delta / ((1 + delta**c) ** (1 / c))\n    )\n</code></pre>"},{"location":"reference/quacc/utils/kpts.html#quacc.utils.kpts.convert_pmg_kpts","title":"convert_pmg_kpts","text":"<pre><code>convert_pmg_kpts(\n    pmg_kpts: PmgKpts,\n    input_atoms: Atoms,\n    force_gamma: bool = False,\n) -&gt; tuple[list[int], bool]\n</code></pre> <p>Shortcuts for pymatgen k-point generation schemes.</p> <p>Parameters:</p> <ul> <li> <code>pmg_kpts</code>               (<code>PmgKpts</code>)           \u2013            <p>The pmg_kpts kwargs. Has the following options:</p> <ul> <li> <p>{\"line_density\": float}. This will call <code>pymatgen.symmetry.bandstructure.HighSymmKpath</code>     with <code>path_type=\"latimer_munro\"</code>. The <code>line_density</code> value will be     set in the <code>.get_kpoints</code> attribute.</p> </li> <li> <p>{\"kppvol\": float}. This will call <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_vol</code>     with the given value for <code>kppvol</code>.</p> </li> <li> <p>{\"kppa\": float}. This will call <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density</code>     with the given value for <code>kppa</code>.</p> </li> <li> <p>{\"length_densities\": [float, float, float]}. This will call <code>pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_lengths</code>     with the given value for <code>length_densities</code>.</p> </li> </ul> <p>If multiple options are specified, the most dense k-point scheme will be chosen.</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input atoms.</p> </li> <li> <code>force_gamma</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force gamma-centered k-points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>kpts</code>           \u2013            <p>The generated k-points.</p> </li> <li> <code>gamma</code>           \u2013            <p>Whether the k-points are gamma-centered.</p> </li> </ul> Source code in <code>quacc/utils/kpts.py</code> <pre><code>def convert_pmg_kpts(\n    pmg_kpts: PmgKpts, input_atoms: Atoms, force_gamma: bool = False\n) -&gt; tuple[list[int], bool]:\n    \"\"\"\n    Shortcuts for pymatgen k-point generation schemes.\n\n    Parameters\n    ----------\n    pmg_kpts\n        The pmg_kpts kwargs. Has the following options:\n\n        - {\"line_density\": float}. This will call\n        `pymatgen.symmetry.bandstructure.HighSymmKpath`\n            with `path_type=\"latimer_munro\"`. The `line_density` value will be\n            set in the `.get_kpoints` attribute.\n\n        - {\"kppvol\": float}. This will call\n        `pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_vol`\n            with the given value for `kppvol`.\n\n        - {\"kppa\": float}. This will call\n        `pymatgen.io.vasp.inputs.Kpoints.automatic_density`\n            with the given value for `kppa`.\n\n        - {\"length_densities\": [float, float, float]}. This will call\n        `pymatgen.io.vasp.inputs.Kpoints.automatic_density_by_lengths`\n            with the given value for `length_densities`.\n\n        If multiple options are specified, the most dense k-point scheme will be\n        chosen.\n    input_atoms\n        The input atoms.\n    force_gamma\n        Force gamma-centered k-points.\n\n    Returns\n    -------\n    kpts\n        The generated k-points.\n    gamma\n        Whether the k-points are gamma-centered.\n    \"\"\"\n    struct = AseAtomsAdaptor.get_structure(input_atoms)\n\n    if pmg_kpts.get(\"line_density\"):\n        kpath = HighSymmKpath(\n            struct,\n            path_type=\"latimer_munro\",\n            has_magmoms=np.any(struct.site_properties.get(\"magmom\", None)),\n        )\n        kpts, _ = kpath.get_kpoints(\n            line_density=pmg_kpts[\"line_density\"], coords_are_cartesian=False\n        )\n        kpts = np.stack(kpts)\n        gamma = False\n\n    else:\n        max_pmg_kpts: PmgKpts = None\n        for k, v in pmg_kpts.items():\n            if k == \"kppvol\":\n                pmg_kpts = Kpoints.automatic_density_by_vol(\n                    struct, v, force_gamma=force_gamma\n                )\n            elif k == \"kppa\":\n                pmg_kpts = Kpoints.automatic_density(struct, v, force_gamma=force_gamma)\n            elif k == \"length_densities\":\n                pmg_kpts = Kpoints.automatic_density_by_lengths(\n                    struct, v, force_gamma=force_gamma\n                )\n            else:\n                msg = f\"Unsupported k-point generation scheme: {pmg_kpts}.\"\n                raise ValueError(msg)\n\n            max_pmg_kpts = (\n                pmg_kpts\n                if (\n                    not max_pmg_kpts\n                    or np.prod(pmg_kpts.kpts[0]) &gt;= np.prod(max_pmg_kpts.kpts[0])\n                )\n                else max_pmg_kpts\n            )\n\n        kpts = [int(k) for k in max_pmg_kpts.kpts[0]]\n        gamma = max_pmg_kpts.style.name.lower() == \"gamma\"\n\n    return kpts, gamma\n</code></pre>"},{"location":"reference/quacc/utils/kpts.html#quacc.utils.kpts.kspacing_to_kpts","title":"kspacing_to_kpts","text":"<pre><code>kspacing_to_kpts(\n    kspacing: float, atoms: Atoms\n) -&gt; list[int]\n</code></pre> <p>Converts KSPACING to k-points.</p> <p>Parameters:</p> <ul> <li> <code>kspacing</code>               (<code>float</code>)           \u2013            <p>The KSPACING value in inverse angstroms.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input atoms.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The k-points as a list of integers.</p> </li> </ul> Source code in <code>quacc/utils/kpts.py</code> <pre><code>def kspacing_to_kpts(kspacing: float, atoms: Atoms) -&gt; list[int]:\n    \"\"\"\n    Converts KSPACING to k-points.\n\n    Parameters\n    ----------\n    kspacing\n        The KSPACING value in inverse angstroms.\n    atoms\n        The input atoms.\n\n    Returns\n    -------\n    list[int]\n        The k-points as a list of integers.\n    \"\"\"\n    return [\n        int(\n            max(\n                1,\n                np.ceil(\n                    Structure.from_ase_atoms(atoms).lattice.reciprocal_lattice.abc[ik]\n                    / kspacing\n                ),\n            )\n        )\n        for ik in range(3)\n    ]\n</code></pre>"},{"location":"reference/quacc/utils/lists.html","title":"lists","text":"<p>Utilities for working with lists.</p>"},{"location":"reference/quacc/utils/lists.html#quacc.utils.lists.merge_list_params","title":"merge_list_params","text":"<pre><code>merge_list_params(\n    *lists: list[str],\n    removal_prefix: str | None = \"#\",\n    case_insensitive: bool = True\n) -&gt; list[str]\n</code></pre> <p>Merge list string parameters, taking list2 as the priority. Also removes any entries that start with <code>removal_prefix</code> from the final list.</p> <p>Parameters:</p> <ul> <li> <code>*lists</code>               (<code>list[str]</code>, default:                   <code>()</code> )           \u2013            <p>Lists to merge, with the latter taking priority.</p> </li> <li> <code>removal_prefix</code>               (<code>str | None</code>, default:                   <code>'#'</code> )           \u2013            <p>Prefix to use to remove an entry from the final list.</p> </li> <li> <code>case_insensitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to perform case-insensitive comparisons</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>Merged list</p> </li> </ul> Source code in <code>quacc/utils/lists.py</code> <pre><code>def merge_list_params(\n    *lists: list[str], removal_prefix: str | None = \"#\", case_insensitive: bool = True\n) -&gt; list[str]:\n    \"\"\"\n    Merge list string parameters, taking list2 as the priority. Also removes any entries\n    that start with `removal_prefix` from the final list.\n\n    Parameters\n    ----------\n    *lists\n        Lists to merge, with the latter taking priority.\n    removal_prefix\n        Prefix to use to remove an entry from the final list.\n    case_insensitive\n        Whether to perform case-insensitive comparisons\n\n    Returns\n    -------\n    list\n        Merged list\n    \"\"\"\n    merged_list = []\n    lists_ = [list_ for list_ in lists if list_]\n    for list_ in lists_:\n        for item in list_:\n            item_ = item\n            if case_insensitive:\n                item_ = item.lower()\n            if item_ not in merged_list:\n                merged_list.append(item_)\n\n    if removal_prefix:\n        items_to_remove1 = [\n            item[1:] for item in merged_list if item.startswith(removal_prefix)\n        ]\n        items_to_remove2 = [\n            item for item in merged_list if item.startswith(removal_prefix)\n        ]\n        items_to_remove = items_to_remove1 + items_to_remove2\n        for item in items_to_remove:\n            if item in merged_list:\n                merged_list.remove(item)\n\n    merged_list.sort()\n    return merged_list\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html","title":"context","text":"<p>Execution context tracking for the autodiscover directory feature.</p> <p>This module maintains a thread-/task-local stack of ContextNodes that records the nesting of flows, subflows and jobs as they execute.  When NESTED_RESULTS is enabled, the context stack is translated into a filesystem path (e.g. <code>my_flow-&lt;id&gt;/my_subflow-&lt;id&gt;/my_job-&lt;id&gt;</code>) so that every job's output lands in a directory tree that mirrors the workflow structure.</p> <p>Two ContextVars are used:   * <code>_execution_context</code> - the node stack (tuple of ContextNode).   * <code>_directory_context</code> - the root directory chosen for the current     top-level invocation.</p>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.ContextNode","title":"ContextNode","text":"<pre><code>ContextNode(name: str, node_type: NodeType)\n</code></pre> <p>               Bases: <code>MSONable</code></p> <p>A single entry in the execution-context stack.</p> <p>Each node records the function name and its node_type (job, flow, or subflow).  The stack of these nodes is used to build the autodiscovered directory path.  Inherits from MSONable so it can be serialized when the context is passed across process boundaries.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def __init__(self, name: str, node_type: NodeType):\n    self.name = name\n    self.node_type = node_type\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.ContextNode.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.ContextNode.node_type","title":"node_type  <code>instance-attribute</code>","text":"<pre><code>node_type = node_type\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.NodeType","title":"NodeType","text":"<p>               Bases: <code>Enum</code></p> <p>Enumerates the types of nodes in a quacc workflow graph.</p>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.NodeType.FLOW","title":"FLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FLOW = 'flow'\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.NodeType.JOB","title":"JOB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JOB = 'job'\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.NodeType.SUBFLOW","title":"SUBFLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SUBFLOW = 'subflow'\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.directory_context","title":"directory_context","text":"<pre><code>directory_context(directory_path: str)\n</code></pre> <p>Public convenience wrapper around <code>_push_directory_context</code>.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def directory_context(directory_path: str):\n    \"\"\"Public convenience wrapper around ``_push_directory_context``.\"\"\"\n    return _push_directory_context(directory_path)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.get_context","title":"get_context","text":"<pre><code>get_context() -&gt; tuple[ContextNode, ...]\n</code></pre> <p>Return the current execution-context node stack.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def get_context() -&gt; tuple[ContextNode, ...]:\n    \"\"\"Return the current execution-context node stack.\"\"\"\n    return _execution_context.get()\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.get_context_path","title":"get_context_path","text":"<pre><code>get_context_path() -&gt; str\n</code></pre> <p>Build a <code>/</code>-separated path from the names of all nodes on the stack.</p> <p>For example, if the stack is <code>[flow(\"bulk_to_slabs_flow\"), subflow(\"bulk_to_slabs_subflow\"), job(\"relax_job\")]</code>, this returns <code>\"bulk_to_slabs_flow/bulk_to_slabs_subflow/relax_job\"</code>.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def get_context_path() -&gt; str:\n    \"\"\"Build a ``/``-separated path from the names of all nodes on the stack.\n\n    For example, if the stack is ``[flow(\"bulk_to_slabs_flow\"),\n    subflow(\"bulk_to_slabs_subflow\"), job(\"relax_job\")]``, this returns\n    ``\"bulk_to_slabs_flow/bulk_to_slabs_subflow/relax_job\"``.\n    \"\"\"\n    return \"/\".join(n.name for n in get_context())\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.get_directory_context","title":"get_directory_context","text":"<pre><code>get_directory_context() -&gt; str\n</code></pre> <p>Return the root output directory for the current top-level invocation.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def get_directory_context() -&gt; str:\n    \"\"\"Return the root output directory for the current top-level invocation.\"\"\"\n    return _directory_context.get()\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.is_top_level","title":"is_top_level","text":"<pre><code>is_top_level() -&gt; bool\n</code></pre> <p>Check whether no tracked flow/job is currently executing.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def is_top_level() -&gt; bool:\n    \"\"\"Check whether no tracked flow/job is currently executing.\"\"\"\n    current_context = get_context()\n    return current_context == ()\n</code></pre>"},{"location":"reference/quacc/wflow_tools/context.html#quacc.wflow_tools.context.tracked","title":"tracked","text":"<pre><code>tracked(node_type: NodeType)\n</code></pre> <p>Decorator factory that wraps a function to track its execution context.</p> <p>We use this to wrap functions before passing them to workflow engine decorators.</p> <p>For workflow engines that serialize tasks and execute them in separate processes (like Redun), the context can be passed via special kwargs (_quacc_ctx, _quacc_dir) which are extracted and restored before execution.</p> Source code in <code>quacc/wflow_tools/context.py</code> <pre><code>def tracked(node_type: NodeType):\n    \"\"\"\n    Decorator factory that wraps a function to track its execution context.\n\n    We use this to wrap functions before passing them to workflow engine decorators.\n\n    For workflow engines that serialize tasks and execute them in separate\n    processes (like Redun), the context can be passed via special kwargs\n    (_quacc_ctx, _quacc_dir) which are extracted and restored before execution.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        # Preserve the true original (pre-decoration) function so that\n        # strip_decorator() can fully unwrap back to the user's code.\n        original = getattr(func, \"original\", func)\n\n        if asyncio.iscoroutinefunction(func):\n\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n                return await _tracked_call(func, node_type, args, kwargs)\n\n        else:\n\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                return _tracked_call(func, node_type, args, kwargs)\n\n        # Attach the original unwrapped function so it can be recovered later.\n        wrapper.original = original\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/quacc/wflow_tools/customizers.html","title":"customizers","text":"<p>Functions to customize workflow steps.</p>"},{"location":"reference/quacc/wflow_tools/customizers.html#quacc.wflow_tools.customizers.customize_funcs","title":"customize_funcs","text":"<pre><code>customize_funcs(\n    names: list[str] | str,\n    funcs: list[Callable] | Callable,\n    param_defaults: dict[str, dict[str, Any]] | None = None,\n    param_swaps: dict[str, dict[str, Any]] | None = None,\n    decorators: dict[str, Callable | None] | None = None,\n) -&gt; tuple[Callable, ...] | Callable\n</code></pre> <p>Customize a set of functions with decorators and common parameters.</p> <p>Parameters:</p> <ul> <li> <code>names</code>               (<code>list[str] | str</code>)           \u2013            <p>The names of the functions to customize, in the order they should be returned.</p> </li> <li> <code>funcs</code>               (<code>list[Callable] | Callable</code>)           \u2013            <p>The functions to customize, in the order they are described in <code>names</code>.</p> </li> <li> <code>param_defaults</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default parameters to apply to each function. The keys of this dictionary correspond to the strings in <code>names</code>. If the key <code>\"all\"</code> is present, it will be applied to all functions. If the value is <code>None</code>, no custom parameters will be applied to that function.</p> </li> <li> <code>param_swaps</code>               (<code>dict[str, dict[str, Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>User-overrides of parameters to apply to each function. The keys of this dictionary correspond to the strings in <code>names</code>. If the key <code>\"all\"</code> is present, it will be applied to all functions. If the value is <code>None</code>, no custom parameters will be applied to that function.</p> </li> <li> <code>decorators</code>               (<code>dict[str, Callable | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom decorators to apply to each function. The keys of this dictionary correspond to the strings in <code>names</code>. If the key <code>\"all\"</code> is present, it will be applied to all functions. If a value is <code>None</code>, no decorator will be applied that function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Callable, ...] | Callable</code>           \u2013            <p>The customized functions, returned in the same order as provided in <code>funcs</code>.</p> </li> </ul> Source code in <code>quacc/wflow_tools/customizers.py</code> <pre><code>def customize_funcs(\n    names: list[str] | str,\n    funcs: list[Callable] | Callable,\n    param_defaults: dict[str, dict[str, Any]] | None = None,\n    param_swaps: dict[str, dict[str, Any]] | None = None,\n    decorators: dict[str, Callable | None] | None = None,\n) -&gt; tuple[Callable, ...] | Callable:\n    \"\"\"\n    Customize a set of functions with decorators and common parameters.\n\n    Parameters\n    ----------\n    names\n        The names of the functions to customize, in the order they should be returned.\n    funcs\n        The functions to customize, in the order they are described in `names`.\n    param_defaults\n        Default parameters to apply to each function. The keys of this dictionary correspond\n        to the strings in `names`. If the key `\"all\"` is present, it will be applied to all\n        functions. If the value is `None`, no custom parameters will be applied to that function.\n    param_swaps\n        User-overrides of parameters to apply to each function. The keys of this dictionary correspond\n        to the strings in `names`. If the key `\"all\"` is present, it will be applied to all\n        functions. If the value is `None`, no custom parameters will be applied to that function.\n    decorators\n        Custom decorators to apply to each function. The keys of this dictionary correspond\n        to the strings in `names`. If the key `\"all\"` is present, it will be applied to all\n        functions. If a value is `None`, no decorator will be applied that function.\n\n    Returns\n    -------\n    tuple[Callable, ...] | Callable\n        The customized functions, returned in the same order as provided in `funcs`.\n    \"\"\"\n    parameters = recursive_dict_merge(param_defaults, param_swaps)\n    decorators = decorators or {}\n    updated_funcs = []\n\n    if not isinstance(names, list | tuple):\n        names = [names]\n    if not isinstance(funcs, list | tuple):\n        funcs = [funcs]\n\n    if \"all\" in names:\n        raise ValueError(\"Invalid function name: 'all' is a reserved name.\")\n    if bad_decorator_keys := [k for k in decorators if k not in names and k != \"all\"]:\n        raise ValueError(\n            f\"Invalid decorator keys: {bad_decorator_keys}. Valid keys are: {names}\"\n        )\n    if bad_parameter_keys := [k for k in parameters if k not in names and k != \"all\"]:\n        raise ValueError(\n            f\"Invalid parameter keys: {bad_parameter_keys}. Valid keys are: {names}\"\n        )\n\n    for i, func in enumerate(funcs):\n        func_ = deepcopy(func)\n        if decorator := decorators.get(\"all\"):\n            func_ = redecorate(func_, decorator)\n        if decorator := decorators.get(names[i]):\n            func_ = redecorate(func_, decorator)\n        if params := parameters.get(\"all\"):\n            func_ = update_parameters(func_, params)\n        if params := parameters.get(names[i]):\n            func_ = update_parameters(func_, params)\n        updated_funcs.append(func_)\n\n    return updated_funcs[0] if len(updated_funcs) == 1 else tuple(updated_funcs)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/customizers.html#quacc.wflow_tools.customizers.redecorate","title":"redecorate","text":"<pre><code>redecorate(\n    func: Callable, decorator: Callable | None\n) -&gt; Callable\n</code></pre> <p>Redecorate a pre-decorated function with a custom decorator.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The pre-decorated function.</p> </li> <li> <code>decorator</code>               (<code>Callable | None</code>)           \u2013            <p>The new decorator to apply. If <code>None</code>, the function is stripped of its decorators.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The newly decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/customizers.py</code> <pre><code>def redecorate(func: Callable, decorator: Callable | None) -&gt; Callable:\n    \"\"\"\n    Redecorate a pre-decorated function with a custom decorator.\n\n    Parameters\n    ----------\n    func\n        The pre-decorated function.\n    decorator\n        The new decorator to apply. If `None`, the function is stripped of its\n        decorators.\n\n    Returns\n    -------\n    Callable\n        The newly decorated function.\n    \"\"\"\n    func = strip_decorator(func)\n    return func if decorator is None else decorator(func)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/customizers.html#quacc.wflow_tools.customizers.strip_decorator","title":"strip_decorator","text":"<pre><code>strip_decorator(func: Callable) -&gt; Callable\n</code></pre> <p>Strip the decorators from a function.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The function to strip decorators from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The function with all decorators removed.</p> </li> </ul> Source code in <code>quacc/wflow_tools/customizers.py</code> <pre><code>def strip_decorator(func: Callable) -&gt; Callable:\n    \"\"\"\n    Strip the decorators from a function.\n\n    Parameters\n    ----------\n    func\n        The function to strip decorators from.\n\n    Returns\n    -------\n    Callable\n        The function with all decorators removed.\n    \"\"\"\n    from quacc import get_settings\n\n    settings = get_settings()\n\n    if settings.WORKFLOW_ENGINE == \"dask\":\n        from dask.delayed import Delayed\n\n        from quacc.wflow_tools.decorators import Delayed_\n\n        if isinstance(func, Delayed_):\n            func = func.func\n        if isinstance(func, Delayed):\n            func = func.__wrapped__\n            if hasattr(func, \"__wrapped__\"):\n                # Needed for custom `@subflow` decorator\n                func = func.__wrapped__\n\n    elif settings.WORKFLOW_ENGINE == \"jobflow\":\n        if hasattr(func, \"original\"):\n            func = func.original\n\n    elif settings.WORKFLOW_ENGINE == \"parsl\":\n        from parsl.app.python import PythonApp\n\n        if isinstance(func, PythonApp):\n            func = func.func\n\n    elif settings.WORKFLOW_ENGINE == \"prefect\":\n        from prefect import Flow as PrefectFlow\n        from prefect import Task\n\n        if isinstance(func, Task | PrefectFlow):\n            func = func.fn\n        elif hasattr(func, \"__wrapped__\"):\n            func = func.__wrapped__\n\n    elif settings.WORKFLOW_ENGINE == \"redun\":\n        from redun import Task\n\n        if isinstance(func, Task):\n            func = func.func\n\n    return func\n</code></pre>"},{"location":"reference/quacc/wflow_tools/customizers.html#quacc.wflow_tools.customizers.update_parameters","title":"update_parameters","text":"<pre><code>update_parameters(\n    func: Callable,\n    params: dict[str, Any],\n    decorator: (\n        Literal[\"job\", \"flow\", \"subflow\"] | None\n    ) = \"job\",\n) -&gt; Callable\n</code></pre> <p>Update the parameters of a (potentially decorated) function.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The function to update.</p> </li> <li> <code>params</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The parameters and associated values to update.</p> </li> <li> <code>decorator</code>               (<code>Literal['job', 'flow', 'subflow'] | None</code>, default:                   <code>'job'</code> )           \u2013            <p>The decorator associated with <code>func</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The updated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/customizers.py</code> <pre><code>def update_parameters(\n    func: Callable,\n    params: dict[str, Any],\n    decorator: Literal[\"job\", \"flow\", \"subflow\"] | None = \"job\",\n) -&gt; Callable:\n    \"\"\"\n    Update the parameters of a (potentially decorated) function.\n\n    Parameters\n    ----------\n    func\n        The function to update.\n    params\n        The parameters and associated values to update.\n    decorator\n        The decorator associated with `func`.\n\n    Returns\n    -------\n    Callable\n        The updated function.\n    \"\"\"\n    from quacc import flow, get_settings, job, subflow\n\n    settings = get_settings()\n\n    if decorator and settings.WORKFLOW_ENGINE == \"dask\":\n        if decorator == \"job\":\n            decorator_func = job\n        elif decorator == \"flow\":\n            decorator_func = flow\n        elif decorator == \"subflow\":\n            decorator_func = subflow\n        else:\n            raise ValueError(\n                f\"Invalid decorator name: {decorator}. Valid names are: 'job', 'flow', 'subflow'\"\n            )\n        func = strip_decorator(func)\n        return decorator_func(partial(func, **params))\n\n    partial_fn = partial(func, **params)\n    # Assigning a __name__ allows monty's jsanitize function to work correctly\n    # with this partial function.\n    if hasattr(func, \"name\"):\n        partial_fn.__name__ = func.name\n    elif hasattr(func, \"__name__\"):\n        partial_fn.__name__ = func.__name__\n    else:\n        partial_fn.__name__ = \"\"\n\n    return partial_fn\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html","title":"decorators","text":"<p>Workflow decorators.</p>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Flow","title":"Flow  <code>module-attribute</code>","text":"<pre><code>Flow = Callable[..., Any]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Job","title":"Job  <code>module-attribute</code>","text":"<pre><code>Job = Callable[..., Any]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Subflow","title":"Subflow  <code>module-attribute</code>","text":"<pre><code>Subflow = Callable[..., Any]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Delayed_","title":"Delayed_","text":"<pre><code>Delayed_(func)\n</code></pre> <p>A small Dask-compatible, serializable object to wrap delayed functions that we don't want to execute.</p> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def __init__(self, func):\n    self.func = func\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Delayed_.__slots__","title":"__slots__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__slots__ = ('func',)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Delayed_.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func = func\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Delayed_.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    return self.func(*args, **kwargs)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.Delayed_.__reduce__","title":"__reduce__","text":"<pre><code>__reduce__()\n</code></pre> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def __reduce__(self):\n    return (Delayed_, (self.func,))\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.flow","title":"flow","text":"<pre><code>flow(\n    _func: Callable[..., Any] | None = None, **kwargs\n) -&gt; Flow\n</code></pre> <p>Decorator for workflows, which consist of at least one compute job. This is a <code>@flow</code> decorator.</p> Quacc Parsl Dask Prefect Redun Jobflow <code>flow</code> No effect No effect <code>flow</code> <code>task</code> No effect <p>All <code>@flow</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>from quacc import flow, job\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\n@flow\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <p>... is the same as doing</p> DaskParslPrefectRedunJobflow <pre><code>from dask import delayed\n\n\n@delayed\ndef add(a, b):\n    return a + b\n\n\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from parsl import python_app\n\n\n@python_app\ndef add(a, b):\n    return a + b\n\n\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from prefect import flow, task\n\n\n@task\ndef add(a, b):\n    return a + b\n\n\n@flow\ndef workflow(a, b, c):\n    return add.submit(add.submit(a, b), c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>from redun import task\n\n\n@task\ndef add(a, b):\n    return a + b\n\n\n@task\ndef workflow(a, b, c):\n    return add(add(a, b), c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <p>Warning</p> <p>This decorator is not meant to be used with Jobflow at this time.</p> <p>Parameters:</p> <ul> <li> <code>_func</code>               (<code>Callable[..., Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Flow</code>           \u2013            <p>The <code>@flow</code>-decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def flow(_func: Callable[..., Any] | None = None, **kwargs) -&gt; Flow:\n    \"\"\"\n    Decorator for workflows, which consist of at least one compute job. This is a\n    `#!Python @flow` decorator.\n\n    | Quacc  | Parsl     | Dask      | Prefect | Redun  | Jobflow   |\n    | ------ | --------- | --------- | ------- | ------ | --------- |\n    | `flow` | No effect | No effect | `flow`  | `task` | No effect |\n\n    All `#!Python @flow`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    from quacc import flow, job\n\n\n    @job\n    def add(a, b):\n        return a + b\n\n\n    @flow\n    def workflow(a, b, c):\n        return add(add(a, b), c)\n\n\n    workflow(1, 2, 3)\n    ```\n\n    ... is the same as doing\n\n    === \"Dask\"\n\n        ```python\n        from dask import delayed\n\n\n        @delayed\n        def add(a, b):\n            return a + b\n\n\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Parsl\"\n\n        ```python\n        from parsl import python_app\n\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        from prefect import flow, task\n\n\n        @task\n        def add(a, b):\n            return a + b\n\n\n        @flow\n        def workflow(a, b, c):\n            return add.submit(add.submit(a, b), c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        from redun import task\n\n\n        @task\n        def add(a, b):\n            return a + b\n\n\n        @task\n        def workflow(a, b, c):\n            return add(add(a, b), c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Jobflow\"\n\n        !!! Warning\n\n            This decorator is not meant to be used with Jobflow at this time.\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n\n    Returns\n    -------\n    Flow\n        The `#!Python @flow`-decorated function.\n    \"\"\"\n    from quacc import get_settings\n\n    settings = get_settings()\n\n    if _func is None:\n        return partial(flow, **kwargs)\n\n    elif settings.WORKFLOW_ENGINE == \"redun\":\n        from redun import task\n\n        return task(_func, namespace=_func.__module__, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"prefect\":\n        return _get_prefect_wrapped_flow(_func, settings, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"jobflow\":\n        return _get_jobflow_wrapped_flow(_func)\n    else:\n        return tracked(NodeType.FLOW)(_func)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.job","title":"job","text":"<pre><code>job(\n    _func: Callable[..., Any] | None = None, **kwargs\n) -&gt; Job\n</code></pre> <p>Decorator for individual compute jobs. This is a <code>@job</code> decorator. Think of each <code>@job</code>-decorated function as an individual SLURM job, if that helps.</p> Quacc Parsl Dask Prefect Redun Jobflow <code>job</code> <code>python_app</code> <code>delayed</code> <code>task</code> <code>task</code> <code>job</code> <p>All <code>@job</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>from quacc import job\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n</code></pre> <p>... is the same as doing</p> DaskParslPrefectRedunJobflow <pre><code>from dask import delayed\n\n\n@delayed\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n</code></pre> <pre><code>from parsl import python_app\n\n\n@python_app\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n</code></pre> <pre><code>from prefect import task\n\n\n@task\ndef add(a, b):\n    return a + b\n\n\nadd.submit(1, 2)\n</code></pre> <pre><code>from redun import task\n\n\n@task\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n</code></pre> <pre><code>import jobflow as jf\n\n\n@jf.job\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>_func</code>               (<code>Callable[..., Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments to pass to the workflow engine decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Job</code>           \u2013            <p>The @job-decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def job(_func: Callable[..., Any] | None = None, **kwargs) -&gt; Job:\n    \"\"\"\n    Decorator for individual compute jobs. This is a `#!Python @job` decorator. Think of\n    each `#!Python @job`-decorated function as an individual SLURM job, if that helps.\n\n    | Quacc | Parsl        | Dask      | Prefect | Redun  | Jobflow |\n    | ----- | ------------ | --------- | ------- | ------ | ------- |\n    | `job` | `python_app` | `delayed` | `task`  | `task` | `job`   |\n\n    All `#!Python @job`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    from quacc import job\n\n\n    @job\n    def add(a, b):\n        return a + b\n\n\n    add(1, 2)\n    ```\n\n    ... is the same as doing\n\n    === \"Dask\"\n\n        ```python\n        from dask import delayed\n\n\n        @delayed\n        def add(a, b):\n            return a + b\n\n\n        add(1, 2)\n        ```\n\n    === \"Parsl\"\n\n        ```python\n        from parsl import python_app\n\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n\n        add(1, 2)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        from prefect import task\n\n\n        @task\n        def add(a, b):\n            return a + b\n\n\n        add.submit(1, 2)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        from redun import task\n\n\n        @task\n        def add(a, b):\n            return a + b\n\n\n        add(1, 2)\n        ```\n\n    === \"Jobflow\"\n\n        ```python\n        import jobflow as jf\n\n\n        @jf.job\n        def add(a, b):\n            return a + b\n\n\n        add(1, 2)\n        ```\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the workflow engine decorator.\n\n    Returns\n    -------\n    Job\n        The @job-decorated function.\n    \"\"\"\n    from quacc import get_settings\n\n    settings = get_settings()\n\n    if _func is None:\n        return partial(job, **kwargs)\n\n    if changes := kwargs.pop(\"settings_swap\", {}):\n        _func = change_settings_wrap(_func, changes)\n\n    if settings.WORKFLOW_ENGINE == \"dask\":\n        from dask import delayed\n\n        # See https://github.com/dask/dask/issues/10733\n\n        @wraps(_func)\n        def wrapper(*f_args, **f_kwargs):\n            return _func(*f_args, **f_kwargs)\n\n        return Delayed_(delayed(wrapper, **kwargs))\n\n    elif settings.WORKFLOW_ENGINE == \"jobflow\":\n        return _get_jobflow_wrapped_func(_func, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"parsl\":\n        from parsl import python_app\n\n        wrapped_fn = _get_parsl_wrapped_func(_func, kwargs)\n\n        return python_app(wrapped_fn, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"redun\":\n        from redun import task\n\n        return task(_func, namespace=_func.__module__, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"prefect\":\n        from prefect import task\n\n        if settings.PREFECT_AUTO_SUBMIT:\n\n            @wraps(_func)\n            def wrapper(*f_args, **f_kwargs):\n                decorated = task(_func, **kwargs)\n                return decorated.submit(*f_args, **f_kwargs)\n\n            return wrapper\n        else:\n            return task(_func, **kwargs)\n    else:\n        _func = tracked(NodeType.JOB)(_func)\n        return _func\n</code></pre>"},{"location":"reference/quacc/wflow_tools/decorators.html#quacc.wflow_tools.decorators.subflow","title":"subflow","text":"<pre><code>subflow(\n    _func: Callable[..., Any] | None = None, **kwargs\n) -&gt; Subflow\n</code></pre> <p>Decorator for (dynamic) sub-workflows. This is a <code>@subflow</code> decorator.</p> Quacc Parsl Dask Prefect Redun Jobflow <code>subflow</code> <code>join_app</code> <code>delayed</code> <code>flow</code> <code>task</code> No effect <p>All <code>@subflow</code>-decorated functions are transformed into their corresponding decorator.</p> <pre><code>import random\nfrom quacc import flow, job, subflow\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\n@job\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n\n@subflow\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n\n@flow\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <p>... is the same as doing</p> DaskParslPrefectRedunJobflow <p>It's complicated... see the source code.</p> <pre><code>import random\nfrom parsl import join_app, python_app\n\n\n@python_app\ndef add(a, b):\n    return a + b\n\n\n@python_app\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n\n@join_app\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom prefect import flow, task\n\n\n@task\ndef add(a, b):\n    return a + b\n\n\n@task\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n\n@flow\ndef add_distributed(vals, c):\n    return [add.submit(val, c) for val in vals]\n\n\n@flow\ndef workflow(a, b, c):\n    result1 = add.submit(a, b)\n    result2 = make_more.submit(result1)\n    return add_distributed(result2, c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <pre><code>import random\nfrom redun import task\n\n\n@task\ndef add(a, b):\n    return a + b\n\n\n@task\ndef make_more(val):\n    return [val] * random.randint(2, 5)\n\n\n@task\ndef add_distributed(vals, c):\n    return [add(val, c) for val in vals]\n\n\n@task\ndef workflow(a, b, c):\n    result1 = add(a, b)\n    result2 = make_more(result1)\n    return add_distributed(result2, c)\n\n\nworkflow(1, 2, 3)\n</code></pre> <p>Warning</p> <p>This decorator is not meant to be used with Jobflow at this time.</p> <p>Parameters:</p> <ul> <li> <code>_func</code>               (<code>Callable[..., Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>The function to decorate. This is not meant to be supplied by the user.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments to pass to the decorator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>callable</code>           \u2013            <p>The decorated function.</p> </li> </ul> Source code in <code>quacc/wflow_tools/decorators.py</code> <pre><code>def subflow(_func: Callable[..., Any] | None = None, **kwargs) -&gt; Subflow:\n    \"\"\"\n    Decorator for (dynamic) sub-workflows. This is a `#!Python @subflow` decorator.\n\n    | Quacc     | Parsl      | Dask      | Prefect | Redun  | Jobflow   |\n    | --------- | ---------- | --------- | ------- |------- | --------- |\n    | `subflow` | `join_app` | `delayed` | `flow`  | `task` | No effect |\n\n    All `#!Python @subflow`-decorated functions are transformed into their corresponding\n    decorator.\n\n    ```python\n    import random\n    from quacc import flow, job, subflow\n\n\n    @job\n    def add(a, b):\n        return a + b\n\n\n    @job\n    def make_more(val):\n        return [val] * random.randint(2, 5)\n\n\n    @subflow\n    def add_distributed(vals, c):\n        return [add(val, c) for val in vals]\n\n\n    @flow\n    def workflow(a, b, c):\n        result1 = add(a, b)\n        result2 = make_more(result1)\n        return add_distributed(result2, c)\n\n\n    workflow(1, 2, 3)\n    ```\n\n    ... is the same as doing\n\n    === \"Dask\"\n\n        It's complicated... see the source code.\n\n    === \"Parsl\"\n\n        ```python\n        import random\n        from parsl import join_app, python_app\n\n\n        @python_app\n        def add(a, b):\n            return a + b\n\n\n        @python_app\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n\n        @join_app\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Prefect\"\n\n        ```python\n        import random\n        from prefect import flow, task\n\n\n        @task\n        def add(a, b):\n            return a + b\n\n\n        @task\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n\n        @flow\n        def add_distributed(vals, c):\n            return [add.submit(val, c) for val in vals]\n\n\n        @flow\n        def workflow(a, b, c):\n            result1 = add.submit(a, b)\n            result2 = make_more.submit(result1)\n            return add_distributed(result2, c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Redun\"\n\n        ```python\n        import random\n        from redun import task\n\n\n        @task\n        def add(a, b):\n            return a + b\n\n\n        @task\n        def make_more(val):\n            return [val] * random.randint(2, 5)\n\n\n        @task\n        def add_distributed(vals, c):\n            return [add(val, c) for val in vals]\n\n\n        @task\n        def workflow(a, b, c):\n            result1 = add(a, b)\n            result2 = make_more(result1)\n            return add_distributed(result2, c)\n\n\n        workflow(1, 2, 3)\n        ```\n\n    === \"Jobflow\"\n\n        !!! Warning\n\n            This decorator is not meant to be used with Jobflow at this time.\n\n    Parameters\n    ----------\n    _func\n        The function to decorate. This is not meant to be supplied by the user.\n    **kwargs\n        Keyword arguments to pass to the decorator.\n\n    Returns\n    -------\n    callable\n        The decorated function.\n    \"\"\"\n    from quacc import get_settings\n\n    settings = get_settings()\n\n    if _func is None:\n        return partial(subflow, **kwargs)\n\n    elif settings.WORKFLOW_ENGINE == \"dask\":\n        from dask.delayed import delayed\n        from dask.distributed import worker_client\n\n        # See https://github.com/dask/dask/issues/10733\n\n        @wraps(_func)\n        def wrapper(*f_args, **f_kwargs):\n            with worker_client() as client:\n                futures = client.compute(_func(*f_args, **f_kwargs))\n                return client.gather(futures)\n\n        return delayed(wrapper, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"parsl\":\n        from parsl import join_app\n\n        wrapped_fn = _get_parsl_wrapped_func(_func, kwargs)\n\n        return join_app(wrapped_fn, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"prefect\":\n        return _get_prefect_wrapped_flow(_func, settings, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"redun\":\n        from redun import task\n\n        return task(_func, namespace=_func.__module__, **kwargs)\n    elif settings.WORKFLOW_ENGINE == \"jobflow\":\n        return _get_jobflow_wrapped_func(_func, **kwargs)\n    else:\n        _func = tracked(NodeType.SUBFLOW)(_func)\n        return _func\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html","title":"job_argument","text":"<p>Job argument classes for workflow engine interoperability.</p> <p>This module provides a pattern for creating workflow-engine-specific objects that can be used as arguments in jobs within a DAG. The primary use case is copying files from source directories (which are represented as futures in various workflow engines) to a target directory.</p> <p>Different workflow engines represent deferred/future values differently: - Prefect/Parsl: Use <code>.result()</code> to resolve futures - Dask: Uses <code>.compute()</code> to resolve delayed values - Redun: Requires wrapping operations in <code>@task</code> decorators for lazy evaluation - Jobflow: Uses UUID-based references that get resolved by the executor - No engine (direct execution): Values are already resolved</p>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.Copy","title":"Copy","text":"<p>               Bases: <code>JobArgument</code></p> <p>Unified API for copying files from job output directories in a workflow DAG.</p> <p>This is the main class that users should instantiate. It acts as a factory that automatically returns the appropriate engine-specific implementation based on the current WORKFLOW_ENGINE setting.</p>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.DaskCopy","title":"DaskCopy","text":"<pre><code>DaskCopy(src_dir_to_files: dict[Delayed, str | list[str]])\n</code></pre> <p>               Bases: <code>dict</code></p> <p>Copy implementation for the Dask workflow engine.</p> <p>Dask uses delayed objects that are resolved via the <code>.compute()</code> method. This class inherits from dict to ensure proper serialization when passed between Dask workers.</p> <p>Parameters:</p> <ul> <li> <code>src_dir_to_files</code>               (<code>dict[Delayed, str | list[str]]</code>)           \u2013            <p>A mapping from Dask delayed objects (representing source directories) to lists of files to copy from those directories.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def __init__(self, src_dir_to_files: dict[Delayed, str | list[str]]):\n    # Store in the dict under a private key for serialization compatibility\n    self[\"_src_dir_to_files\"] = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.DaskCopy.do_copy","title":"do_copy","text":"<pre><code>do_copy(tgt_dir: str | Path)\n</code></pre> <p>Compute delayed values and copy files to the target directory.</p> <p>Parameters:</p> <ul> <li> <code>tgt_dir</code>               (<code>str | Path</code>)           \u2013            <p>The destination directory where files will be copied.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def do_copy(self, tgt_dir: str | Path):\n    \"\"\"\n    Compute delayed values and copy files to the target directory.\n\n    Parameters\n    ----------\n    tgt_dir\n        The destination directory where files will be copied.\n    \"\"\"\n    for future, files in self[\"_src_dir_to_files\"].items():\n        copy_decompress_files(future.compute(), files, tgt_dir)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.DictCopy","title":"DictCopy","text":"<p>               Bases: <code>dict</code></p> <p>Default copy implementation when no workflow engine is configured.</p> <p>This class inherits from dict so it can be used directly as a mapping of source_dir -&gt; files_to_copy.</p>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.DictCopy.do_copy","title":"do_copy","text":"<pre><code>do_copy(tgt_dir: str | Path)\n</code></pre> <p>Copy files from all source directories to the target directory.</p> <p>Parameters:</p> <ul> <li> <code>tgt_dir</code>               (<code>str | Path</code>)           \u2013            <p>The destination directory where files will be copied.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def do_copy(self, tgt_dir: str | Path):\n    \"\"\"\n    Copy files from all source directories to the target directory.\n\n    Parameters\n    ----------\n    tgt_dir\n        The destination directory where files will be copied.\n    \"\"\"\n    for src_dir, files in self.items():\n        copy_decompress_files(src_dir, files, tgt_dir)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobArgument","title":"JobArgument","text":"<p>Abstract factory base class for workflow-engine-specific job arguments.</p> <p>Subclasses must define a <code>_class_mapping</code> class variable that maps workflow engine names (str) to their corresponding implementation classes. The key <code>None</code> should map to the default implementation used when no workflow engine is configured.</p>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobArgument.__new__","title":"__new__","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def __new__(cls, *args, **kwargs):\n    settings = get_settings()\n\n    target_cls = cls._class_mapping.get(\n        settings.WORKFLOW_ENGINE, cls._class_mapping[None]\n    )\n\n    obj = target_cls.__new__(target_cls)\n    obj.__init__(*args, **kwargs)\n    return obj\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobflowCopy","title":"JobflowCopy","text":"<pre><code>JobflowCopy(\n    futures_to_vals: (\n        dict[OutputReference, [str | list[str]]] | None\n    ) = None,\n    src_dir_to_files: (\n        dict[str, [str | list[str]]] | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>MSONable</code></p> <p>Copy implementation for Jobflow engine.</p> <p>Parameters:</p> <ul> <li> <code>futures_to_vals</code>               (<code>dict[OutputReference, [str | list[str]]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping from Jobflow OutputReferences to the list of files to copy from the directory that the OutputReference will resolve to. Used when constructing the object before serialization.</p> </li> <li> <code>src_dir_to_files</code>               (<code>dict[str, [str | list[str]]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping from resolved directory paths to file lists. Used when reconstructing the object after deserialization.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def __init__(\n    self,\n    futures_to_vals: dict[OutputReference, [str | list[str]]] | None = None,\n    src_dir_to_files: dict[str, [str | list[str]]] | None = None,\n):\n    self.futures_to_vals = futures_to_vals\n    self.src_dir_to_files = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobflowCopy.futures_to_vals","title":"futures_to_vals  <code>instance-attribute</code>","text":"<pre><code>futures_to_vals = futures_to_vals\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobflowCopy.src_dir_to_files","title":"src_dir_to_files  <code>instance-attribute</code>","text":"<pre><code>src_dir_to_files = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobflowCopy.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Serialization method required for <code>MSONable</code> objects.</p> <p>The OutputReferences are stored in <code>uuids_to_refs</code>. Jobflow will resolve them before <code>from_dict</code> is called.</p> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Serialization method required for `MSONable` objects.\n\n    The OutputReferences are stored in `uuids_to_refs`. Jobflow will\n    resolve them before `from_dict` is called.\n    \"\"\"\n    uuids_to_refs = {k.uuid: k for k in self.futures_to_vals}\n    uuids_to_vals = {k.uuid: v for k, v in self.futures_to_vals.items()}\n    return {\n        \"@module\": self.__class__.__module__,\n        \"@class\": self.__class__.__name__,\n        \"uuids_to_refs\": uuids_to_refs,\n        \"uuids_to_vals\": uuids_to_vals,\n    }\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobflowCopy.do_copy","title":"do_copy","text":"<pre><code>do_copy(tgt_dir: str | Path)\n</code></pre> <p>Copy files from all source directories to the target directory.</p> <p>Parameters:</p> <ul> <li> <code>tgt_dir</code>               (<code>str | Path</code>)           \u2013            <p>The destination directory where files will be copied.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def do_copy(self, tgt_dir: str | Path):\n    \"\"\"\n    Copy files from all source directories to the target directory.\n\n    Parameters\n    ----------\n    tgt_dir\n        The destination directory where files will be copied.\n    \"\"\"\n    for src_dir, files in self.src_dir_to_files.items():\n        copy_decompress_files(src_dir, files, tgt_dir)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.JobflowCopy.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: str[str, Any])\n</code></pre> <p>Reconstruct from serialized dict after OutputReferences are resolved.</p> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: str[str, Any]):\n    \"\"\"\n    Reconstruct from serialized dict after OutputReferences are resolved.\n    \"\"\"\n    uuids_to_refs = d[\"uuids_to_refs\"]\n    uuids_to_vals = d[\"uuids_to_vals\"]\n    src_dir_to_files = {\n        uuids_to_refs[uuid]: files for uuid, files in uuids_to_vals.items()\n    }\n    return cls(src_dir_to_files=src_dir_to_files)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.PrefectOrParslCopy","title":"PrefectOrParslCopy","text":"<pre><code>PrefectOrParslCopy(\n    src_dir_to_files: dict[\n        PrefectFuture | AppFuture, str | list[str]\n    ],\n)\n</code></pre> <p>Copy implementation for Prefect and Parsl workflow engines.</p> <p>Both Prefect and Parsl use futures that are resolved via the <code>.result()</code> method. This class stores a mapping from future objects to files, and resolves each future when <code>do_copy</code> is called.</p> <p>Parameters:</p> <ul> <li> <code>src_dir_to_files</code>               (<code>dict[PrefectFuture | AppFuture, str | list[str]]</code>)           \u2013            <p>A mapping from future objects (representing source directories) to lists of files to copy from those directories.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def __init__(\n    self, src_dir_to_files: dict[PrefectFuture | AppFuture, str | list[str]]\n):\n    self.src_dir_to_files = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.PrefectOrParslCopy.src_dir_to_files","title":"src_dir_to_files  <code>instance-attribute</code>","text":"<pre><code>src_dir_to_files = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.PrefectOrParslCopy.do_copy","title":"do_copy","text":"<pre><code>do_copy(tgt_dir: str | Path)\n</code></pre> <p>Resolve futures and copy files to the target directory.</p> <p>Parameters:</p> <ul> <li> <code>tgt_dir</code>               (<code>str | Path</code>)           \u2013            <p>The destination directory where files will be copied.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def do_copy(self, tgt_dir: str | Path):\n    \"\"\"\n    Resolve futures and copy files to the target directory.\n\n    Parameters\n    ----------\n    tgt_dir\n        The destination directory where files will be copied.\n    \"\"\"\n    for future, files in self.src_dir_to_files.items():\n        copy_decompress_files(future.result(), files, tgt_dir)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.RedunCopy","title":"RedunCopy","text":"<pre><code>RedunCopy(src_dir_to_files: dict[Value, str | list[str]])\n</code></pre> <p>Copy implementation for the Redun workflow engine.</p> <p>Redun uses a lazy evaluation model where deferred values are only resolved when they cross a task boundary. This class wraps the copy operation in a redun <code>@task</code> to ensure that source directory values are properly resolved before the copy occurs.</p> <p>Parameters:</p> <ul> <li> <code>src_dir_to_files</code>               (<code>dict[Value, str | list[str]]</code>)           \u2013            <p>A mapping from redun Value objects (representing source directories) to lists of files to copy from those directories.</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def __init__(self, src_dir_to_files: dict[Value, str | list[str]]):\n    self.src_dir_to_files = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.RedunCopy.src_dir_to_files","title":"src_dir_to_files  <code>instance-attribute</code>","text":"<pre><code>src_dir_to_files = src_dir_to_files\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_argument.html#quacc.wflow_tools.job_argument.RedunCopy.do_copy","title":"do_copy","text":"<pre><code>do_copy(tgt_dir: str | Path)\n</code></pre> <p>Create redun tasks to copy files to the target directory.</p> <p>Unlike other implementations, this returns a list of redun task results rather than performing the copy immediately. Redun's scheduler will execute these tasks when their input dependencies are resolved.</p> <p>Parameters:</p> <ul> <li> <code>tgt_dir</code>               (<code>str | Path</code>)           \u2013            <p>The destination directory where files will be copied.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of redun task results (one per source directory).</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_argument.py</code> <pre><code>def do_copy(self, tgt_dir: str | Path):\n    \"\"\"\n    Create redun tasks to copy files to the target directory.\n\n    Unlike other implementations, this returns a list of redun task results\n    rather than performing the copy immediately. Redun's scheduler will\n    execute these tasks when their input dependencies are resolved.\n\n    Parameters\n    ----------\n    tgt_dir\n        The destination directory where files will be copied.\n\n    Returns\n    -------\n    list\n        A list of redun task results (one per source directory).\n    \"\"\"\n    from redun import task\n\n    @task\n    def _do_copy_task(src_dir, files, tgt_dir):\n        # At this task boundary, redun evaluates src_dir from a deferred\n        # value to its actual resolved value (the directory path string).\n        copy_decompress_files(src_dir, files, tgt_dir)\n\n    # Return a list of task invocations; redun will schedule these and\n    # resolve the src_dir values when their upstream dependencies complete.\n    return [\n        _do_copy_task(src_dir, files, tgt_dir)\n        for src_dir, files in self.src_dir_to_files.items()\n    ]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_patterns.html","title":"job_patterns","text":""},{"location":"reference/quacc/wflow_tools/job_patterns.html#quacc.wflow_tools.job_patterns.kwarg_map","title":"kwarg_map","text":"<pre><code>kwarg_map(\n    func: Callable,\n    unmapped_kwargs: dict[str, Any] | None = None,\n    **mapped_kwargs\n) -&gt; list[Any]\n</code></pre> <p>A helper function for when you want to construct a chain of objects with individual arguments for each one.  Can be easier to read than a list expansion.</p> <p>Adapted from https://stackoverflow.com/a/36575917 (CC-by-SA 3.0)</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The function to map.</p> </li> <li> <code>unmapped_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs to pass to func that shouldn't be mapped</p> </li> <li> <code>mapped_kwargs</code>           \u2013            <p>kwargs of the form key=list[...] that should be mapped over</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>List of results from calling func(**mapped_kwargs, **unmapped_kwargs) for each kwargs in mapped_kwargs</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_patterns.py</code> <pre><code>def kwarg_map(\n    func: Callable, unmapped_kwargs: dict[str, Any] | None = None, **mapped_kwargs\n) -&gt; list[Any]:\n    \"\"\"\n    A helper function for when you want to construct a chain of objects with individual arguments for each one.  Can\n    be easier to read than a list expansion.\n\n    Adapted from https://stackoverflow.com/a/36575917 (CC-by-SA 3.0)\n\n    Parameters\n    ----------\n    func\n        The function to map.\n    unmapped_kwargs\n        Dictionary of kwargs to pass to func that shouldn't be mapped\n    mapped_kwargs\n        kwargs of the form key=list[...] that should be mapped over\n\n    Returns\n    -------\n    list[Any]\n        List of results from calling func(**mapped_kwargs, **unmapped_kwargs) for each\n        kwargs in mapped_kwargs\n    \"\"\"\n    unmapped_kwargs = unmapped_kwargs or {}\n\n    all_lens = [len(v) for v in mapped_kwargs.values()]\n    n_elements = all_lens[0]\n    if not all(n_elements == le for le in all_lens):\n        raise AssertionError(f\"Inconsistent lengths: {all_lens}\")\n    return [\n        func(**{k: v[i] for k, v in iter(mapped_kwargs.items())}, **unmapped_kwargs)\n        for i in range(n_elements)\n    ]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_patterns.html#quacc.wflow_tools.job_patterns.map_partition","title":"map_partition","text":"<pre><code>map_partition(\n    func: Callable,\n    unmapped_kwargs: dict[str, Any] | None = None,\n    **mapped_kwargs\n) -&gt; list[Any]\n</code></pre> <p>Job to apply a function to each set of elements in mapped_kwargs.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The function to map.</p> </li> <li> <code>unmapped_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs to pass to func that shouldn't be mapped</p> </li> <li> <code>mapped_kwargs</code>           \u2013            <p>kwargs of the form key=list[...] that should be mapped over</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>list of results from calling func(**mapped_kwargs, **unmapped_kwargs) for each kwargs in mapped_kwargs</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_patterns.py</code> <pre><code>@job\ndef map_partition(\n    func: Callable, unmapped_kwargs: dict[str, Any] | None = None, **mapped_kwargs\n) -&gt; list[Any]:\n    \"\"\"\n    Job to apply a function to each set of elements in mapped_kwargs.\n\n    Parameters\n    ----------\n    func\n        The function to map.\n    unmapped_kwargs\n        Dictionary of kwargs to pass to func that shouldn't be mapped\n    mapped_kwargs\n        kwargs of the form key=list[...] that should be mapped over\n\n    Returns\n    -------\n    list[Any]\n        list of results from calling func(**mapped_kwargs, **unmapped_kwargs) for each\n        kwargs in mapped_kwargs\n    \"\"\"\n    return kwarg_map(func, unmapped_kwargs=unmapped_kwargs, **mapped_kwargs)\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_patterns.html#quacc.wflow_tools.job_patterns.map_partitioned_lists","title":"map_partitioned_lists","text":"<pre><code>map_partitioned_lists(\n    func: Callable,\n    num_partitions: int,\n    unmapped_kwargs: dict[str, Any] | None = None,\n    **mapped_kwargs: list[list[Any]]\n) -&gt; list[Any]\n</code></pre> <p>Given list-of-lists parameters (say a list of batches that we want to map over), apply func to each element of each list</p> <p>For example:</p> <pre><code>@job\ndef testjob(**kwargs):\n    print(kwargs)\n\n\n@flow\ndef testflow():\n    num_partitions = 2\n    result = map_partitioned_lists(\n        testjob,\n        num_partitions,\n        test_arg_1=partition([1, 2, 3, 4, 5], num_partitions),\n        test_arg_2=partition([\"a\", \"b\", \"c\", \"d\", \"e\"], num_partitions),\n    )\n\n\ntestflow()\n</code></pre> <p>should yield</p> <pre><code>{\"test_arg_1\": 1, \"test_arg_2\": \"a\"}\n{\"test_arg_1\": 2, \"test_arg_2\": \"b\"}\n{\"test_arg_1\": 3, \"test_arg_2\": \"c\"}\n{\"test_arg_1\": 4, \"test_arg_2\": \"d\"}\n{\"test_arg_1\": 5, \"test_arg_2\": \"e\"}\n</code></pre> <p>regardless of the number of partitions.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>The function to map.</p> </li> <li> <code>num_partitions</code>               (<code>int</code>)           \u2013            <p>the length of each kwarg in mapped_kwargs</p> </li> <li> <code>unmapped_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs to pass to func that shouldn't be mapped</p> </li> <li> <code>mapped_kwargs</code>               (<code>list[list[Any]]</code>, default:                   <code>{}</code> )           \u2013            <p>kwargs of the form key=list[...] that should be mapped over</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>list of results from calling func(**(mapped_kwargs | unmapped_kwargs)) for each kwargs in mapped_kwargs</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_patterns.py</code> <pre><code>def map_partitioned_lists(\n    func: Callable,\n    num_partitions: int,\n    unmapped_kwargs: dict[str, Any] | None = None,\n    **mapped_kwargs: list[list[Any]],\n) -&gt; list[Any]:\n    \"\"\"\n    Given list-of-lists parameters (say a list of batches that we want to map over),\n    apply func to each element of each list\n\n    For example:\n\n    ```python\n    @job\n    def testjob(**kwargs):\n        print(kwargs)\n\n\n    @flow\n    def testflow():\n        num_partitions = 2\n        result = map_partitioned_lists(\n            testjob,\n            num_partitions,\n            test_arg_1=partition([1, 2, 3, 4, 5], num_partitions),\n            test_arg_2=partition([\"a\", \"b\", \"c\", \"d\", \"e\"], num_partitions),\n        )\n\n\n    testflow()\n    ```\n\n    should yield\n\n    ```python\n    {\"test_arg_1\": 1, \"test_arg_2\": \"a\"}\n    {\"test_arg_1\": 2, \"test_arg_2\": \"b\"}\n    {\"test_arg_1\": 3, \"test_arg_2\": \"c\"}\n    {\"test_arg_1\": 4, \"test_arg_2\": \"d\"}\n    {\"test_arg_1\": 5, \"test_arg_2\": \"e\"}\n    ```\n\n    regardless of the number of partitions.\n\n\n    Parameters\n    ----------\n    func\n        The function to map.\n    num_partitions\n        the length of each kwarg in mapped_kwargs\n    unmapped_kwargs\n        Dictionary of kwargs to pass to func that shouldn't be mapped\n    mapped_kwargs\n        kwargs of the form key=list[...] that should be mapped over\n\n    Returns\n    -------\n    list[Any]\n        list of results from calling func(**(mapped_kwargs | unmapped_kwargs)) for each\n        kwargs in mapped_kwargs\n    \"\"\"\n\n    return [\n        map_partition(\n            strip_decorator(func),\n            unmapped_kwargs=unmapped_kwargs,\n            **{k: mapped_kwargs[k][i] for k in mapped_kwargs},\n        )\n        for i in range(num_partitions)\n    ]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_patterns.html#quacc.wflow_tools.job_patterns.partition","title":"partition","text":"<pre><code>partition(\n    list_to_partition: list, num_partitions: int\n) -&gt; list[Any]\n</code></pre> <p>Given a list, partition it into n roughly equal lists</p> <p>Parameters:</p> <ul> <li> <code>list_to_partition</code>               (<code>list</code>)           \u2013            <p>the list to partition</p> </li> <li> <code>num_partitions</code>               (<code>int</code>)           \u2013            <p>the number of partitions to output</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>n lists constructed from a</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_patterns.py</code> <pre><code>@job\ndef partition(list_to_partition: list, num_partitions: int) -&gt; list[Any]:\n    \"\"\"\n    Given a list, partition it into n roughly equal lists\n\n    Parameters\n    ----------\n    list_to_partition\n        the list to partition\n    num_partitions\n        the number of partitions to output\n\n    Returns\n    -------\n    list[Any]\n        n lists constructed from a\n    \"\"\"\n    k, m = divmod(len(list_to_partition), num_partitions)\n    return [\n        list_to_partition[i * k + min(i, m) : (i + 1) * k + min(i + 1, m)]\n        for i in range(num_partitions)\n    ]\n</code></pre>"},{"location":"reference/quacc/wflow_tools/job_patterns.html#quacc.wflow_tools.job_patterns.unpartition","title":"unpartition","text":"<pre><code>unpartition(lists_to_combine: list[list[Any]]) -&gt; list[Any]\n</code></pre> <p>Given a partitioned list (list of lists), recombine it to a single list</p> <p>Parameters:</p> <ul> <li> <code>lists_to_combine</code>               (<code>list[list[Any]]</code>)           \u2013            <p>the list of lists to recombine</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>a single recombined list</p> </li> </ul> Source code in <code>quacc/wflow_tools/job_patterns.py</code> <pre><code>@job\ndef unpartition(lists_to_combine: list[list[Any]]) -&gt; list[Any]:\n    \"\"\"\n    Given a partitioned list (list of lists), recombine\n    it to a single list\n\n    Parameters\n    ----------\n    lists_to_combine\n        the list of lists to recombine\n\n    Returns\n    -------\n    list[Any]\n        a single recombined list\n    \"\"\"\n    return list(itertools.chain(*lists_to_combine))\n</code></pre>"},{"location":"user/basics/wflow_decorators.html","title":"Workflow Decorators","text":""},{"location":"user/basics/wflow_decorators.html#introduction","title":"Introduction","text":"<p>Here, we provide code snippets for several decorator-based workflow engines. For a comparison of the pros and cons of each approach, refer to the Workflow Engines Overview page. We describe the specifics of how to use each workflow engine in more detail later in the documentation.</p>"},{"location":"user/basics/wflow_decorators.html#background","title":"Background","text":"<p>To help enable interoperability between workflow engines, quacc offers a unified set of decorators: <code>@job</code>, <code>@flow</code>, and <code>@subflow</code>.</p>"},{"location":"user/basics/wflow_decorators.html#job","title":"<code>@job</code>","text":"<p>A <code>@job</code> in quacc is an individual compute task. In the context of an HPC environment, this can typically be thought of as a compute task you would normally submit as a single job to the scheduler.</p>"},{"location":"user/basics/wflow_decorators.html#flow","title":"<code>@flow</code>","text":"<p>A <code>@flow</code> in quacc is a collection of one or more jobs. It defines the logic of the workflow, connecting the output of one job to the inputs of one or more other jobs. As a general guideline, the flow should not contain computations beyond those of the underlying jobs or subflows.</p>"},{"location":"user/basics/wflow_decorators.html#subflow","title":"<code>@subflow</code>","text":"<p>A <code>@subflow</code> in quacc is any workflow that returns a list of job outputs and where the number of jobs to be called is not necessarily known until runtime.</p> DaskParslPrefectRedunJobflow <p>Take a moment to read the Dask Delayed documentation overview page to get a sense of how the Dask decorators works and the Dask Distributed quickstart page to understand how to submit tasks to a Dask cluster. Namely, you should understand the <code>@delayed</code> decorator and how to interface with the <code>Client</code>.</p> Quacc Dask <code>@job</code> <code>@delayed</code> <code>@flow</code> No effect <code>@subflow</code> <code>@delayed</code> <p>Technically, there are some subtle differences between the <code>@delayed</code> decorator and the <code>quacc</code> equivalents, but for the purposes of this tutorial, you can think of them as similar.</p> <p>Take a moment to read the Parsl documentation's \"Quick Start\" to get a sense of how Parsl works. Namely, you should understand the concept of a <code>python_app</code> and <code>join_app</code>, which describe individual compute tasks and dynamic job tasks, respectively.</p> Quacc Parsl <code>@job</code> <code>@python_app</code> <code>@flow</code> No effect <code>@subflow</code> <code>@join_app</code> <p>Take a moment to read the Prefect documentation's Quickstart and Tutorials. Namely, you should understand the concept of a <code>@task</code> and a <code>@flow</code>, which describe individual compute tasks and workflows, respectively.</p> Quacc Prefect <code>@job</code> <code>@task</code> <code>@flow</code> <code>@flow</code> <code>@subflow</code> <code>@flow</code> <p>Take a moment to read the Redun documentation's Design Overview page to get a sense of how Redun works. Namely, you should understand the <code>Task</code> decorator and how to interface with the <code>Scheduler</code>.</p> Quacc Redun <code>@job</code> <code>@task</code> <code>@flow</code> <code>@task</code> <code>@subflow</code> <code>@task</code> <p>Take a moment to read the Jobflow documentation's Quick Start to get a sense of how Jobflow works. Namely, you should understand the concept of a <code>@job</code> and a <code>@flow</code>, which describe individual compute tasks and workflows, respectively.</p> Quacc Jobflow <code>@job</code> <code>@job</code> <code>@flow</code> <code>@flow</code> <code>@subflow</code> <code>@job</code> <p>The quacc descriptors are drop-in replacements for the specified workflow engine analogue, which we will use for the remainder of the tutorials. Based on the value for the <code>WORKFLOW_ENGINE</code> global variable in your quacc settings, the appropriate decorator will be automatically selected. If the <code>WORKFLOW_ENGINE</code> setting is set to <code>None</code> (i.e. <code>quacc set WORKFLOW_ENGINE None</code>), the decorators will have no effect on the underlying function.</p>"},{"location":"user/basics/wflow_overview.html","title":"Workflow Engines Overview","text":"<p>Everyone's computing needs are different, so we ensured that quacc is interoperable with a variety of modern workflow management tools. There are 300+ workflow management tools out there, so we can't possibly support them all. Instead, we have focused on a select few that adopt a similar decorator-based approach to defining workflows with substantial support for HPC systems.</p>"},{"location":"user/basics/wflow_overview.html#summary","title":"Summary","text":"<p>Recommendations</p> <p>Not sure which to choose? Generally, we recommend Jobflow for users of academic HPC systems with job schedulers. Otherwise, we recommend Prefect. Some additional opinions on the matter.</p> DaskParslPrefectRedunJobflow <p>Dask is a popular parallel computing library for Python. We use Dask Delayed for lazy function execution, Dask Distributed for distributed compute, and (optionally) Dask-Jobqueue for orchestrating the execution on HPC machines.</p> <p>Pros:</p> <ul> <li>Extremely popular</li> <li>Has native support for running on HPC resources</li> <li>It does not involve a centralized server or network connectivity</li> <li>Supports adaptive scaling of compute resources</li> <li>The dashboard to monitor resource usage is very intuitive</li> </ul> <p>Cons:</p> <ul> <li>If the Dask cluster dies, there is no mechanism to gracefully recover the workflow history</li> <li>Monitoring job progress is more challenging and less detailed than other solutions</li> <li>The documentation, while comprehensive, can be difficult to follow given the various Dask components</li> <li>Calculations cannot be submitted remotely or across disparate compute resources</li> </ul> <p>Parsl is a workflow management solution out of Argonne National Laboratory, the University of Chicago, and the University of Illinois. It is well-adapted for running on virtually any HPC environment with a job scheduler.</p> <p>Pros:</p> <ul> <li>Extremely configurable and deployable for virtually any HPC environment</li> <li>Quite simple to define the workflows and run them from a Jupyter Notebook</li> <li>Thorough documentation and active user community across academia</li> <li>Well-suited for pilot jobs and advanced queuing schemes</li> <li>Does not rely on maintaining a centralized server</li> </ul> <p>Cons:</p> <ul> <li>The number of different terms can be slightly overwhelming to those less familiar with HPC</li> <li>Monitoring job progress is more challenging and less detailed than other solutions</li> <li>Debugging failed workflows can be difficult</li> <li>The pilot job model is often a new concept to many HPC users that takes some time to understand</li> </ul> <p>Prefect is a workflow orchestration tool that is popular in the data engineering community. It has an excellent dashboard for monitoring workflows.</p> <p>Pros:</p> <ul> <li>Quite popular among the data engineering community</li> <li>Excellent web-based dashboard for monitoring workflow progress</li> <li>The free version of Prefect Cloud is reasonably generous</li> <li>Can use advanced queueing schemes to manage workflow execution</li> <li>New features are being added regularly and rapidly</li> </ul> <p>Cons:</p> <ul> <li>For those who are less HPC-savvy, some of the concepts can be quite technical</li> <li>If using Prefect Cloud, the compute nodes must have a network connection</li> <li>The dashboard, while useful for monitoring successes and failures, is not ideal for analyzing results</li> <li>The software is geared more towards data engineering than scientific computing, and that is reflected in the features and documentation</li> </ul> <p>Redun is a flexible workflow management program developed by Insitro.</p> <p>Pros:</p> <ul> <li>Extremely simple syntax for defining workflows</li> <li>Has strong support for task/result caching</li> <li>Useful CLI-based monitoring system</li> <li>Very strong AWS support</li> </ul> <p>Cons:</p> <ul> <li>Currently lacks support for typical HPC job schedulers</li> <li>No user-friendly GUI for job monitoring</li> <li>Does not have a particularly active user community</li> <li>Not updated frequently</li> </ul> <p>Jobflow is developed and maintained by the Materials Project team at Lawrence Berkeley National Laboratory and serves as a seamless interface to FireWorks or Jobflow Remote for dispatching and monitoring compute jobs.</p> <p>Pros:</p> <ul> <li>Native support for a variety of databases</li> <li>Directly compatible with Atomate2</li> <li>Designed with materials science workflows in mind</li> <li>Actively supported by the Materials Project team</li> </ul> <p>Cons:</p> <ul> <li>Is not fully compatible with all the features of <code>quacc</code></li> <li>Parsing the output of a workflow is not as intuitive as other solutions</li> <li>Defining dynamic workflows with Jobflow's <code>Response</code> object can be more complex than other solutions</li> </ul>"},{"location":"user/basics/wflow_syntax.html","title":"Workflow Syntax","text":""},{"location":"user/basics/wflow_syntax.html#simple-workflow","title":"Simple Workflow","text":"<p>Let's do the following:</p> <ol> <li>Add two numbers (e.g. <code>1 + 2</code>)</li> <li>Multiply the output of Step 1 by a third number (e.g. <code>3 * 3</code>)</li> </ol> <p>In practice, we would want each of the two tasks to be their own compute job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(add) --&gt; C(mult) --&gt; D[Output];</code></pre> DaskParslPrefectRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Dask client:</p> <pre><code>quacc set WORKFLOW_ENGINE dask\n</code></pre> python<pre><code>from dask.distributed import Client\n\nclient = Client()  #  (1)!\n</code></pre> <ol> <li>It is necessary to instantiate a Dask client before running Dask workflows. This command loads the default (local) client and only needs to be done once.</li> </ol> <pre><code>from quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\ndef workflow(a, b, c):  #  (2)!\n    output1 = add(a, b)\n    output2 = mult(output1, c)\n    return output2\n\n\ndelayed = workflow(1, 2, 3)  #  (3)!\nresult = client.compute(delayed).result()  #  (4)!\nprint(result)  # 9\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into a Dask <code>@delayed</code>.</p> </li> <li> <p>The <code>@flow</code> decorator doesn't actually do anything when using Dask, so we chose to not include it here for brevity.</p> </li> <li> <p>This returns a <code>Delayed</code> object. A reference is returned.</p> </li> <li> <p>There are multiple ways to resolve a <code>Delayed</code> object. Here, <code>client.compute(delayed)</code> will return a <code>Future</code> object, which can be resolved with <code>.result()</code>. The <code>.result()</code> call will block until the workflow is complete and return the result. As an alternative, you could also use <code>delayed.compute()</code> to dispatch and resolve the <code>Delayed</code> object in one command. Similarly, you could use <code>dask.compute(delayed)[0]</code>, where the <code>[0]</code> indexing is needed because <code>dask.compute()</code> always returns a tuple.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> <pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()  #  (1)!\n</code></pre> <ol> <li>It is necessary to instantiate a Parsl configuration before running Parsl workflows. This command loads the default (local) configuration and only needs to be done once.</li> </ol> <pre><code>from quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\ndef workflow(a, b, c):  #  (2)!\n    output1 = add(a, b)\n    output2 = mult(output1, c)\n    return output2\n\n\nfuture = workflow(1, 2, 3)  #  (3)!\nresult = future.result()  #  (4)!\nprint(result)  # 9\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into a Parsl <code>@python_app</code>.</p> </li> <li> <p>The <code>@flow</code> decorator doesn't actually do anything when using Parsl, so we chose to not include it here for brevity.</p> </li> <li> <p>This will create a <code>PythonApp</code> object that represents the workflow. At this point, the workflow has been dispatched, but only a reference is returned.</p> </li> <li> <p>Calling <code>.result()</code> will block until the workflow is complete and return the result.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable.</p> <pre><code>quacc set WORKFLOW_ENGINE prefect\n</code></pre> <pre><code>from quacc import flow, job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow\ndef workflow(a, b, c):  #  (2)!\n    output1 = add(a, b)\n    output2 = mult(output1, c)\n    return output2\n\n\nresult = workflow(1, 2, 3)  #  (3)!\nprint(result)  # 9\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into a Prefect <code>@task</code>. It will also be launched via <code>.submit()</code> if <code>SETTINGS.PREFECT_AUTO_SUBMIT</code> is <code>True</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will be transformed into a Prefect <code>@flow</code>.</p> </li> <li> <p>This will create and run the <code>Flow</code>. At this point, the workflow has been dispatched and the final results are returned.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> python<pre><code>from redun import Scheduler\n\nscheduler = Scheduler()  #  (1)!\n</code></pre> <ol> <li>It is necessary to instantiate the scheduler before submitting calculations.</li> </ol> <pre><code>from quacc import flow, job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\n@flow  #  (2)!\ndef workflow(a, b, c):\n    output1 = add(a, b)\n    output2 = mult(output1, c)\n    return output2\n\n\nresult = scheduler.run(workflow(1, 2, 3))  # (3)!\nprint(result)  # 9\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into a Redun <code>@task</code>.</p> </li> <li> <p>The <code>@flow</code> decorator will also be transformed into a Redun <code>@task</code>. Everything in Redun is a <code>@task</code>, so it doesn't matter what quacc decorator you apply. We chose <code>@flow</code> simply for clarity.</p> </li> <li> <p>This command will submit the workflow to the Redun scheduler.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\n</code></pre> <pre><code>import jobflow as jf\nfrom quacc import job\n\n\n@job  #  (1)!\ndef add(a, b):\n    return a + b\n\n\n@job\ndef mult(a, b):\n    return a * b\n\n\njob1 = add(1, 2)\njob2 = mult(job1.output, 3)\nflow = jf.Flow([job1, job2])  #  (2)!\n\nresponses = jf.run_locally(flow, ensure_success=True)  #  (3)!\nresult = responses[job2.uuid][1].output  #  (4)!\nprint(result)  # 9\n</code></pre> <ol> <li> <p>The <code>@job</code> decorator will be transformed into <code>@jf.job</code>.</p> </li> <li> <p>A <code>@jf.Flow</code> object is created to represent the workflow.</p> </li> <li> <p>The workflow is run locally and the result is returned in a dictionary.</p> </li> <li> <p>The result is extracted from the dictionary by using the UUID of the second job in the workflow.</p> </li> </ol> Stripping the Decorator from a Job <p>If you ever want to strip the decorator from a pre-decorated <code>@job</code> (e.g. to test out a calculation locally without changing your quacc settings), you can do so with quacc.wflow_tools.customizers.strip_decorator as follows:</p> <pre><code>from quacc import job, strip_decorator\n\n\n@job\ndef add(a, b):\n    return a + b\n\n\noriginal_add = strip_decorator(add)\noriginal_add(1, 2)  # 3\n</code></pre>"},{"location":"user/basics/wflow_syntax.html#learn-more","title":"Learn More","text":"DaskParslPrefectRedunJobflow <p>If you want to learn more about Dask, you can read the Dask Delayed documentation to read more about the decorators and the Dask Distributed documentation to read more about the distributed Dask cluster. Please refer to the Dask Discourse page for Dask-specific questions.</p> <p>If you want to learn more about Parsl, you can read the Parsl Documentation. Please refer to the Parsl Slack Channel for any Parsl-specific questions.</p> <p>If you want to learn more about Prefect, you can read the Prefect Documentation. Please refer to the Prefect community resources for any Prefect-specific questions.</p> <p>If you want to learn more about Redun, you can read the Redun documentation.</p> <p>If you want to learn more about Jobflow, you can read the Jobflow Documentation. Please refer to the Jobflow Discussions Board for Jobflow-specific questions.</p>"},{"location":"user/db/basics.html","title":"Setup and Storing Results","text":"<p>Here, we describe how to set up quacc with a database of your choosing.</p> General PurposePrefectJobflow <p>You can store the output of quacc jobs and flows in your database of choice by defining a Maggma data store.</p> <p>For instance, let's pretend you have decided to make a <code>MongoStore</code> be your database of choice. Instantiating that class might look like the following</p> <pre><code>from maggma.stores import MongoStore\n\nstore = MongoStore(\n    database=\"my_db_name\",\n    collection_name=\"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"my_hostname\",\n    port=27017,\n)\n</code></pre> <p>Then, to store results in your database, you can use the following script:</p> <pre><code>from maggma.stores import MongoStore\nfrom monty.json import jsanitize\n\n# Let `results` be of type `list[dict]` containing outputs from quacc recipes\n\n# Define your database details\nstore = MongoStore(\n    database=\"my_db_name\",\n    collection_name=\"my_collection_name\",\n    username=\"my_username\",\n    password=\"my_password\",\n    host=\"my_hostname\",\n    port=27017,\n)\n\n# Store the results\nsanitized_results = [\n    jsanitize(result, enum_values=True, recursive_msonable=True) for result in results\n]\n\nfor result in sanitized_results:\n    result[\"uuid\"] = str(uuid.uuid4())\n\nwith store:\n    store.update(sanitized_results, key=\"uuid\")\n</code></pre> <p>To use a database with Prefect, read the Database section of the Prefect documentation as well as how to persist results.</p> <p>If you are using Jobflow to construct your workflows, it will automatically store the results in the database you defined during the setup process. No additional steps are needed.</p>"},{"location":"user/db/context.html","title":"Database Options","text":""},{"location":"user/db/context.html#why-use-a-database","title":"Why Use a Database?","text":"<p>In most cases, it is beneficial to store the results in a database for easy querying (like the example below). This is quite simple to do in quacc regardless of the workflow manager you are using by taking advantage of the numerous data store options in maggma.</p> <p></p>"},{"location":"user/db/context.html#choosing-a-data-store-option","title":"Choosing a Data Store Option","text":"<p>Some workflow engines supported by quacc, such as Jobflow and Prefect already involve a database for storing results. In these cases, you can simply use the database provided by the workflow engine. However, if you are using a workflow engine that does not provide a database or not using a workflow engine at all, you may wish to use one directly supported by quacc.</p> <p>The supported data store options are all those provided by maggma. At the time of writing, the most popular options is the <code>MongoStore</code> for interfacing with MongoDB.</p>"},{"location":"user/misc/file_transfers.html","title":"Transferring Files","text":""},{"location":"user/misc/file_transfers.html#local-file-transfers","title":"Local File Transfers","text":""},{"location":"user/misc/file_transfers.html#transfers-from-a-known-file-location","title":"Transfers from a Known File Location","text":"<p>Sometimes, you may want to transfer files between jobs. Many recipes within quacc take an optional keyword argument, <code>copy_files</code> for this purpose.</p> <p>The <code>copy_files</code> keyword argument takes two forms. The first form is simply a <code>SourceDirectory</code>, which is a <code>str</code> or <code>Path</code> object that points to the directory containing the files you wish to copy (and decompress) to the runtime directory. For instance, if you have gzipped files from a previous run in <code>/my/folder</code> that you want to copy and decompress to your new runtime directory, then you could ensure that this is achieved as follows:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job\n\nrelax_job(atoms, copy_files=\"/my/folder\")\n</code></pre> <p>The second form is a dictionary where the keys are the source folders and the values are the names of the files you wish to have copied to the directory where the calculation is ultimately run. For instance, if you have the files <code>CHGCAR.gz</code> and <code>WAVECAR.gz</code> stored in <code>/my/folder</code>, then you could ensure that they are present (and decompressed) in the calculation's working directory as follows:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job\n\natoms = bulk(\"Cu\")\nrelax_job(atoms, copy_files={\"/my/folder\": [\"CHGCAR.gz\", \"WAVECAR.gz\"]})\n</code></pre> <p>You can also copy a specific file from a directory while retaining the directory structure. For instance, if you have the file <code>/my/folder/WAVECAR.gz</code> and you want to copy it to the calculation's working directory as <code>folder/WAVECAR.gz</code>, you can do so as follows:</p> <pre><code>relax_job(atoms, copy_files={\"/my\": [\"folder/WAVECAR.gz\"]})\n</code></pre> <p>Glob Patterns</p> <p>The <code>copy_files</code> keyword argument also supports glob patterns for the filenames, such as <code>WAVECAR*</code> to copy all files that start with <code>WAVECAR</code> from the source.</p>"},{"location":"user/misc/file_transfers.html#transfers-between-jobs","title":"Transfers Between Jobs","text":"<p>Sometimes, however, you may not necessarily know a priori where the source file is. For instance, perhaps you want to copy (and decompress) the file <code>WAVECAR.gz</code> from a previous job in your workflow that is stored in a unique directory only determined at runtime. In this scenario, you can still use the <code>copy_files</code> keyword argument, but you will need to fetch the prior job's directory.</p> <pre><code>from pathlib import Path\nfrom ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\natoms = bulk(\"Cu\")\nresults1 = relax_job(atoms)\nstatic_job(results1[\"atoms\"], copy_files={results1[\"dir_name\"]: [\"WAVECAR.gz\"]})\n</code></pre>"},{"location":"user/misc/file_transfers.html#non-local-file-transfers","title":"Non-Local File Transfers","text":"<p>If using quacc across distributed computing environments, there may not be a guarantee that the file you wish to transfer is even on the same machine as your current job. In this scenario, the best approach is to create a dedicated file staging area on your machine of choice where you can store files you wish to transfer.</p> <p>For instance, if using a job scheduler like Slurm, you could have a step in your job script that copies files (e.g. via <code>scp</code>) from a remote location to a local staging area. Then, you can use the <code>copy_files</code> keyword argument to copy the files from the staging area to the calculation's working directory.</p> <p>Alternatively, several of the supported workflow managers have built-in options to enable file staging.</p>"},{"location":"user/misc/restarts.html","title":"Restarts","text":""},{"location":"user/misc/restarts.html#parsl","title":"Parsl","text":"<p><code>quacc</code> supports restarting calculations when using Parsl as the workflow engine. This is achieved through Parsl's memoization system, which caches results based on the function and its input arguments.</p>"},{"location":"user/misc/restarts.html#how-it-works","title":"How it Works","text":"<p>When using Parsl, <code>quacc</code> automatically registers a special hashing function that creates unique identifiers for ASE <code>Atoms</code> objects. This allows Parsl to recognize when the same calculation is being attempted on identical atomic structures. More information about Parsl memoization can be found in the Parsl documentation.</p> <p>Warning</p> <p>The hashing excludes the <code>.info</code> dictionary and calculator, focusing only on main properties (e.g., positions, numbers, cell, ...). For exact details, see the <code>ase.Atoms.fromdict</code> method.</p>"},{"location":"user/misc/restarts.html#usage","title":"Usage","text":"<p>To enable restart capabilities in your Parsl workflows, you need to:</p> <ol> <li>Configure Parsl's checkpointing behavior.</li> <li>Enable caching for the jobs you wish to checkpoint using <code>cache=True</code> in the job decorator.</li> </ol> <p>Here's an example:</p> <pre><code>import parsl\nfrom ase.build import bulk\nfrom parsl.config import Config\nfrom parsl.utils import get_last_checkpoint\n\nfrom quacc import job\nfrom quacc.recipes.vasp.core import relax_job\nfrom quacc.wflow_tools.customizers import redecorate\n\nconfig = Config(...)\n\nparsl.load(config)\n\n# Configure Parsl to checkpoint at the end of each task and every 30 minutes\nconfig.checkpoint_mode = \"task_exit\"\nconfig.checkpoint_period = \"00:30:00\"\n\n# Load the last checkpoint, necessary when restarting\nconfig.checkpoint_files = get_last_checkpoint()\n\n# Enable restart capabilities by decorating the job with cache=True\nrestart_enabled_relax_job = redecorate(relax_job, job(cache=True))\n\n# Create an atoms object and run the calculation\natoms = bulk(\"Cu\", cubic=True)\n\nfuture = relax_job(atoms)\nresults = future.result()\n</code></pre> <p>When restarted, Parsl will compare the hash of the various parameters passed to the job function with the hashes stored in the cache. If a match is found, Parsl will return the cached results instead of recomputing them. Results are only reused if the exact same calculation with identical inputs is attempted.</p> <p>Warning</p> <p>In addition to Parsl's in-built hashing functions for standard types (<code>list</code>, <code>dict</code>, ...) Quacc provides a custom hashing function for ASE <code>Atoms</code> objects. If you need to run jobs with other, complex objects as inputs (e.g., <code>Phonopy</code> objects) you may need to register additional hashing functions.</p>"},{"location":"user/misc/restarts.html#technical-details","title":"Technical Details","text":"<p>The hashing implementation can be found in <code>quacc.atoms.core</code>:</p> <ul> <li><code>_encode_atoms</code>: Handles the actual encoding of Atoms objects.</li> <li><code>get_atoms_id_parsl</code>: Creates Parsl-compatible byte hashes.</li> <li>The hashing function is automatically registered when Parsl is selected as the workflow engine.</li> </ul>"},{"location":"user/recipes/recipes_intro.html","title":"Intro to Jobs","text":"<p>In quacc, each code comes with pre-packaged jobs and workflows, which we collectively call recipes. This tutorial walks you through how to use these provided recipes to run simple calculations that can be tested out on your local machine. We'll start with an introduction to jobs, which are individual calculations that can be stitched together.</p>"},{"location":"user/recipes/recipes_intro.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you are not yet familiar with the ASE <code>Atoms</code> object, you should read the ASE tutorial. Additionally, it is worthwhile to be familiar with the basics of an ASE Calculator. The \"Open Science with ASE: Core Tutorials\" is an excellent resource for learning about the basics of ASE.</p> <p>Note</p> <p>Since we are not using a workflow engine for these examples, run the following in the command line:</p> <pre><code>quacc set WORKFLOW_ENGINE None\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#examples","title":"Examples","text":""},{"location":"user/recipes/recipes_intro.html#a-simple-calculation-with-emt","title":"A Simple Calculation with EMT","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C[Output]</code></pre> <p>Let's start with a simple example. Here, we will use a cheap calculator based on effective medium theory (EMT) to run a structure relaxation on a bulk structure of copper. We are interested in doing a structure relaxation, so we will use the quacc.recipes.emt.core.relax_job recipe, as demonstrated below. Most recipes in quacc take an <code>Atoms</code> object as the first positional argument and will return a dictionary that summarizes the output.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation on the Atoms object\nresult = relax_job(atoms)\nprint(result)\n</code></pre> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 22, 22, 334535),\n                'emmet_version': '0.82.0',\n                'pymatgen_version': '2024.6.10'},\n'chemsys': 'Cu',\n'composition': Composition('Cu1'),\n'composition_reduced': Composition('Cu1'),\n'converged': True,\n'density': 8.971719800606017,\n'density_atomic': 11.761470249999999,\n'dir_name': '/mnt/c/Users/asros/Desktop/quacc-2024-06-17-18-22-22-249452-41421',\n'elements': [Element Cu],\n'formula_anonymous': 'A',\n'formula_pretty': 'Cu',\n'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n                'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 22, 22, 333682),\n                                'emmet_version': '0.82.0',\n                                'pymatgen_version': '2024.6.10'},\n                'chemsys': 'Cu',\n                'composition': Composition('Cu1'),\n                'composition_reduced': Composition('Cu1'),\n                'density': 8.971719800606017,\n                'density_atomic': 11.761470249999999,\n                'elements': [Element Cu],\n                'formula_anonymous': 'A',\n                'formula_pretty': 'Cu',\n                'nelements': 1,\n                'nsites': 1,\n                'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                            'number': 225,\n                            'point_group': 'm-3m',\n                            'symbol': 'Fm-3m',\n                            'symprec': 0.1,\n                            'version': '2.4.0'},\n                'volume': 11.761470249999999},\n'name': 'EMT Relax',\n'nelements': 1,\n'nid': 'rosen.',\n'nsites': 1,\n'parameters': {'asap_cutoff': False},\n'parameters_opt': {'alpha': 70.0,\n                    'max_steps': 1000,\n                    'maxstep': 0.2,\n                    'optimizer': 'BFGS',\n                    'type': 'optimization'},\n'quacc_version': '0.8.1',\n'results': {'energies': array([-0.00568151]),\n            'energy': -0.005681511358581304,\n            'forces': array([[-3.14977672e-16,  1.01949224e-15,  3.66995236e-16]]),\n            'free_energy': -0.005681511358581304,\n            'stress': array([1.36192652e-02, 1.36192652e-02, 1.36192652e-02, 0.00000000e+00,\n    7.55159347e-17, 1.47492060e-19])},\n'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\nangles : 60.00000000000001 60.00000000000001 60.00000000000001\nvolume : 11.761470249999999\n    A : 0.0 1.805 1.805\n    B : 1.805 0.0 1.805\n    C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.4.0'},\n'trajectory': [Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]])],\n'trajectory_results': [{'energies': array([-0.00568151]),\n                        'energy': -0.005681511358581304,\n                        'forces': array([[-3.14977672e-16,  1.01949224e-15,  3.66995236e-16]]),\n                        'free_energy': -0.005681511358581304,\n                        'stress': array([1.36192652e-02, 1.36192652e-02, 1.36192652e-02, 0.00000000e+00,\n    7.55159347e-17, 1.47492060e-19])}],\n'volume': 11.761470249999999}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#a-mixed-code-workflow","title":"A Mixed-Code Workflow","text":"<pre><code>graph LR\n  A[Input] --&gt; B(EMT Relax) --&gt; C(GFN2-xTB Static) --&gt; D[Output]</code></pre> <p>Now let's add on a bit of complexity. Here, we will use EMT to run a relaxation on the bulk Cu structure and then use the output of this calculation as the input to a static calculation with the semi-empirical quantum mechanics method GFN2-xTB as implemented in quacc.recipes.tblite.core.static_job.</p> <p>This example highlights how there are no restrictions in terms of how many codes you can use in a single workflow. It also briefly demonstrates how you can specify optional parameters of a given job, as we will elaborate further in the next example.</p> <p>Note</p> <p>Some codes require additional setup, including <code>tblite</code>. Refer to the Calculator Setup section for details.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.tblite.core import static_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation with EMT\nresult1 = relax_job(atoms)\n\n# Run a static calculation with GFN2-xTB\nresult2 = static_job(result1[\"atoms\"], method=\"GFN2-xTB\")  # (1)!\nprint(result2)\n</code></pre> <ol> <li>We have to pass an <code>Atoms</code> object to the <code>static_job</code> recipe, so we parse it from <code>result1</code> output dictionary. We also have specified an optional parameter, <code>method</code>. Refer to the function signature for the <code>static_job</code> recipe to see the full list of parameters that can be specified.</li> </ol> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 25, 25, 853559),\n                'emmet_version': '0.83.6',\n                'pymatgen_version': '2024.6.10'},\n'chemsys': 'Cu',\n'composition': Composition('Cu1'),\n'composition_reduced': Composition('Cu1'),\n'density': 8.971719800606017,\n'density_atomic': 11.761470249999999,\n'dir_name': '/mnt/c/Users/asros/github/quacc/quacc-2024-06-17-18-25-25-482739-76656',\n'elements': [Element Cu],\n'formula_anonymous': 'A',\n'formula_pretty': 'Cu',\n'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n                'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 25, 25, 852522),\n                                'emmet_version': '0.83.6',\n                                'pymatgen_version': '2024.6.10'},\n                'chemsys': 'Cu',\n                'composition': Composition('Cu1'),\n                'composition_reduced': Composition('Cu1'),\n                'density': 8.971719800606017,\n                'density_atomic': 11.761470249999999,\n                'elements': [Element Cu],\n                'formula_anonymous': 'A',\n                'formula_pretty': 'Cu',\n                'nelements': 1,\n                'nsites': 1,\n                'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                            'number': 225,\n                            'point_group': 'm-3m',\n                            'symbol': 'Fm-3m',\n                            'symprec': 0.1,\n                            'version': '2.4.0'},\n                'volume': 11.761470249999999},\n'name': 'TBLite Static',\n'nelements': 1,\n'nid': 'rosen.',\n'nsites': 1,\n'parameters': {'accuracy': 1.0,\n                'cache_api': True,\n                'electronic_temperature': 300.0,\n                'max_iterations': 250,\n                'method': 'GFN2-xTB',\n                'verbosity': 1},\n'quacc_version': '0.9.6',\n'results': {'charges': array([-4.66053862e-11]),\n            'dipole': array([-8.02234177e-08,  1.96331282e-07, -5.14078572e-08]),\n            'energy': -318.8584605831615,\n            'forces': array([[5.44452313e-20, 5.39007790e-19, 2.45003541e-19]]),\n            'free_energy': -318.8584605831615,\n            'stress': array([14.65181119, 14.65181119, 14.65181119,  1.40704868,  1.01943286,\n        0.63181703])},\n'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\nangles : 60.00000000000001 60.00000000000001 60.00000000000001\nvolume : 11.761470249999999\n    A : 0.0 1.805 1.805\n    B : 1.805 0.0 1.805\n    C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.4.0'},\n'volume': 11.761470249999999}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#modifying-parameters-of-a-job","title":"Modifying Parameters of a Job","text":"<p>As demonstrated in the previous example, each recipe accepts optional keyword arguments to modify the default parameters. To identify the possible parameters a function takes, you'll want to check out the function signature and corresponding documentation, like that for quacc.recipes.emt.core.relax_job. Go ahead; click it! Once you do, you'll see from the docstring that there is one required positional argument for the recipe (the <code>Atoms</code> object) and several optional keyword arguments.</p>"},{"location":"user/recipes/recipes_intro.html#setting-custom-ase-calculator-parameters","title":"Setting Custom ASE Calculator Parameters","text":"<p>All recipes in quacc allow you to pass in a custom set of keyword arguments to the underlying ASE calculator so that you have full control over the parameters (as specified via <code>**calc_kwargs</code> in the function signature). For instance, ASE's <code>EMT</code> calculator can take an optional parameter <code>asap_cutoff</code>. We show how to pass this parameter to the <code>relax_job</code> recipe in the example below.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation with modified EMT calculator parameters\nresult = relax_job(atoms, asap_cutoff=True)\nprint(result)\n</code></pre> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 20, 40, 231408),\n                'emmet_version': '0.82.0',\n                'pymatgen_version': '2024.6.10'},\n'chemsys': 'Cu',\n'composition': Composition('Cu1'),\n'composition_reduced': Composition('Cu1'),\n'converged': True,\n'density': 8.971719800606017,\n'density_atomic': 11.761470249999999,\n'dir_name': '/mnt/c/Users/asros/Desktop/quacc-2024-06-17-18-20-40-132724-86476',\n'elements': [Element Cu],\n'formula_anonymous': 'A',\n'formula_pretty': 'Cu',\n'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n                'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 20, 40, 229796),\n                                'emmet_version': '0.82.0',\n                                'pymatgen_version': '2024.6.10'},\n                'chemsys': 'Cu',\n                'composition': Composition('Cu1'),\n                'composition_reduced': Composition('Cu1'),\n                'density': 8.971719800606017,\n                'density_atomic': 11.761470249999999,\n                'elements': [Element Cu],\n                'formula_anonymous': 'A',\n                'formula_pretty': 'Cu',\n                'nelements': 1,\n                'nsites': 1,\n                'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                            'number': 225,\n                            'point_group': 'm-3m',\n                            'symbol': 'Fm-3m',\n                            'symprec': 0.1,\n                            'version': '2.4.0'},\n                'volume': 11.761470249999999},\n'name': 'EMT Relax',\n'nelements': 1,\n'nid': 'rosen.',\n'nsites': 1,\n'parameters': {'asap_cutoff': True},\n'parameters_opt': {'alpha': 70.0,\n                    'max_steps': 1000,\n                    'maxstep': 0.2,\n                    'optimizer': 'BFGS',\n                    'type': 'optimization'},\n'quacc_version': '0.8.1',\n'results': {'energies': array([-0.00060116]),\n            'energy': -0.0006011628239370737,\n            'forces': array([[1.18655086e-15, 1.15706056e-15, 3.16066617e-15]]),\n            'free_energy': -0.0006011628239370737,\n            'stress': array([0.01169831, 0.01169831, 0.01169831, 0.        , 0.        ,\n    0.        ])},\n'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\nangles : 60.00000000000001 60.00000000000001 60.00000000000001\nvolume : 11.761470249999999\n    A : 0.0 1.805 1.805\n    B : 1.805 0.0 1.805\n    C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.4.0'},\n'trajectory': [Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]])],\n'trajectory_results': [{'energies': array([-0.00060116]),\n                        'energy': -0.0006011628239370737,\n                        'forces': array([[1.18655086e-15, 1.15706056e-15, 3.16066617e-15]]),\n                        'free_energy': -0.0006011628239370737,\n                        'stress': array([0.01169831, 0.01169831, 0.01169831, 0.        , 0.        ,\n    0.        ])}],\n'volume': 11.761470249999999}\n</code></pre>"},{"location":"user/recipes/recipes_intro.html#specifying-keyword-arguments-to-the-job","title":"Specifying Keyword Arguments to the Job","text":"<p>One of these optional keyword arguments for quacc.recipes.emt.core.relax_job is <code>relax_cell</code>, which sets whether the cell should be relaxed. By default, this parameter is set to <code>False</code>. We will go ahead and set it to <code>True</code> in the example below.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation, including cell relaxation\nresult = relax_job(atoms, relax_cell=True)\nprint(result)\n</code></pre> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[3.237103763481748e-17, 1.7947995601681468, 1.794799560168147], [1.7947995601681463, 1.6830370083537554e-16, 1.7947995601681468], [1.7947995601681463, 1.7947995601681466, 2.5911916198566743e-16]]),\n'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 18, 43, 595725),\n                'emmet_version': '0.82.0',\n                'pymatgen_version': '2024.6.10'},\n'chemsys': 'Cu',\n'composition': Composition('Cu1'),\n'composition_reduced': Composition('Cu1'),\n'converged': True,\n'density': 9.125558571548108,\n'density_atomic': 11.563195249785407,\n'dir_name': '/mnt/c/Users/asros/Desktop/quacc-2024-06-17-18-18-43-397414-52347',\n'elements': [Element Cu],\n'formula_anonymous': 'A',\n'formula_pretty': 'Cu',\n'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n                'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 18, 43, 588430),\n                                'emmet_version': '0.82.0',\n                                'pymatgen_version': '2024.6.10'},\n                'chemsys': 'Cu',\n                'composition': Composition('Cu1'),\n                'composition_reduced': Composition('Cu1'),\n                'density': 8.971719800606017,\n                'density_atomic': 11.761470249999999,\n                'elements': [Element Cu],\n                'formula_anonymous': 'A',\n                'formula_pretty': 'Cu',\n                'nelements': 1,\n                'nsites': 1,\n                'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                            'number': 225,\n                            'point_group': 'm-3m',\n                            'symbol': 'Fm-3m',\n                            'symprec': 0.1,\n                            'version': '2.4.0'},\n                'volume': 11.761470249999999},\n'name': 'EMT Relax',\n'nelements': 1,\n'nid': 'rosen.',\n'nsites': 1,\n'parameters': {'asap_cutoff': False},\n'parameters_opt': {'alpha': 70.0,\n                    'max_steps': 1000,\n                    'maxstep': 0.2,\n                    'optimizer': 'BFGS',\n                    'type': 'optimization'},\n'quacc_version': '0.8.1',\n'results': {'energies': array([-0.00703632]),\n            'energy': -0.007036318158828436,\n            'forces': array([[-1.59440590e-15,  2.41710031e-15,  8.65930422e-15]]),\n            'free_energy': -0.007036318158828436,\n            'stress': array([-1.58924696e-04, -1.58924696e-04, -1.58924696e-04,  2.30432437e-16,\n        7.68108123e-17,  1.89824193e-17])},\n'structure': Structure Summary\nLattice\n    abc : 2.538229879731059 2.538229879731059 2.5382298797310585\nangles : 59.99999999999999 59.99999999999999 59.99999999999999\nvolume : 11.563195249785407\n    A : 3.237103763481748e-17 1.7947995601681468 1.794799560168147\n    B : 1.7947995601681463 1.6830370083537554e-16 1.7947995601681468\n    C : 1.7947995601681463 1.7947995601681466 2.5911916198566743e-16\n    pbc : True True True\nPeriodicSite: Cu (1.426e-17, 4.785e-18, 2.908e-17) [5.462e-18, 1.074e-17, -2.796e-18],\n'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.4.0'},\n'trajectory': [Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n                Atoms(symbols='Cu', pbc=True, cell=[[-2.2894595839080307e-17, 1.800874299952309, 1.800874299952309], [1.8008742999523093, -4.462884179157955e-20, 1.800874299952309], [1.8008742999523093, 1.800874299952309, -2.2849966997288728e-17]]),\n                Atoms(symbols='Cu', pbc=True, cell=[[3.237103763481748e-17, 1.7947995601681468, 1.794799560168147], [1.7947995601681463, 1.6830370083537554e-16, 1.7947995601681468], [1.7947995601681463, 1.7947995601681466, 2.5911916198566743e-16]])],\n'trajectory_results': [{'energies': array([-0.00568151]),\n                        'energy': -0.005681511358581304,\n                        'forces': array([[-3.14977672e-16,  1.01949224e-15,  3.66995236e-16]]),\n                        'free_energy': -0.005681511358581304,\n                        'stress': array([1.36192652e-02, 1.36192652e-02, 1.36192652e-02, 0.00000000e+00,\n    7.55159347e-17, 1.47492060e-19])},\n                        {'energies': array([-0.00655972]),\n                        'energy': -0.006559723374008897,\n                        'forces': array([[ 5.33690684e-16, -2.55246602e-16,  6.79425456e-16]]),\n                        'free_energy': -0.006559723374008897,\n                        'stress': array([ 8.17600510e-03,  8.17600510e-03,  8.17600510e-03, -2.28108398e-16,\n    -7.60361327e-17,  1.22198354e-18])},\n                        {'energies': array([-0.00703632]),\n                        'energy': -0.007036318158828436,\n                        'forces': array([[-1.59440590e-15,  2.41710031e-15,  8.65930422e-15]]),\n                        'free_energy': -0.007036318158828436,\n                        'stress': array([-1.58924696e-04, -1.58924696e-04, -1.58924696e-04,  2.30432437e-16,\n        7.68108123e-17,  1.89824193e-17])}],\n'volume': 11.563195249785407}\n</code></pre> <p>You will also see that quacc.recipes.emt.core.relax_job takes an <code>opt_params</code> keyword argument that allows you to pass in a dictionary of parameters to the optimizer. That may look something like the following.</p> <pre><code>from ase.build import bulk\nfrom ase.optimize import LBFGS\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run a structure relaxation with modified optimizer parameters\nresult = relax_job(atoms, opt_params={\"fmax\": 1e-3, \"optimizer\": LBFGS})\nprint(result)\n</code></pre> Printed Output <pre><code>{'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 47, 36, 394332),\n                'emmet_version': '0.83.6',\n                'pymatgen_version': '2024.6.10'},\n'chemsys': 'Cu',\n'composition': Composition('Cu1'),\n'composition_reduced': Composition('Cu1'),\n'converged': True,\n'density': 8.971719800606017,\n'density_atomic': 11.761470249999999,\n'dir_name': '/mnt/c/Users/asros/github/quacc/quacc-2024-06-17-18-47-36-174854-98734',\n'elements': [Element Cu],\n'formula_anonymous': 'A',\n'formula_pretty': 'Cu',\n'input_atoms': {'atoms': Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]]),\n                'builder_meta': {'build_date': datetime.datetime(2024, 6, 17, 18, 47, 36, 393460),\n                                'emmet_version': '0.83.6',\n                                'pymatgen_version': '2024.6.10'},\n                'chemsys': 'Cu',\n                'composition': Composition('Cu1'),\n                'composition_reduced': Composition('Cu1'),\n                'density': 8.971719800606017,\n                'density_atomic': 11.761470249999999,\n                'elements': [Element Cu],\n                'formula_anonymous': 'A',\n                'formula_pretty': 'Cu',\n                'nelements': 1,\n                'nsites': 1,\n                'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n                            'number': 225,\n                            'point_group': 'm-3m',\n                            'symbol': 'Fm-3m',\n                            'symprec': 0.1,\n                            'version': '2.4.0'},\n                'volume': 11.761470249999999},\n'name': 'EMT Relax',\n'nelements': 1,\n'nid': 'rosen.',\n'nsites': 1,\n'parameters': {'asap_cutoff': False},\n'parameters_opt': {'fmax': 0.001,\n                    'max_steps': 1000,\n                    'maxstep': 0.2,\n                    'optimizer': 'LBFGS',\n                    'type': 'optimization'},\n'quacc_version': '0.9.6',\n'results': {'energies': array([-0.00568151]),\n            'energy': -0.005681511358581304,\n            'forces': array([[-3.14977672e-16,  1.01949224e-15,  3.66995236e-16]]),\n            'free_energy': -0.005681511358581304,\n            'stress': array([1.36192652e-02, 1.36192652e-02, 1.36192652e-02, 0.00000000e+00,\n    7.55159347e-17, 1.47492060e-19])},\n'structure': Structure Summary\nLattice\n    abc : 2.5526554800834367 2.5526554800834367 2.5526554800834367\nangles : 60.00000000000001 60.00000000000001 60.00000000000001\nvolume : 11.761470249999999\n    A : 0.0 1.805 1.805\n    B : 1.805 0.0 1.805\n    C : 1.805 1.805 0.0\n    pbc : True True True\nPeriodicSite: Cu (0.0, 0.0, 0.0) [0.0, 0.0, 0.0],\n'symmetry': {'crystal_system': &lt;CrystalSystem.cubic: 'Cubic'&gt;,\n            'number': 225,\n            'point_group': 'm-3m',\n            'symbol': 'Fm-3m',\n            'symprec': 0.1,\n            'version': '2.4.0'},\n'trajectory': [Atoms(symbols='Cu', pbc=True, cell=[[0.0, 1.805, 1.805], [1.805, 0.0, 1.805], [1.805, 1.805, 0.0]])],\n'trajectory_results': [{'energies': array([-0.00568151]),\n                        'energy': -0.005681511358581304,\n                        'forces': array([[-3.14977672e-16,  1.01949224e-15,  3.66995236e-16]]),\n                        'free_energy': -0.005681511358581304,\n                        'stress': array([1.36192652e-02, 1.36192652e-02, 1.36192652e-02, 0.00000000e+00,\n    7.55159347e-17, 1.47492060e-19])}],\n'volume': 11.761470249999999}\n</code></pre>"},{"location":"user/recipes/torchsim.html","title":"TorchSim Recipes","text":"<p>This tutorial introduces quacc's TorchSim recipes, which provide a high-level interface for running batched molecular dynamics simulations, geometry optimizations, and static calculations using machine learning potentials. The quacc TorchSim recipes wrap TorchSim's high-level API while providing workflow engine compatibility, automatic trajectory handling, and standardized output schemas.</p>"},{"location":"user/recipes/torchsim.html#pre-requisites","title":"Pre-Requisites","text":"<p>Before using the TorchSim recipes, you need to install TorchSim and at least one machine learning potential:</p> <pre><code>pip install torch-sim mace-torch\n</code></pre> <p>You should also be familiar with ASE Atoms objects and have read the Intro to Jobs tutorial.</p> <p>Note</p> <p>Since we are not using a workflow engine for these examples, run the following in the command line:</p> <pre><code>quacc set WORKFLOW_ENGINE None\n</code></pre>"},{"location":"user/recipes/torchsim.html#overview","title":"Overview","text":"<p>The quacc TorchSim recipes provide three main jobs:</p> <ol> <li><code>relax_job</code> - Geometry optimization using batched optimizers</li> <li><code>md_job</code> - Molecular dynamics simulations with various integrators</li> <li><code>static_job</code> - Single-point energy/force/stress calculations</li> </ol> <p>Key features include:</p> <ul> <li>Batch processing: Simulate multiple systems in a single job</li> <li>Autobatching: Automatically manage GPU memory for large batches</li> <li>Trajectory reporting: Save trajectories and computed properties</li> <li>Workflow compatibility: Works with all quacc-supported workflow engines</li> </ul>"},{"location":"user/recipes/torchsim.html#basic-geometry-optimization","title":"Basic Geometry Optimization","text":"<p>Let's start with a simple geometry optimization. We'll use a Lennard-Jones potential for demonstration, but the same approach works with any supported model type.</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom quacc.recipes.torchsim.core import relax_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Create an Argon FCC structure and perturb it\natoms = bulk(\"Ar\", \"fcc\", a=5.26, cubic=True)\natoms.positions += 0.1  # Perturb to make optimization meaningful\n\n# Run geometry optimization\nresult = relax_job(\n    atoms=[atoms],\n    model_type=TSModelType.LENNARD_JONES,\n    model_path=None,\n    optimizer=ts.Optimizer.fire,\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},\n    model_kwargs={\"sigma\": 3.405, \"epsilon\": 0.0104, \"compute_stress\": True},\n)\n\n# Access results\nprint(f\"Final energy: {result['output']['energy'][0]:.6f} eV\")\nprint(f\"Optimized atoms: {result['atoms'][0]}\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#understanding-the-output","title":"Understanding the Output","text":"<p>The <code>relax_job</code> returns a dictionary containing:</p> <ul> <li><code>atoms</code>: List of optimized ASE Atoms objects</li> <li><code>output</code>: Dictionary with <code>energy</code>, <code>forces</code>, and <code>stress</code> for each system</li> <li><code>dir_name</code>: Path to the job directory containing trajectory files</li> <li><code>model_type</code>, <code>model_path</code>: Model configuration used</li> <li><code>optimizer</code>, <code>convergence_fn</code>: Optimization settings</li> <li><code>trajectory_reporter</code>, <code>autobatcher</code>: Configuration details</li> </ul>"},{"location":"user/recipes/torchsim.html#molecular-dynamics","title":"Molecular Dynamics","text":"<p>The <code>md_job</code> recipe runs molecular dynamics simulations. Here's an example using the Langevin thermostat for NVT dynamics:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom quacc.recipes.torchsim.core import md_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Create a copper structure\natoms = bulk(\"Cu\", \"fcc\", a=3.6, cubic=True)\n\n# Run NVT molecular dynamics\nresult = md_job(\n    atoms=[atoms],\n    model_type=TSModelType.LENNARD_JONES,\n    model_path=None,\n    integrator=ts.Integrator.nvt_langevin,\n    n_steps=100,\n    temperature=300.0,  # Kelvin\n    timestep=0.001,  # picoseconds\n    model_kwargs={\"sigma\": 2.0, \"epsilon\": 0.1},\n)\n\nprint(f\"Final energy: {result['output']['energy'][0]:.6f} eV\")\nprint(f\"MD ran for {result['n_steps']} steps at {result['temperature']} K\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#available-integrators","title":"Available Integrators","text":"<p>TorchSim provides several integrators accessible via <code>ts.Integrator</code>:</p> <ul> <li><code>nvt_langevin</code> - Langevin thermostat (NVT)</li> <li><code>nvt_nose_hoover</code> - Nos\u00e9-Hoover thermostat (NVT)</li> <li><code>nve</code> - Microcanonical ensemble (NVE)</li> <li><code>npt_langevin</code> - Langevin barostat (NPT)</li> </ul>"},{"location":"user/recipes/torchsim.html#static-calculations","title":"Static Calculations","text":"<p>For single-point calculations without system evolution, use <code>static_job</code>:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.torchsim.core import static_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Create multiple structures\ncu_atoms = bulk(\"Cu\", \"fcc\", a=3.6, cubic=True)\nfe_atoms = bulk(\"Fe\", \"bcc\", a=2.87, cubic=True)\n\n# Run static calculations on both\nresult = static_job(\n    atoms=[cu_atoms, fe_atoms],\n    model_type=TSModelType.LENNARD_JONES,\n    model_path=None,\n    trajectory_reporter_dict={\n        \"prop_calculators\": {1: [\"potential_energy\", \"forces\", \"stress\"]},\n    },\n    model_kwargs={\"sigma\": 2.5, \"epsilon\": 0.05, \"compute_stress\": True},\n)\n\n# Access energies for each system\nfor i, energy in enumerate(result[\"output\"][\"energy\"]):\n    print(f\"System {i}: {energy:.6f} eV\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#using-machine-learning-potentials","title":"Using Machine Learning Potentials","text":"<p>The TorchSim recipes support various machine learning potentials. Here's an example with MACE:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom mace.calculators.foundations_models import download_mace_mp_checkpoint\nfrom quacc.recipes.torchsim.core import relax_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Download and get path to MACE model\nmodel_path = download_mace_mp_checkpoint(\"small\")\n\n# Create a silicon structure\natoms = bulk(\"Si\", \"diamond\", a=5.43, cubic=True)\natoms.positions += 0.05  # Small perturbation\n\n# Run optimization with MACE\nresult = relax_job(\n    atoms=[atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    optimizer=ts.Optimizer.fire,\n    convergence_fn=\"force\",\n    convergence_fn_kwargs={\"force_tol\": 0.01},  # eV/\u00c5\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},\n)\n\nprint(f\"Final energy: {result['output']['energy'][0]:.6f} eV\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#supported-model-types","title":"Supported Model Types","text":"<p>The <code>TSModelType</code> enum includes:</p> Model Type Description <code>MACE</code> MACE models <code>FAIRCHEM</code> FairChem (EquiformerV2, eSCN) <code>FAIRCHEMV1</code> Legacy FairChem models <code>MATTERSIM</code> MatterSim models <code>SEVENNET</code> SevenNet models <code>ORB</code> Orb models <code>GRAPHPESWRAPPER</code> GraphPES models <code>NEQUIPFRAMEWORK</code> NequIP Framework models <code>METATOMIC</code> Metatomic models <code>LENNARD_JONES</code> Classical Lennard-Jones (testing)"},{"location":"user/recipes/torchsim.html#batch-processing-multiple-systems","title":"Batch Processing Multiple Systems","text":"<p>One of TorchSim's key strengths is efficient batch processing. You can simulate multiple systems in parallel:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom quacc.recipes.torchsim.core import relax_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Create multiple systems of different sizes\nsystems = [\n    bulk(\"Cu\", \"fcc\", a=3.6, cubic=True),\n    bulk(\"Fe\", \"bcc\", a=2.87, cubic=True),\n    bulk(\"Cu\", \"fcc\", a=3.6, cubic=True).repeat([2, 2, 2]),\n    bulk(\"Fe\", \"bcc\", a=2.87, cubic=True).repeat([2, 2, 2]),\n]\n\n# Perturb all structures\nfor atoms in systems:\n    atoms.positions += 0.1\n\n# Optimize all systems in a single job\nresult = relax_job(\n    atoms=systems,\n    model_type=TSModelType.LENNARD_JONES,\n    model_path=None,\n    optimizer=ts.Optimizer.fire,\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},\n    model_kwargs={\"sigma\": 2.5, \"epsilon\": 0.05, \"compute_stress\": True},\n)\n\n# Results for each system\nfor i, (atoms, energy) in enumerate(zip(result[\"atoms\"], result[\"output\"][\"energy\"])):\n    print(f\"System {i}: {len(atoms)} atoms, {energy:.6f} eV\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#trajectory-reporting","title":"Trajectory Reporting","text":"<p>Track simulation progress and save trajectories using <code>trajectory_reporter_dict</code>:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom quacc.recipes.torchsim.core import md_job\nfrom quacc.schemas.torchsim import TSModelType\n\natoms = bulk(\"Cu\", \"fcc\", a=3.6, cubic=True)\n\n# Configure trajectory reporting\ntrajectory_reporter = {\n    \"state_frequency\": 10,  # Save state every 10 steps\n    \"prop_calculators\": {\n        5: [\"potential_energy\", \"kinetic_energy\", \"temperature\"],\n    },\n}\n\nresult = md_job(\n    atoms=[atoms],\n    model_type=TSModelType.LENNARD_JONES,\n    model_path=None,\n    integrator=ts.Integrator.nvt_langevin,\n    n_steps=100,\n    temperature=500.0,\n    timestep=0.001,\n    trajectory_reporter_dict=trajectory_reporter,\n    model_kwargs={\"sigma\": 2.0, \"epsilon\": 0.1},\n)\n\n# Trajectory files are saved in result[\"dir_name\"]\nprint(f\"Trajectory saved to: {result['dir_name']}\")\nprint(f\"Reporter config: {result['trajectory_reporter']}\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#available-property-calculators","title":"Available Property Calculators","text":"<p>Properties that can be tracked during simulations:</p> <ul> <li><code>potential_energy</code> - System potential energy</li> <li><code>forces</code> - Atomic forces</li> <li><code>stress</code> - System stress tensor</li> <li><code>kinetic_energy</code> - Kinetic energy (MD only)</li> <li><code>temperature</code> - Instantaneous temperature (MD only)</li> </ul>"},{"location":"user/recipes/torchsim.html#autobatching","title":"Autobatching","text":"<p>For large batches that exceed GPU memory, enable autobatching:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom quacc.recipes.torchsim.core import relax_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Create many systems\nsystems = [bulk(\"Cu\", \"fcc\", a=3.6, cubic=True).repeat([2, 2, 2]) for _ in range(20)]\nfor atoms in systems:\n    atoms.positions += 0.1\n\n# Enable autobatching with custom settings\nautobatcher = {\n    \"memory_scales_with\": \"n_atoms\",\n    \"max_memory_scaler\": 260,  # Adjust based on GPU memory\n}\n\nresult = relax_job(\n    atoms=systems,\n    model_type=TSModelType.LENNARD_JONES,\n    model_path=None,\n    optimizer=ts.Optimizer.fire,\n    autobatcher_dict=autobatcher,\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},\n    model_kwargs={\"sigma\": 2.5, \"epsilon\": 0.05, \"compute_stress\": True},\n)\n\nprint(f\"Optimized {len(result['atoms'])} systems\")\n</code></pre> <p>You can also set <code>autobatcher_dict=True</code> for automatic configuration.</p>"},{"location":"user/recipes/torchsim.html#convergence-criteria","title":"Convergence Criteria","text":"<p>For geometry optimization, two convergence criteria are available:</p>"},{"location":"user/recipes/torchsim.html#force-convergence-default","title":"Force Convergence (Default)","text":"<pre><code>result = relax_job(\n    atoms=[atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    optimizer=ts.Optimizer.fire,\n    convergence_fn=\"force\",\n    convergence_fn_kwargs={\"force_tol\": 0.01},  # eV/\u00c5\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},\n)\n</code></pre>"},{"location":"user/recipes/torchsim.html#energy-convergence","title":"Energy Convergence","text":"<pre><code>result = relax_job(\n    atoms=[atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    optimizer=ts.Optimizer.fire,\n    convergence_fn=\"energy\",\n    convergence_fn_kwargs={\"energy_tol\": 1e-6},  # eV\n)\n</code></pre>"},{"location":"user/recipes/torchsim.html#cell-optimization","title":"Cell Optimization","text":"<p>To optimize both atomic positions and cell parameters, use the <code>cell_filter</code> option:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom quacc.recipes.torchsim.core import relax_job\nfrom quacc.schemas.torchsim import TSModelType\n\natoms = bulk(\"Si\", \"diamond\", a=5.5)  # Slightly wrong lattice constant\natoms.positions += 0.05\n\nresult = relax_job(\n    atoms=[atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    optimizer=ts.Optimizer.fire,\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},  # Enable cell optimization\n)\n</code></pre> <p>Available cell filters via <code>ts.CellFilter</code>:</p> <ul> <li><code>unit</code> - Full cell relaxation</li> <li><code>scalar</code> - Isotropic volume relaxation</li> <li><code>off</code> - Fixed cell (positions only)</li> </ul>"},{"location":"user/recipes/torchsim.html#complete-workflow-example","title":"Complete Workflow Example","text":"<p>Here's a complete example combining multiple jobs:</p> <pre><code>from ase.build import bulk\nimport torch_sim as ts\nfrom mace.calculators.foundations_models import download_mace_mp_checkpoint\nfrom quacc.recipes.torchsim.core import relax_job, md_job, static_job\nfrom quacc.schemas.torchsim import TSModelType\n\n# Setup\nmodel_path = download_mace_mp_checkpoint(\"small\")\natoms = bulk(\"Cu\", \"fcc\", a=3.6, cubic=True).repeat([2, 2, 2])\natoms.positions += 0.1\n\n# Step 1: Optimize the structure\nrelax_result = relax_job(\n    atoms=[atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    optimizer=ts.Optimizer.fire,\n    init_kwargs={\"cell_filter\": ts.CellFilter.unit},\n)\noptimized_atoms = relax_result[\"atoms\"][0]\nprint(f\"Relaxation energy: {relax_result['output']['energy'][0]:.4f} eV\")\n\n# Step 2: Run MD to equilibrate\nmd_result = md_job(\n    atoms=[optimized_atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    integrator=ts.Integrator.nvt_langevin,\n    n_steps=500,\n    temperature=300.0,\n    timestep=0.002,\n    trajectory_reporter_dict={\n        \"state_frequency\": 50,\n        \"prop_calculators\": {10: [\"potential_energy\", \"temperature\"]},\n    },\n)\nequilibrated_atoms = md_result[\"atoms\"][0]\nprint(f\"MD final energy: {md_result['output']['energy'][0]:.4f} eV\")\n\n# Step 3: Static calculation for final properties\nstatic_result = static_job(\n    atoms=[equilibrated_atoms],\n    model_type=TSModelType.MACE,\n    model_path=model_path,\n    trajectory_reporter_dict={\n        \"prop_calculators\": {1: [\"potential_energy\", \"forces\", \"stress\"]},\n    },\n)\nprint(f\"Final energy: {static_result['output']['energy'][0]:.4f} eV\")\nprint(f\"Final forces shape: {len(static_result['output']['forces'][0])} atoms\")\n</code></pre>"},{"location":"user/recipes/torchsim.html#comparison-with-torchsim-direct-api","title":"Comparison with TorchSim Direct API","text":"<p>The quacc recipes wrap TorchSim's high-level functions with additional features:</p> Feature TorchSim Direct quacc Recipe Batch processing <code>ts.optimize(system=systems, ...)</code> <code>relax_job(atoms=systems, ...)</code> Workflow engines Manual integration Built-in support Result schemas Custom handling Standardized dictionaries Trajectory paths Manual management Automatic job directory Model loading Manual instantiation <code>model_type</code> + <code>model_path</code>"},{"location":"user/recipes/torchsim.html#conclusion","title":"Conclusion","text":"<p>The quacc TorchSim recipes provide a powerful interface for running batched atomistic simulations with machine learning potentials. Key advantages include:</p> <ol> <li>Workflow compatibility - Works with Prefect, Parsl, Dask, and other engines</li> <li>Batch efficiency - Process multiple systems in parallel on GPU</li> <li>Automatic memory management - Autobatching handles large datasets</li> <li>Standardized outputs - Consistent result schemas across all jobs</li> <li>Trajectory management - Automatic file handling in job directories</li> </ol> <p>For more details on the underlying TorchSim functionality, see the TorchSim documentation.</p>"},{"location":"user/recipes/workflows.html","title":"Intro to Flows","text":"<p>In addition to individual jobs, quacc ships with a variety of pre-made workflows, which we call flows for short. Here, we will run a pre-made flow with EMT, defined by quacc.recipes.emt.slabs.bulk_to_slabs_flow and described by the following graph representation:</p> <pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs)\n  B --&gt; C(Slab Relax) --&gt; G(Slab Static) --&gt; K[Output]\n  B --&gt; D(Slab Relax) --&gt; H(Slab Static) --&gt; K[Output]\n  B --&gt; E(Slab Relax) --&gt; I(Slab Static) --&gt; K[Output]\n  B --&gt; F(Slab Relax) --&gt; J(Slab Static) --&gt; K[Output];</code></pre> <p>Since we are running everything locally for now, every calculation will be run serially. As discussed in the following sections, using a workflow manager will allow us to run these calculations in parallel on one or more remote machines.</p>"},{"location":"user/recipes/workflows.html#a-representative-example","title":"A Representative Example","text":"<p>Like before, we import the pre-made recipe, pass it the <code>Atoms</code> object, and then print the results.</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nresult = bulk_to_slabs_flow(atoms)\n\n# Print the result\nprint(result)\n</code></pre>"},{"location":"user/recipes/workflows.html#modifying-jobs-in-a-pre-made-flow","title":"Modifying Jobs in a Pre-Made Flow","text":""},{"location":"user/recipes/workflows.html#modifying-a-subset-of-jobs","title":"Modifying a Subset of Jobs","text":"<p>To modify the default parameters of a subset of jobs in a pre-made workflow, you can pass a dictionary of parameters to the <code>job_params</code> keyword argument of the workflow function (note: the name and <code>@job</code> definition for each step in the pre-made workflow is specified in the flow's docstring). The example below modifies sets <code>opt_params={\"fmax\": 1e-4}</code> for the <code>relax_job</code> called within <code>bulk_to_slabs_flow</code>:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow with modified parameters for the `relax_job` step\nresult = bulk_to_slabs_flow(\n    atoms, job_params={\"relax_job\": {\"opt_params\": {\"fmax\": 1e-4}}}\n)\n\n# Print the result\nprint(result)\n</code></pre>"},{"location":"user/recipes/workflows.html#modifying-all-jobs","title":"Modifying All Jobs","text":"<p>To modify the default parameters of all the jobs in a pre-made workflow, you can use the \"all\" keyword as a shorthand. The example below modifies the EMT calculator's <code>asap_cutoff</code> parameter for all jobs in the <code>bulk_to_slabs_flow</code>:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow with modified parameters for all jobs in the flow\nresult = bulk_to_slabs_flow(atoms, job_params={\"all\": {\"asap_cutoff\": True}})\n\n# Print the result\nprint(result)\n</code></pre>"},{"location":"user/recipes/workflows.html#concluding-comments","title":"Concluding Comments","text":"<p>At this point, you now have the basic idea of how quacc recipes work!</p> <p>If you don't care about using a workflow engine, feel free to write simple quacc-based Python scripts and submit them as-is using your favorite computing machine and scheduler. However, if you are looking to efficiently scale up and monitor large numbers of workflows, continue reading!</p>"},{"location":"user/settings/file_management.html","title":"File Management","text":"<p>It can be useful to understand how quacc handles files so that you can adjust the behavior for your needs. Let's consider a recipe that writes an input file <code>INPUT</code> and an output file <code>OUTPUT</code>.</p> <p>Having an Organized Filesystem</p> <p>If you want to achieve a bit more structure in how your files are stored, you can dynamically set the <code>RESULTS_DIR</code> quacc setting as you wish. If you wish to prevent the automatic creation of a unique directory for each job, you can set the <code>CREATE_UNIQUE_DIR</code> quacc setting to <code>False</code>.</p> <p>For a hierarchical folder structure that reflects the relationship between flows, subflows, and jobs, see Auto-generation of folder structure.</p>"},{"location":"user/settings/file_management.html#scenario-1-the-default-case","title":"Scenario 1: The Default Case","text":"<p>Here, let us begin by assuming we are using the default quacc settings. By default, <code>RESULTS_DIR</code> is set to <code>Path()</code> (i.e. the current working directory), but this can be modified by the user.</p>"},{"location":"user/settings/file_management.html#job-runtime","title":"Job Runtime","text":"<p>At job runtime, the file structure looks like:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 tmp-quacc-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT\n    \u2514\u2500\u2500 OUTPUT\n</code></pre>"},{"location":"user/settings/file_management.html#job-success","title":"Job Success","text":"<p>Once the job successfully completes, the file structure looks like:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 quacc-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT.gz\n    \u2514\u2500\u2500 OUTPUT.gz\n</code></pre> <p>Disabling Automated File Compression</p> <p>If you don't want the results to be gzipped, you can set the <code>GZIP_FILES</code> setting to <code>False</code>.</p>"},{"location":"user/settings/file_management.html#job-failure","title":"Job Failure","text":"<p>If the job fails or does not complete, then the file structure looks like:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 failed-quacc-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT\n    \u2514\u2500\u2500 OUTPUT\n</code></pre>"},{"location":"user/settings/file_management.html#scenario-2-auto-generation-of-folder-structure","title":"Scenario 2: Auto-generation of folder structure","text":"<p>Quacc has a new feature for \"auto-generation\" of a sensible output folder structure during job execution. To enable this feature, set <code>NESTED_RESULTS</code> to <code>true</code>.</p> <p>Here, let us assume that <code>RESULTS_DIR</code> is set to <code>Path.cwd()</code> (i.e. the current working directory), though this can be modified just like any other setting.</p>"},{"location":"user/settings/file_management.html#job-runtime_1","title":"Job Runtime","text":"<p>At job runtime, the file structure looks like:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 tmp-relax_job-2026-02-16-71530\n    \u251c\u2500\u2500 INPUT.gz\n    \u2514\u2500\u2500 OUTPUT.gz\n</code></pre>"},{"location":"user/settings/file_management.html#job-success_1","title":"Job Success","text":"<p>Once the job successfully completes, the file structure looks like:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 relax_job-2026-02-16-71530\n    \u251c\u2500\u2500 INPUT.gz\n    \u2514\u2500\u2500 OUTPUT.gz\n</code></pre> <p>Here, <code>relax_job</code> is the name of the job and is suffixed with a timestamp. A recipe may have multiple jobs with the same name, and the timestamp helps us distinguish one run of a job from another.</p> <p>For typical quacc recipes that have a flow, subflow(s), and job(s), the output folders will reflect the relationship between them. For example, the <code>bulk_to_slabs_flow</code> recipe results in something like:</p> <pre><code>RESULTS_DIR\n\u2514\u2500\u2500 bulk_to_slabs_flow-2026-02-16-35312\n    \u2514\u2500\u2500 bulk_to_slabs_subflow-2026-02-16-38381\n        \u251c\u2500\u2500 relax_job-2026-02-16-45812\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        \u251c\u2500\u2500 relax_job-2026-02-16-42525\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        ...\n</code></pre> <p>At each level, the folder name has a prefix that identifies the name of the <code>@flow</code>, <code>@subflow</code>, or <code>@job</code> being run, and the suffix indicates the timestamp. In general, the ordering of folders at a level corresponds to the order in which they were run.</p>"},{"location":"user/settings/file_management.html#job-failure_1","title":"Job Failure","text":"<p>If the job fails or does not complete, then the file structure looks like:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 failed-relax_job-2026-02-16-71530\n    \u251c\u2500\u2500 INPUT.gz\n    \u2514\u2500\u2500 OUTPUT.gz\n</code></pre> <p>For typical quacc recipes that have a flow, subflow(s), and job(s), the file structure looks as follows. Here one of the two relax jobs has failed.</p> <pre><code>RESULTS_DIR\n\u2514\u2500\u2500 bulk_to_slabs_flow-2026-02-16-35312\n    \u2514\u2500\u2500 bulk_to_slabs_subflow-2026-02-16-38381\n        \u251c\u2500\u2500 failed-relax_job-2026-02-16-45812\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        \u251c\u2500\u2500 relax_job-2026-02-16-42525\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        ...\n</code></pre>"},{"location":"user/settings/file_management.html#specifying-a-scratch_dir","title":"Specifying a <code>SCRATCH_DIR</code>","text":"<p>By default, the <code>SCRATCH_DIR</code> setting is set to <code>None</code>. This means that all the calculations will be run somewhere within the <code>RESULTS_DIR</code>. Sometimes, the filesystem where you want to permanently store the results and where you want to run the calculations is different. In this case, you can specify a <code>SCRATCH_DIR</code> setting to distinguish between the two.</p> <p>Here, let's assume the user has specified the <code>SCRATCH_DIR</code> setting to be a custom path.</p>"},{"location":"user/settings/file_management.html#job-runtime_2","title":"Job Runtime","text":"<p>At job runtime, the file structure looks like:</p> <p>If <code>NESTED_RESULTS</code> is <code>False</code>:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 symlink-tmp-quacc-2023-12-08-67890\n\u2502\n</code></pre> <pre><code>SCRATCH_DIR\n\u251c\u2500\u2500 tmp-quacc-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT\n    \u2514\u2500\u2500 OUTPUT\n</code></pre> <p>If <code>NESTED_RESULTS</code> is <code>True</code>:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 symlink-relax_job-quacc-2023-12-08-67890\n\u2502\n</code></pre> <pre><code>SCRATCH_DIR\n\u251c\u2500\u2500 tmp-relax_job-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT\n    \u2514\u2500\u2500 OUTPUT\n</code></pre> <p>For typical quacc recipes that have a flow, subflow(s), and job(s):</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 symlink-relax_job-2026-02-16-45812\n\u2502\n</code></pre> <pre><code>SCRATCH_DIR\n\u2514\u2500\u2500 tmp-bulk_to_slabs_flow-2026-02-16-35312\n    \u2514\u2500\u2500 bulk_to_slabs_subflow-2026-02-16-38381\n        \u251c\u2500\u2500 relax_job-2026-02-16-45812\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        \u251c\u2500\u2500 relax_job-2026-02-16-42525\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        ...\n</code></pre> <p>In all these cases, <code>symlink-..</code> is a temporary symbolic link that points to the corresponding job folder in <code>SCRATCH_DIR/tmp-..</code>, so you can easily monitor the progress of the calculation. On Windows, no symbolink link is created, but the <code>tmp-..</code> directory is still created in <code>SCRATCH_DIR</code>.</p>"},{"location":"user/settings/file_management.html#job-success_2","title":"Job Success","text":"<p>Once the job successfully completes, the file structure looks like:</p> <p>If <code>NESTED_RESULTS</code> is <code>False</code>:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 quacc-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT.gz\n    \u2514\u2500\u2500 OUTPUT.gz\n</code></pre> <pre><code>SCRATCH_DIR\n\u2502\n</code></pre> <p>If <code>NESTED_RESULTS</code> is <code>True</code>:</p> <pre><code>RESULTS_DIR\n\u2514\u2500\u2500 relax_job-2026-02-16-71530\n    \u251c\u2500\u2500 INPUT.gz\n    \u2514\u2500\u2500 OUTPUT.gz\n</code></pre> <pre><code>SCRATCH_DIR\n\u2502\n</code></pre>"},{"location":"user/settings/file_management.html#job-failure_2","title":"Job Failure","text":"<p>If the job fails or does not complete, then the file structure looks as follows.</p> <p>If <code>NESTED_RESULTS</code> is <code>False</code>:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 symlink-failed-quacc-2023-12-08-67890\n\u2502\n</code></pre> <pre><code>SCRATCH_DIR\n\u251c\u2500\u2500 failed-quacc-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT\n    \u2514\u2500\u2500 OUTPUT\n</code></pre> <p>If <code>NESTED_RESULTS</code> is <code>True</code>:</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 symlink-failed-relax_job-2023-12-08-67890\n\u2502\n</code></pre> <pre><code>SCRATCH_DIR\n\u251c\u2500\u2500 failed-relax_job-2023-12-08-67890\n\u2502   \u251c\u2500\u2500 INPUT\n    \u2514\u2500\u2500 OUTPUT\n</code></pre> <p>For typical quacc recipes that have a flow, subflow(s), and job(s), the file structure looks as follows. Here one of the two relax jobs has failed.</p> <pre><code>RESULTS_DIR\n\u251c\u2500\u2500 symlink-failed-relax_job-2026-02-16-45812\n\u2502\n</code></pre> <pre><code>SCRATCH_DIR\n\u2514\u2500\u2500 tmp-bulk_to_slabs_flow-2026-02-16-35312\n    \u2514\u2500\u2500 bulk_to_slabs_subflow-2026-02-16-38381\n        \u251c\u2500\u2500 failed-relax_job-2026-02-16-45812\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        \u251c\u2500\u2500 relax_job-2026-02-16-42525\n        \u2502         \u251c\u2500\u2500 opt.json.gz\n        \u2502         \u251c\u2500\u2500 opt.log.gz\n        \u2502         \u2514\u2500\u2500 opt.traj.gz\n        ...\n</code></pre> <p>The <code>symlink-</code> points to the corresponding <code>failed-...</code> job folder in <code>SCRATCH_DIR</code>.</p>"},{"location":"user/settings/settings.html","title":"Modifying Settings","text":"<p>Important</p> <p>The quacc configuration parameters (e.g. YAML file, environment variables) are only active on the machine where they are specified. In other words, each remote machine has its own custom set of configuration parameters.</p> <p>The default global quacc settings can be found in the <code>settings.py</code> file. If you wish to modify any of the global quacc settings, there are several ways to do so.</p>"},{"location":"user/settings/settings.html#using-a-yaml-file","title":"Using a YAML File","text":"<p>Command-Line Interface</p> <p>The quacc command-line interface (CLI) lets you update the YAML file from the terminal. You can run <code>quacc set PARAMETER value</code> to set a given parameter in the YAML file to the specified value. Similarly, you can run <code>quacc unset PARAMETER</code> to remove a parameter from the YAML file.</p> <p>If you are planning to modify a given set of parameters for all of your calculations, the easiest way is to create a YAML file with custom settings. By default, quacc looks for this YAML file at <code>~/.quacc.yaml</code>. If you wish to store the YAML file somewhere else or with a different name, you can define the environment variable <code>QUACC_CONFIG_FILE</code> and point it to the YAML path of your choosing.</p> ~/.quacc.yaml<pre><code>SCRATCH_DIR: /path/to/my/scratch/dir # (1)!\nCREATE_UNIQUE_DIR: false # (2)!\nWORKFLOW_ENGINE: None # (3)!\n</code></pre> <ol> <li> <p>In YAML, you do not need to put quotation marks around strings. The YAML file also supports environment variable-based paths, like <code>$SCRATCH</code>.</p> </li> <li> <p>In YAML, booleans are lowercase.</p> </li> <li> <p>In YAML, a blank value or <code>null</code> is interpreted as <code>None</code> in Python. We also support \"None\" for convenience.</p> </li> </ol> <p>When is This Method Ideal?</p> <p>This approach is ideal when you want to change a setting that applies to most or all of your calculations. If you wish to have multiple sets of YAML files, you can dynamically change which file to use by setting the <code>QUACC_CONFIG_FILE</code> environment variable accordingly.</p>"},{"location":"user/settings/settings.html#using-environment-variables","title":"Using Environment Variables","text":"<p>If you want to define quacc settings without writing them to a YAML file, you can instead modify the desired settings by defining individual environment variables with <code>QUACC</code> as the prefix. The environment variable takes precedence over any value specified in the YAML file. Most simple field types (e.g. <code>int</code>, <code>bool</code>, <code>float</code>, <code>str</code>) will be automatically inferred from the environment variable. For more complex types, such as lists or dictionaries, refer to the corresponding section in the pydantic-settings documentation. We use <code>__</code> as the delimiter for nested settings.</p> <p>To achieve the same results as the aforementioned YAML file, you would define the following environment variables:</p> <pre><code>export QUACC_SCRATCH_DIR=/path/to/my/scratch/dir\nexport QUACC_CREATE_UNIQUE_DIR=False\nexport QUACC_WORKFLOW_ENGINE=None\n</code></pre> <p>When is This Method Ideal?</p> <p>This approach is ideal when you want to dynamically modify the quacc settings for a given set of calculations, as the environment variable can be modified on-the-fly (e.g. in the job's submission script) without modifying the YAML file that is read by all other calculations.</p> <p>Be Careful!</p> <p>If you try to modify environment variables within Python using <code>os.environ</code>, make sure you do this before you make any <code>quacc</code>-related imports. Note that any changes to your environment variables via <code>os.environ</code> only happen on the machine where the command is run!</p>"},{"location":"user/settings/settings.html#modifying-the-global-settings-in-a-script","title":"Modifying the Global Settings in a Script","text":"<p>If you want to define quacc settings on-the-fly without writing them to a YAML file or using environment variables, you can do so using the context handler function quacc.settings.change_settings as follows:</p> <pre><code>from ase.build import bulk\nfrom quacc import change_settings\nfrom quacc.recipes.emt.core import relax_job\n\natoms = bulk(\"Cu\")\n\nwith change_settings({\"GZIP_FILES\": False}):\n    result = relax_job(atoms)\n</code></pre> Using a Workflow Engine? <p>When deploying calculations via a workflow engine, changes to in-memory global variables on the local machine will not be reflected on the remote machine. While the YAML file and environment variable approaches are preferred, if you wish to make changes from within your script then this should be done via a custom <code>settings_swap</code> keyword argument that is supported by the <code>@job</code> decorator.</p> <pre><code>from quacc import job\n\n\n@job(settings_swap={\"GZIP_FILES\": False})  # (1)!\ndef add(a, b):\n    return a + b\n</code></pre> <ol> <li> <p>This is the same as doing</p> <pre><code>from quacc import change_settings, job\n\n\n@job\ndef add(a, b):\n    with change_settings({\"RESULTS_DIR\": \"/path/to/my/favorite/dir\"}):\n        return a + b\n</code></pre> </li> </ol> <p>If using a pre-made <code>@job</code>, you can simply redecorate it so that it supports your custom settings:</p> <pre><code>from ase.build import bulk\nfrom quacc import redecorate, job\nfrom quacc.recipes.emt.core import relax_job\n\natoms = bulk(\"Cu\")\nrelax_job_ = redecorate(relax_job, job(settings_swap={\"GZIP_FILES\": False}))\nresults = relax_job_(atoms)\n</code></pre> <p>When is This Method Ideal?</p> <p>This approach is ideal for fine-tuned modifications to settings within your workflow.</p>"},{"location":"user/settings/settings_list.html","title":"List of Quacc Settings","text":"quacc/settings.py<pre><code>    # ---------------------------\n    # Workflow Engine\n    # ---------------------------\n\n    WORKFLOW_ENGINE: Literal[\"dask\", \"parsl\", \"prefect\", \"redun\", \"jobflow\"] | None = (\n        Field(None, description=(\"The workflow manager to use, if any.\"))\n    )\n\n    # ---------------------------\n    # General Settings\n    # ---------------------------\n\n    RESULTS_DIR: Path = Field(\n        Path(),\n        description=(\n            \"\"\"\n            Directory to permanently store I/O-based calculation results in.\n            Note that this behavior may be modified by the chosen workflow engine.\n            \"\"\"\n        ),\n    )\n    SCRATCH_DIR: Path | None = Field(\n        None,\n        description=(\n            \"\"\"\n            The base directory where calculations are run. If set to None, calculations will be run in a\n            temporary directory within `RESULTS_DIR`. If a `Path` is supplied, calculations will\n            be run in a temporary directory within `SCRATCH_DIR`. Files are always moved back\n            to `RESULTS_DIR` after the calculation is complete, and the temporary directory\n            in `SCRATCH_DIR` is removed.\n            \"\"\"\n        ),\n    )\n    CREATE_UNIQUE_DIR: bool = Field(\n        True,\n        description=(\n            \"\"\"\n            Whether to have a unique directory in RESULTS_DIR for each job.\n            Some workflow engines have an option to do this for you already,\n            in which case you should set this to False.\n            \"\"\"\n        ),\n    )\n    GZIP_FILES: bool = Field(\n        True, description=\"Whether generated files should be gzip'd.\"\n    )\n    CHECK_CONVERGENCE: bool = Field(\n        True,\n        description=\"Whether to check for convergence, when implemented by a given recipe.\",\n    )\n    NESTED_RESULTS: bool = Field(\n        False,\n        description=(\n            \"\"\"\n            Whether to auto-discover sensible paths for output files in\n            RESULTS_DIR for each flow. The path chosen reflect the relationship\n            the flow and the subflows/jobs executed within it.\n            \"\"\"\n        ),\n    )\n\n    # ---------------------------\n    # Prefect Settings\n    # ---------------------------\n    PREFECT_AUTO_SUBMIT: bool = Field(\n        True, description=\"Whether to auto-submit tasks to the task runner.\"\n    )\n    PREFECT_RESOLVE_FLOW_RESULTS: bool = Field(\n        True,\n        description=\"Whether to resolve all futures in flow results to data and fail if not possible\",\n    )\n\n    # ---------------------------\n    # ORCA Settings\n    # ---------------------------\n    ORCA_CMD: str = Field(\n        which(\"orca\") or \"orca\",\n        description=(\n            \"\"\"\n            Path to the ORCA executable. This must be the full, absolute path\n            for parallel calculations to work.\n            \"\"\"\n        ),\n    )\n\n    # ---------------------------\n    # MRCC Settings\n    # ---------------------------\n    MRCC_CMD: str = Field(\n        \"dmrcc\",\n        description=(\n            \"\"\"\n            Path to the MRCC executable.\n            \"\"\"\n        ),\n    )\n\n    # ---------------------------\n    # ESPRESSO Settings\n    # ---------------------------\n    ESPRESSO_BIN_DIR: Path = Field(\n        Path(), description=\"Base path to the espresso binaries.\"\n    )\n    ESPRESSO_BINARIES: dict[str, str] = Field(\n        {\n            \"pw\": \"pw.x\",\n            \"ph\": \"ph.x\",\n            \"neb\": \"neb.x\",\n            \"q2r\": \"q2r.x\",\n            \"dos\": \"dos.x\",\n            \"matdyn\": \"matdyn.x\",\n            \"dynmat\": \"dynmat.x\",\n            \"bands\": \"bands.x\",\n            \"projwfc\": \"projwfc.x\",\n            \"pp\": \"pp.x\",\n            \"wannier90\": \"wannier90.x\",\n            \"fs\": \"fs.x\",\n            \"postahc\": \"postahc.x\",\n            \"dvscf_q2r\": \"dvscf_q2r.x\",\n        },\n        description=\"Name for each espresso binary.\",\n    )\n    ESPRESSO_PARALLEL_CMD: Union[str, tuple[str, str]] = Field(\n        \"\",\n        description=(\n            \"\"\"\n            Parallelization flags to run Espresso. The 0th index of the tuple\n            contains any commands that come before the binary, and the 1st index\n            contains any commands that come after the binary.\n\n            For example: [\"mpirun -np 4\", \"-nk 2\"] would be the same as running\n            Espresso via `\"mpirun -np 4 {binary} -nk 2\"` where {binary} is the\n            binary that is automatically determined based on the job type,\n            `ESPRESSO_BIN_DIR` and `ESPRESSO_BINARIES`.\n\n            If only a `str` is provided, no post-binary commands will be used.\n            \"\"\"\n        ),\n    )\n    ESPRESSO_PSEUDO: Path | None = Field(\n        None, description=(\"Path to a pseudopotential library for espresso.\")\n    )\n    ESPRESSO_PRESET_DIR: Path = Field(\n        Path(__file__).parent / \"calculators\" / \"espresso\" / \"presets\",\n        description=\"Path to the espresso preset directory\",\n    )\n\n    # ---------------------------\n    # Gaussian Settings\n    # ---------------------------\n    GAUSSIAN_CMD: str = Field(\"g16\", description=(\"Path to the Gaussian executable.\"))\n\n    # ---------------------------\n    # ONETEP Settings\n    # ---------------------------\n    ONETEP_CMD: str = Field(\n        \"onetep.arch\",\n        description=(\"Full ONETEP command, including parallelization flags.\"),\n    )\n    ONETEP_PP_PATH: Path = Field(Path(), description=(\"Path to pseudopotentials.\"))\n\n    # ---------------------------\n    # GULP Settings\n    # ---------------------------\n    GULP_CMD: str = Field(\"gulp\", description=(\"Path to the GULP executable.\"))\n    GULP_LIB: Path | None = Field(\n        os.environ.get(\"GULP_LIB\"),\n        description=(\n            \"Path to the GULP force field library. If not specified, the GULP_LIB environment variable will be used (if present).\"\n        ),\n    )\n\n    # ---------------------------\n    # VASP Settings\n    # ---------------------------\n\n    # VASP Settings: Main\n    VASP_PARALLEL_CMD: str = Field(\n        \"\",\n        description=(\n            \"\"\"\n            Parallel command to run VASP with Custodian.\n            For example: `\"srun -N 2 --ntasks-per-node 48\"`.\n            Note that this does not include the executable name.\n            \"\"\"\n        ),\n    )\n    VASP_CMD: str = Field(\n        \"vasp_std\", description=\"Command to run the standard version of VASP.\"\n    )\n    VASP_GAMMA_CMD: str = Field(\n        \"vasp_gam\", description=\"Command to run the gamma-point only version of VASP.\"\n    )\n    VASP_PP_PATH: Path | None = Field(\n        os.environ.get(\"VASP_PP_PATH\"),\n        description=\"Path to the VASP pseudopotential folders.\",\n    )\n    VASP_PP_VERSION: str | None = Field(\n        os.environ.get(\"VASP_PP_VERSION\"),\n        description=\"Version of VASP pseudopotentials to use\",\n    )\n    VASP_VDW: Path | None = Field(\n        os.environ.get(\"ASE_VASP_VDW\"),\n        description=\"Path to the folder containing the vdw_kernel.bindat file for VASP vdW functionals.\",\n    )\n\n    # VASP Settings: General\n    VASP_INCAR_COPILOT: Literal[\"off\", \"on\", \"aggressive\"] = Field(\n        \"on\",\n        description=(\n            \"\"\"\n            Controls VASP co-pilot mode for automated INCAR parameter handling.\n            off: Do not use co-pilot mode. INCAR parameters will be unmodified.\n            on: Use co-pilot mode. This will only modify INCAR flags not already set by the user.\n            aggressive: Use co-pilot mode in aggressive mode. This will modify INCAR flags even if they are already set by the user.\n            \"\"\"\n        ),\n    )\n    VASP_BADER: bool = Field(\n        bool(which(\"bader\")),\n        description=(\n            \"\"\"\"\n            Whether to run a Bader analysis when summarizing VASP results.\n            Requires bader to be in PATH.\n            \"\"\"\n        ),\n    )\n    VASP_CHARGEMOL: bool = Field(\n        bool(os.environ.get(\"DDEC6_ATOMIC_DENSITIES_DIR\")),\n        description=(\n            \"\"\"\n            Whether to run a Chargemol (i.e. DDEC6, CM5) analysis when summarizing VASP results.\n            Requires the Chargemol executable to be in PATH and the DDEC6_ATOMIC_DENSITIES_DIR environment variable.\n            \"\"\"\n        ),\n    )\n    VASP_PRESET_MAG_DEFAULT: float = Field(\n        0.5,\n        description=(\n            \"\"\"\n            Default initial magmom to use for a given element if a preset\n            with magmoms is provided but an element is missing from the list.\n            \"\"\"\n        ),\n    )\n    VASP_MAG_CUTOFF: float = Field(\n        0.02,\n        description=(\n            \"\"\"\n            If the absolute value of all magnetic moments are below this value,\n            they will be set to 0 such that a spin-unpolarized calculation will be performed.\n            \"\"\"\n        ),\n    )\n    VASP_COPY_MAGMOMS: bool = Field(\n        True,\n        description=(\n            \"\"\"\n            If True, any pre-existing atoms.get_magnetic_moments() will be set\n            in atoms.set_initial_magnetic_moments().\n            \"\"\"\n        ),\n    )\n    VASP_PRESET_DIR: Path = Field(\n        Path(__file__).parent / \"calculators\" / \"vasp\" / \"presets\",\n        description=\"Path to the VASP preset directory\",\n    )\n\n    # VASP Settings: Custodian\n    VASP_USE_CUSTODIAN: bool = Field(\n        True, description=\"Whether Custodian should be used to run VASP\"\n    )\n    VASP_CUSTODIAN_VTST: bool = Field(\n        False,\n        description=(\n            \"\"\"\n            If VTST-related input swaps should be used when running Custodian.\n            Requires VASP to be compiled with VTST\n            \"\"\"\n        ),\n    )\n    VASP_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Custodian\"\n    )\n    VASP_CUSTODIAN_HANDLERS: list[str] = Field(\n        [\n            \"VaspErrorHandler\",\n            \"MeshSymmetryErrorHandler\",\n            \"UnconvergedErrorHandler\",\n            \"NonConvergingErrorHandler\",\n            \"PotimErrorHandler\",\n            \"PositiveEnergyErrorHandler\",\n            \"FrozenJobErrorHandler\",\n            \"StdErrHandler\",\n            \"LargeSigmaHandler\",\n            \"IncorrectSmearingHandler\",\n        ],\n        description=\"Handlers for Custodian\",\n    )\n    VASP_CUSTODIAN_VALIDATORS: list[str] = Field(\n        [\"VasprunXMLValidator\", \"VaspFilesValidator\"],\n        description=\"Validators for Custodian\",\n    )\n    VASP_CUSTODIAN_WALL_TIME: int | None = Field(\n        None,\n        description=(\n            \"\"\"\n            After this many seconds, Custodian will stop running\n            and ensure that VASP writes a STOPCAR\n            \"\"\"\n        ),\n    )\n\n    # ---------------------------\n    # Q-Chem Settings\n    # ---------------------------\n\n    # Q-Chem Settings: Main\n    QCHEM_CMD: str = Field(\n        \"qchem\", description=\"Command to run the standard version of Q-Chem.\"\n    )\n\n    QCHEM_LOCAL_SCRATCH: Path = Field(\n        Path(\"/tmp\") if Path(\"/tmp\").exists() else Path.cwd() / \".qchem_scratch\",\n        description=\"Compute-node local scratch directory in which Q-Chem should perform IO.\",\n    )\n    QCHEM_NUM_CORES: int = Field(\n        psutil.cpu_count(logical=False) or 1,\n        description=\"Number of cores to use for the Q-Chem calculation.\",\n    )\n\n    # Q-Chem Settings: Custodian\n    QCHEM_USE_ERROR_HANDLERS: bool = Field(\n        True,\n        description=\"Whether Custodian's error handlers should be employed for Q-Chem.\",\n    )\n\n    QCHEM_CUSTODIAN_MAX_ERRORS: int = Field(\n        5, description=\"Maximum errors for Q-Chem Custodian.\"\n    )\n\n    # NBO Settings\n    QCHEM_NBO_EXE: Path | None = Field(\n        None, description=\"Full path to the NBO executable.\"\n    )\n\n    # ---------------------------\n    # NewtonNet Settings\n    # ---------------------------\n    NEWTONNET_MODEL_PATH: Union[Path, list[Path]] = Field(\n        Path(\"best_model_state.tar\"), description=\"Path to NewtonNet .tar model\"\n    )\n    NEWTONNET_CONFIG_PATH: Union[Path, list[Path]] = Field(\n        Path(\"config.yml\"), description=\"Path to NewtonNet YAML settings file\"\n    )\n\n    # ---------------------------\n    # Logger Settings\n    # ---------------------------\n    LOG_FILENAME: Path | None = Field(None, description=\"Path to store the log file.\")\n    LOG_LEVEL: Literal[\"CRITICAL\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"] = Field(\n        \"INFO\", description=(\"Logger level.\")\n    )\n</code></pre>"},{"location":"user/wflow_engine/executors.html","title":"Deploying Calculations","text":"<p>In the previous examples, we have been running calculations on the local machine. However, in practice, you will probably want to run your calculations on one or more HPC machines. This section will describe how to set up your workflows to run on HPC machines using your desired workflow engine to scale up your calculations.</p> <p>A Note on Terminology</p> <p>Throughout this section, when we refer to a \"job\", we are specifically referring to a function decorated by <code>@job</code> (i.e. not necessarily a Slurm job). A node refers to the compute node on the HPC machine, which consists of many individual compute cores. An allocation refers to one or more nodes that have been reserved via the job scheduler for a given amount of time.</p>"},{"location":"user/wflow_engine/executors.html#background-information","title":"Background Information","text":"DaskParslPrefectJobflow <p>A Dask cluster can be set up to be used with a queueing system like that found on most HPC machines. This is most easily done via Dask Jobqueue. Example configurations for various queuing systems can be found in the \"Example Deployments\" section of the Dask Jobqueue documentation.</p> <p>Out-of-the-box, Parsl will run on your local machine. However, in practice you will probably want to run your Parsl workflows on HPC machines.</p> <p>To configure Parsl for the high-performance computing environment of your choice, refer to the executor configuration page in the Parsl documentation for many examples. Additional details can be found in the \"Execution\" section of the Parsl documentation. Most users of quacc will probably want to the <code>HighThroughputExecutor</code>.</p> <p>Pilot Jobs</p> <p>Unlike most other workflow engines, Parsl is built for the pilot job model where the allocated nodes continually pull in new jobs to run. This makes it possible to avoid submitting a large number of small jobs to the scheduler, which can be inefficient from a queuing perspective.</p> <p>Globus Compute</p> <p>If you want to run Parsl workflows on remote, distributed computing resources, check out Globus Compute and the corresponding tutorial.</p> <p>To scale up calculations, read about the concept of a Prefect task runner. By default, <code>quacc</code> automatically submits all <code>@job</code>-decorated functions to the specified task runner and so concurrency is achieved by default.</p> <p>To use Prefect in a job scheduler environment, you can create a <code>DaskTaskRunner</code> that can be used in conjunction with dask-jobqueue. Example configurations for various queuing systems can be found in the \"Example Deployments\" section of the <code>dask-jobqueue</code> documentation.</p> <p>Out-of-the-box, Jobflow can be used to run on your local machine. You will, however, need a \"manager\" to run your workflows on HPC machines. The recommended option is jobflow-remote, but you can also use Fireworks.</p> Jobflow RemoteFireworks <p>Setting Up Your Jobflow Remote Configuration</p> <p>When you previously set up Jobflow or FireWorks, you created a YAML file with configuration details. It's now time to revisit that file and adjust the <code>pre_run</code> command with any modules or environment variables necessary for your calculations to run. Additionally, you will probably want to update the <code>nodes</code>, <code>walltime</code>, and related settings for your scheduler.</p> <p>Setting Up Your <code>my_qadapter.yaml</code></p> <p>When you previously set up Jobflow and FireWorks, you created a <code>my_qadapter.yaml</code> file. It's now time to revisit that file and adjust the <code>pre_rocket</code> command with any modules or environment variables necessary for your calculations to run. Additionally, you will probably want to update the <code>nodes</code>, <code>walltime</code>, and related settings for your scheduler.</p> <p>Converting Between Jobflow and FireWorks</p> <p>The <code>jobflow.managers.fireworks</code> module has all the tools you need to convert your Jobflow workflows to a format that is suitable for FireWorks.</p> <p>Converting a Job to a Firework</p> <p>To convert a <code>Job</code> to a <code>firework</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import job_to_firework\n\n# make your Jobflow `job` here\n\nfw = job_to_firework(job)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(fw)\n</code></pre> <p>Converting a Flow to a Workflow</p> <p>To convert a <code>Flow</code> to a <code>workflow</code> and add it to your launch pad:</p> <pre><code>from fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\n\n# make your Jobflow `flow` here\n\nwf = flow_to_workflow(flow)\nlpad = LaunchPad.auto_load()\nlpad.add_wf(wf)\n</code></pre>"},{"location":"user/wflow_engine/executors.html#worked-examples","title":"Worked Examples","text":"<p>In this section, we go through the entire process to deploy recipes remotely on HPC machines that use a job scheduler. The precise configuration details will depend on your given compute setup. Nonetheless, we have provided examples here for Perlmutter at NERSC that you can build from.</p> <p>First-Time Deployment</p> <p>Before deploying remote calculations for the first time, do <code>quacc set WORKFLOW_ENGINE None</code> on the remote machine and run your recipe as a standard Python script (e.g. by submitting it as a job to the scheduler). This preliminary test will help you identify potential issues that are independent of the workflow manager.</p>"},{"location":"user/wflow_engine/executors.html#pre-requisites","title":"Pre-Requisites","text":"<p>If you haven't done so already:</p> DaskParslPrefectJobflow <p>On the remote machine:</p> <pre><code>pip install quacc[dask]\nquacc set WORKFLOW_ENGINE dask\n</code></pre> For NERSC Users <p>If using Perlmutter at NERSC, Dask should be run from the <code>$SCRATCH</code> directory. This is because the <code>$SCRATCH</code> directory is the only directory that supports file locking mechanisms, which Dask relies on.</p> <p>On the remote machine:</p> <pre><code>pip install quacc[parsl]\nquacc set WORKFLOW_ENGINE parsl\n</code></pre> <p>On the remote machine:</p> <pre><code>pip install quacc[prefect]\nquacc set WORKFLOW_ENGINE prefect\n</code></pre> <p>Also make sure to connect to Prefect Cloud on the remote machine if you are not self-hosting:</p> <pre><code>prefect cloud login\n</code></pre> For NERSC Users <p>If using Perlmutter at NERSC with the Dask backend for Prefect, your calculations should be run from the <code>$SCRATCH</code> directory. This is because the <code>$SCRATCH</code> directory is the only directory that supports file locking mechanisms, which Dask relies on.</p> Jobflow RemoteFireworks <p>On both the local and remote machines:</p> <pre><code>pip install quacc[jobflow]\n</code></pre> <p>When you are ready to run, make sure the daemon is live in the background with</p> <pre><code>jf runner start\n</code></pre> <p>On both the remote machine:</p> <pre><code>pip install quacc[jobflow] fireworks\n</code></pre>"},{"location":"user/wflow_engine/executors.html#concurrent-non-mpi-jobs","title":"Concurrent Non-MPI Jobs","text":"DaskParslPrefectJobflow <p>Here, we will run single-core TBLite relaxation and frequency calculations for 162 molecules in the so-called \"g2\" collection of small, neutral molecules.</p> <p>On the remote machine, first make sure to install the necessary dependencies:</p> <pre><code>pip install quacc[tblite]\n</code></pre> <p>From an interactive resource like a Jupyter Notebook or IPython kernel on the login node of the remote machine, run the following to instantiate a Dask <code>SLURMCluster</code> that will request two Slurm allocations of one node each, with each <code>@job</code> running on one core of the allocation:</p> <pre><code>from dask.distributed import Client\nfrom dask_jobqueue import SLURMCluster\n\naccount = \"MyAccountName\"\n\ncores_per_node = 112\nslurm_jobs = 2\n\nenv_vars = \"export OMP_NUM_THREADS=1,1\"  # (1)!\n\ncluster = SLURMCluster(\n    cores=cores_per_node,  # (2)!\n    memory=\"64 GB\",\n    shebang=\"#!/bin/bash\",\n    account=account,\n    walltime=\"00:10:00\",\n    job_mem=\"0\",\n    job_script_prologue=[\n        \"source ~/.bashrc\",\n        env_vars,\n    ],\n    job_directives_skip=[\"-n\", \"--cpus-per-task\"],  # (3)!\n    job_extra_directives=[\"-q debug\", \"-C cpu\"],  # (4)!\n)\nprint(cluster.job_script())\ncluster.scale(jobs=slurm_jobs)\nclient = Client(cluster)\n</code></pre> <ol> <li> <p>Since we are running single-core jobs, we need to set the <code>OMP_NUM_THREADS</code> environment variable to \"1,1\" according to the TBLite documentation.</p> </li> <li> <p>It is also worthwhile to play around with the <code>processes</code> argument, which defaults to sqrt(cores).</p> </li> <li> <p>We have skipped the <code>-n</code> and <code>--cpus-per-task</code> Slurm directives because we will be using the full node here.</p> </li> <li> <p>We have set the queue to submit to and the constraint to use.</p> </li> </ol> <p>Then run the following code:</p> <pre><code>from ase.collections import g2\nfrom quacc.recipes.tblite.core import relax_job, freq_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return freq_job(relax_output[\"atoms\"], energy=relax_output[\"results\"][\"energy\"])\n\n\nfutures = []\nfor name in g2.names:\n    atoms = g2[name]\n    future = client.compute(workflow(atoms))\n    futures.append(future)\n\nresults = client.gather(futures)\nfor result in results:\n    print(\n        result[\"formula_pretty\"],\n        result[\"results\"][\"gibbs_energy\"],\n        result[\"dir_name\"],\n    )\n</code></pre> <p>Here, we describe representative <code>HighThroughputExecutor</code> configurations that will orchestrate jobs from the login node of NERSC's Perlmutter machine. There is no one-size-fits-all approach, so you will need to adjust the configuration to suit your specific needs.</p> <p>Here, we will run single-core TBLite relaxation and frequency calculations for 162 molecules in the so-called \"g2\" collection of small, neutral molecules. This example should be run from an interactive resource like a Jupyter Notebook or IPython kernel on the remote machine.</p> <p>On the remote machine, make sure to install the necessary dependencies:</p> <pre><code>pip install quacc[tblite]\n</code></pre> <p>Now we will request a single Slurm allocation with 2 nodes, and each compute job will run on one core of that allocation.</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.dataflow.dependency_resolvers import DEEP_DEPENDENCY_RESOLVER\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SrunLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\n\ncores_per_job = 1\ncores_per_node = 128\nnodes_per_allocation = 2\nmin_allocations = 0\nmax_allocations = 1\n\nenv_vars = f\"export OMP_NUM_THREADS={cores_per_job},1\"  # (1)!\n\nconfig = Config(\n    dependency_resolver=DEEP_DEPENDENCY_RESOLVER,  # (2)!\n    strategy=\"htex_auto_scale\",  # (3)!\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_parsl\",  # (4)!\n            max_workers_per_node=cores_per_node,  # (5)!\n            cores_per_worker=cores_per_job,  # (6)!\n            provider=SlurmProvider(\n                account=account,\n                qos=\"debug\",\n                constraint=\"cpu\",\n                worker_init=f\"source ~/.bashrc &amp;&amp; conda activate cms &amp;&amp; {env_vars}\",  # (7)!\n                walltime=\"00:10:00\",  # (8)!\n                nodes_per_block=nodes_per_allocation,  # (9)!\n                init_blocks=0,  # (10)!\n                min_blocks=min_allocations,  # (11)!\n                max_blocks=max_allocations,  # (12)!\n                launcher=SrunLauncher(),  # (13)!\n                cmd_timeout=60,  # (14)!\n            ),\n        )\n    ],\n    initialize_logging=False,  # (15)!\n)\n\nparsl.load(config)\n</code></pre> <ol> <li> <p>Since we are running single-core jobs, we need to set the <code>OMP_NUM_THREADS</code> environment variable to \"1,1\" according to the TBLite documentation.</p> </li> <li> <p>This is an opt-in feature needed when using Parsl to ensure all features in quacc are supported.</p> </li> <li> <p>Unique to the <code>HighThroughputExecutor</code>, this <code>strategy</code> will automatically scale the number of active blocks (i.e. Slurm allocations) up or down based on the number of jobs remaining. We set <code>max_blocks=1</code> here so it can't scale up beyond 1 Slurm job, but it can scale down from 1 to 0 since <code>min_blocks=0</code>. By setting <code>init_blocks=0</code>, no Slurm allocation will be requested until jobs are launched.</p> </li> <li> <p>This is just an arbitrary label for file I/O.</p> </li> <li> <p>The maximum number of running jobs per node. If you are running a non-MPI job, this value will generally be the number of physical cores per node (this example). Perlmutter has 128 physical CPU cores, so we have set a value of 128 here.</p> </li> <li> <p>The number of cores per job. We are running single-core jobs in this example.</p> </li> <li> <p>Any commands to run before carrying out any of the Parsl jobs. This is useful for setting environment variables, activating a given Conda environment, and loading modules.</p> </li> <li> <p>The walltime for each block (i.e. Slurm allocation).</p> </li> <li> <p>The number of nodes that each block (i.e. Slurm allocation) should allocate.</p> </li> <li> <p>Sets the number of blocks (e.g. Slurm allocations) to provision during initialization of the workflow. We set this to a value of 0 so that there isn't a running Slurm job before any jobs have been submitted to Parsl.</p> </li> <li> <p>Sets the minimum number of blocks (e.g. Slurm allocations) to maintain during elastic resource management. We set this to 0 so that Slurm jobs aren't running when there are no remaining jobs.</p> </li> <li> <p>Sets the maximum number of active blocks (e.g. Slurm allocations) during elastic resource management. We set this to 1 here, but it can be increased to have multiple Slurm jobs running simultaneously. Raising <code>max_blocks</code> to a larger value will allow the \"htex_auto_scale\" strategy to upscale resources as needed.</p> </li> <li> <p>The type of Launcher to use. <code>SrunLauncher()</code> will distribute jobs across the cores and nodes of the Slurm allocation. It should not be used for <code>PythonApp</code>s that themselves call MPI, which should use <code>SimpleLauncher()</code> instead.</p> </li> <li> <p>The maximum time to wait (in seconds) for the job scheduler info to be retrieved/sent.</p> </li> <li> <p>This will tidy up the Parsl logging to match the same log level as in quacc (<code>INFO</code> by default).</p> </li> </ol> <p>Now we define the workflow, apply it to all molecules in the \"g2\" collection, and monitor the progress of our calculations.</p> <pre><code>from ase.collections import g2\nfrom concurrent.futures import as_completed\nfrom tqdm import tqdm\nfrom quacc.recipes.tblite.core import relax_job, freq_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms)\n    return freq_job(relax_output[\"atoms\"], energy=relax_output[\"results\"][\"energy\"])\n\n\nfutures = []\nfor name in g2.names:\n    atoms = g2[name]\n    future = workflow(atoms)  #  (1)!\n    futures.append(future)\n\n\nfor future in tqdm(as_completed(futures), total=len(futures)):\n    result = future.result()\n    print(\n        result[\"formula_pretty\"],\n        result[\"results\"][\"gibbs_energy\"],\n        result[\"dir_name\"],\n    )\n</code></pre> <ol> <li>This is when the <code>PythonApp</code>s will be dispatched.</li> </ol> Tips for Practical Deployment <p>For debugging purposes or when running only a small numbers of jobs, it is simple enough to run the Parsl process from an interactive Jupyter Notebook or IPython kernel on the remote machine. However, for practical deployment and to ensure jobs are continually submitted to the queue even when the SSH session is terminated, you can run the Parsl orchestration process on a login node and maintain its state via a program like <code>tmux</code> or <code>screen</code>.</p> <p>For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running jobs on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p> <p>Here, we will run single-core TBLite relaxation and frequency calculations for 20 molecules from the so-called \"g2\" collection of small, neutral molecules. Note that the full \"g2\" collection has 162 molecules, but running all of them in quick succession will risk surpassing the free-tier rate limit of Prefect Cloud.</p> <p>On the remote machine, first make sure to install the necessary dependencies:</p> <pre><code>pip install quacc[tblite]\n</code></pre> <p>From an interactive resource like a Jupyter Notebook or IPython kernel on the login node of the remote machine, you will need to instantiate a Dask <code>SLURMCluster</code> that will request one Slurm allocation for one node, with a <code>@job</code> running on each core of the allocation:</p> <pre><code>from dask.distributed import Client\nfrom dask_jobqueue import SLURMCluster\n\naccount = \"MyAccountName\"\n\nslurm_jobs = 1\ncores_per_node = 112\n\nenv_vars = \"export OMP_NUM_THREADS=1,1\"  # (1)!\n\ncluster_kwargs = {\n    \"cores\": cores_per_node,  # (2)!\n    \"memory\": \"64 GB\",\n    \"shebang\": \"#!/bin/bash\",\n    \"account\": account,\n    \"walltime\": \"00:10:00\",\n    \"job_mem\": \"0\",\n    \"job_script_prologue\": [\n        \"source ~/.bashrc\",\n        env_vars,\n    ],\n    \"job_directives_skip\": [\"-n\", \"--cpus-per-task\"],  # (3)!\n    \"job_extra_directives\": [\"-q debug\", \"-C cpu\"],  # (4)!\n}\ncluster = SLURMCluster(**cluster_kwargs)\nprint(cluster.job_script())\ncluster.scale(jobs=slurm_jobs)\nclient = Client(cluster)\n</code></pre> <ol> <li> <p>Since we are running single-core jobs, we need to set the <code>OMP_NUM_THREADS</code> environment variable to \"1,1\" according to the TBLite documentation.</p> </li> <li> <p>It is also worthwhile to play around with the <code>processes</code> argument, which defaults to sqrt(cores).</p> </li> <li> <p>We have skipped the <code>-n</code> and <code>--cpus-per-task</code> Slurm directives because we will be using the full node here.</p> </li> <li> <p>We have set the queue to submit to and the constraint to use.</p> </li> </ol> <p>Now we define our workflow to dispatch, attaching it to the premade Dask cluster:</p> <pre><code>from prefect_dask import DaskTaskRunner\nfrom quacc import flow\nfrom quacc.recipes.tblite.core import freq_job, relax_job\n\n\n@flow(task_runner=DaskTaskRunner(address=client.scheduler.address))\ndef workflow(atoms_objects):\n    futures = []\n    for atoms in atoms_objects:\n        relax_output = relax_job(atoms)\n        freq_output = freq_job(\n            relax_output[\"atoms\"], energy=relax_output[\"results\"][\"energy\"]\n        )\n        futures.append(freq_output)\n\n    return futures\n</code></pre> <p>Finally, we dispatch the workflow and fetch the results:</p> <pre><code>from ase.collections import g2\n\natoms_objects = [g2[name] for name in g2.names[:20]]\nresults = workflow(atoms_objects)\n</code></pre> <p>One-Time Dask Clusters</p> <p>If preferred, it is also possible to instantiate a one-time, temporary Dask cluster via the <code>DaskTaskRunner</code> directly rather than connecting to an existing Dask cluster, as described in the Task Runner documentation. This is the more conventional job scheduling approach, where each workflow will run on its own Slurm allocation.</p> Jobflow RemoteFireworks <p>From the login node of the remote machine, run the following:</p> <pre><code>from ase.build import bulk\nfrom jobflow import Flow\nfrom jobflow_remote import submit_flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\natoms_list = [bulk(\"Si\"), bulk(\"Al\")]\nfor atoms in atoms_list:\n    job1 = relax_job(atoms, relax_cell=True)\n    job2 = static_job(job1.output[\"atoms\"])\n    flow = Flow([job1, job2])\n\n    submit_flow(flow, worker=\"basic_python\")\n</code></pre> <p>From the login node of the remote machine, run the following:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\nlpad = LaunchPad.auto_load()\n\natoms_list = [bulk(\"Si\"), bulk(\"Al\")]\nfor atoms in atoms_list:\n    job1 = relax_job(atoms, relax_cell=True)\n    job2 = static_job(job1.output[\"atoms\"])\n    flow = Flow([job1, job2])\n\n    wf = flow_to_workflow(flow)\n    lpad.add_wf(wf)\n</code></pre> <p>Dispatching Calculations</p> <p>With a workflow added to your launch pad, on the login node of the desired machine of choice, you can \"launch fireworks\" (i.e. submit jobs to the queue) via several ways:</p> <ul> <li><code>qlaunch\u00a0rapidfire\u00a0--nlaunches\u00a0&lt;N&gt;</code>\u00a0to submit  jobs to the job scheduler. <li><code>qlaunch rapidfire -m &lt;N&gt;</code> to submit enough jobs such that you only have a maximum of  total jobs in the queue. <li><code>qlaunch rapidfire -m &lt;N&gt; --nlaunches infinite</code> to have this this run as a light-weight background process that continually ensures you have a maximum of  total jobs in the queue. <p>To modify the order in which jobs are run, a priority can be set via\u00a0<code>lpad set_priority &lt;priority&gt; -i &lt;FWID&gt;</code>\u00a0where\u00a0<code>&lt;priority&gt;</code>\u00a0is a number.</p> <p>By default, <code>qlaunch</code> will launch Slurm jobs that each poll for a single FireWork to run. This means that more Slurm jobs may be submitted than there are jobs to run. To modify the behavior of <code>qlaunch</code> to only submit a Slurm job for each \"READY\" FireWork in the launchpad, use the <code>-r</code> (\"reserved\") flag.</p> <p>Monitoring the Launchpad</p> <p>The easiest way to monitor the state of your launched FireWorks and workflows is through the GUI, which can be viewed with <code>lpad webgui</code>. If you are using a NERSC machine, follow the instructions in the NERSC documentation for accessing the GUI.</p> <p>To get the status of running fireworks from the command line, you can run <code>lpad get_fws -s RUNNING</code>. Other statuses can also be provided as well as individual FireWorks IDs.</p> <p>To rerun a specific FireWork, one can use the <code>rerun_fws</code> command like so: <code>lpad rerun_fws -i &lt;FWID&gt;</code> where <code>&lt;FWID&gt;</code> is the FireWork ID. Similarly, one can rerun all fizzled jobs via <code>lpad rerun_fws -s FIZZLED</code>. More complicated Mongo-style queries can also be carried out. Cancelling a workflow can be done with <code>lpad delete_wflows -i &lt;FWID&gt;</code>. Refer to the <code>lpad -h</code> help menu for more details.</p> <p>Setting Where Jobs are Dispatched</p> <p>The <code>my_qadapter.yaml</code> file you made in the installation instructions specifies how FireWorks will submit jobs added to your launch pad. Additional details can be found in the Jobflow Documentation for how to dynamically set where and how Jobflow <code>Job</code> and <code>Flow</code> objects can be dispatched.</p> Continuous Job Submission <p>To ensure that jobs are continually submitted to the queue, you can use <code>tmux</code> to preserve the job submission process even when the SSH session is terminated. For example, running <code>tmux new -s launcher</code> will create a new <code>tmux</code> session named <code>launcher</code>. To exit the <code>tmux</code> session while still preserving any running jobs on the login node, press <code>ctrl+b</code> followed by <code>d</code>. To re-enter the tmux session, run <code>tmux attach -t launcher</code>. Additional <code>tmux</code> commands can be found on the tmux cheatsheet.</p>"},{"location":"user/wflow_engine/executors.html#concurrent-mpi-jobs","title":"Concurrent MPI Jobs","text":"<p>Here we will run a sample VASP recipe that will highlight the use of a more complicated MPI-based configuration. This example can only be run if you are a licensed VASP user, but the same fundamental principles apply to many other DFT codes with recipes in quacc.</p> <p>Once you have ensured that you can run VASP with quacc by following the Calculator Setup guide, follow the steps below.</p> DaskParslPrefectJobflow <pre><code>from dask.distributed import Client\nfrom dask_jobqueue import SLURMCluster\n\naccount = \"MyAccountName\"\n\nslurm_jobs = 2\nnodes_per_calc = 1\ncores_per_node = 128\n\nvasp_parallel_cmd = (\n    f\"srun -N {nodes_per_calc} --ntasks-per-node={cores_per_node} --cpu_bind=cores\"\n)\n\ncluster = SLURMCluster(\n    cores=1,  # (1)!\n    memory=\"64 GB\",\n    shebang=\"#!/bin/bash\",\n    account=account,\n    walltime=\"00:10:00\",\n    job_mem=\"0\",\n    job_script_prologue=[\n        \"source ~/.bashrc\",\n        \"module load vasp/6.4.1-cpu\",\n        f\"export QUACC_VASP_PARALLEL_CMD='{vasp_parallel_cmd}'\",\n    ],\n    job_directives_skip=[\"-n\", \"--cpus-per-task\"],\n    job_extra_directives=[f\"-N {nodes_per_calc}\", \"-q debug\", \"-C cpu\"],\n)\nprint(cluster.job_script())\ncluster.scale(jobs=slurm_jobs)\nclient = Client(cluster)\n</code></pre> <ol> <li>Since we only want to run one VASP job per allocation, we set this to 1. VASP will still use multiple cores via the <code>srun</code> command. The same could be achieved by setting <code>processes=1</code>.</li> </ol> <p>Now we launch the VASP jobs:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms, kpts=[3, 3, 3])\n    return static_job(relax_output[\"atoms\"], kpts=[3, 3, 3])\n\n\nfuture1 = client.compute(workflow(bulk(\"C\")))\nfuture2 = client.compute(workflow(bulk(\"Cu\")))\nresult = client.gather([future1, future2])\nprint(result)\n</code></pre> <p>Limitations</p> <p>Unfortunately, <code>dask-jobqueue</code> is somewhat limited in terms of its flexibility. Most notably, there is no mechanism to distribute <code>@job</code>s over multiple nodes on a single Slurm allocation. Users interested in such functionality should consider using other tools in the Dask suite or other workflow engines (e.g. Parsl).</p> <p>Now let's consider a similar configuration but for jobs where the underlying executable is run via MPI, as is typically the case for most quantum chemistry codes that distribute work over multiple cores and/or nodes. The setup here is a bit different. In this example, we are requesting a single Slurm allocation with 2 nodes (containing 128 physical CPU cores per node), and each compute job is running on 1 node of that allocation.</p> <p>From an interactive resource like a Jupyter Notebook or IPython kernel from the login node on the remote machine:</p> <pre><code>import parsl\nfrom parsl.config import Config\nfrom parsl.dataflow.dependency_resolvers import DEEP_DEPENDENCY_RESOLVER\nfrom parsl.executors import HighThroughputExecutor\nfrom parsl.launchers import SimpleLauncher\nfrom parsl.providers import SlurmProvider\n\naccount = \"MyAccountName\"\n\nnodes_per_job = 1\ncores_per_node = 128\nnodes_per_allocation = 2\nvasp_parallel_cmd = (\n    f\"srun -N {nodes_per_job} --ntasks-per-node={cores_per_node} --cpu_bind=cores\"\n)\n\nconfig = Config(\n    dependency_resolver=DEEP_DEPENDENCY_RESOLVER,\n    strategy=\"htex_auto_scale\",\n    executors=[\n        HighThroughputExecutor(\n            label=\"quacc_mpi_parsl\",\n            max_workers_per_node=nodes_per_allocation // nodes_per_job,  # (1)!\n            cores_per_worker=1e-6,  # (2)!\n            provider=SlurmProvider(\n                account=account,\n                qos=\"debug\",\n                constraint=\"cpu\",\n                worker_init=f\"source ~/.bashrc &amp;&amp; conda activate cms &amp;&amp; module load vasp/6.4.1-cpu &amp;&amp; export QUACC_VASP_PARALLEL_CMD='{vasp_parallel_cmd}'\",\n                walltime=\"00:10:00\",\n                nodes_per_block=nodes_per_allocation,\n                launcher=SimpleLauncher(),  # (3)!\n                cmd_timeout=60,\n            ),\n        )\n    ],\n    initialize_logging=False,\n)\n\nparsl.load(config)\n</code></pre> <ol> <li> <p>Unlike the prior example, here <code>max_workers_per_node</code> is defining the maximum number of concurrent MPI jobs to run per allocation.</p> </li> <li> <p>This is recommended in the Parsl manual for jobs that spawn MPI processes.</p> </li> <li> <p>The <code>SimpleLauncher</code> should be used in place of the <code>SrunLauncher</code> for <code>PythonApp</code>s that themselves call MPI.</p> </li> </ol> <p>Now we launch the VASP jobs:</p> <pre><code>from ase.build import bulk\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\n\ndef workflow(atoms):\n    relax_output = relax_job(atoms, kpts=[3, 3, 3])\n    return static_job(relax_output[\"atoms\"], kpts=[3, 3, 3])\n\n\nfuture1 = workflow(bulk(\"C\"))\nfuture2 = workflow(bulk(\"Cu\"))\nprint(future1.result(), future2.result())\n</code></pre> <pre><code>from dask.distributed import Client\nfrom dask_jobqueue import SLURMCluster\n\naccount = \"MyAccountName\"\n\nslurm_jobs = 2\nnodes_per_calc = 1\ncores_per_node = 112\n\nvasp_parallel_cmd = (\n    f\"srun -N {nodes_per_calc} --ntasks-per-node={cores_per_node} --cpu_bind=cores\"\n)\n\ncluster_kwargs = {\n    \"cores\": 1,  # (1)!\n    \"memory\": \"64 GB\",\n    \"shebang\": \"#!/bin/bash\",\n    \"account\": account,\n    \"walltime\": \"00:10:00\",\n    \"job_mem\": \"0\",\n    \"job_script_prologue\": [\n        \"source ~/.bashrc\",\n        \"module load vasp/6.4.1-cpu\",\n        f\"export QUACC_VASP_PARALLEL_CMD='{vasp_parallel_cmd}'\",\n    ],\n    \"job_directives_skip\": [\"-n\", \"--cpus-per-task\"],\n    \"job_extra_directives\": [f\"-N {nodes_per_calc}\", \"-q debug\", \"-C cpu\"],\n}\ncluster = SLURMCluster(**cluster_kwargs)\nprint(cluster.job_script())\ncluster.scale(jobs=slurm_jobs)\nclient = Client(cluster)\n</code></pre> <ol> <li>Since we only want to run one VASP job per allocation, we set this to 1. VASP will still use multiple cores via the <code>srun</code> command. The same could be achieved by setting <code>processes=1</code>.</li> </ol> <p>Now we define our workflow to dispatch, attaching it to the premade Dask cluster:</p> <pre><code>from prefect_dask import DaskTaskRunner\nfrom quacc import flow\n\n\n@flow(task_runner=DaskTaskRunner(address=client.scheduler.address))\ndef workflow(list_of_atoms):\n    from quacc.recipes.vasp.core import relax_job, static_job\n\n    futures = []\n    for atoms in list_of_atoms:\n        relax_output = relax_job(atoms, kpts=[3, 3, 3])\n        static_output = static_job(relax_output[\"atoms\"], kpts=[3, 3, 3])\n        futures.append(static_output)\n\n    return futures\n</code></pre> <p>Finally, we dispatch the workflow and fetch the results:</p> <pre><code>from ase.build import bulk\n\nlist_of_atoms = [bulk(\"Cu\"), bulk(\"C\")]\nresults = workflow(list_of_atoms)\n</code></pre> Jobflow RemoteFireworks <p>From the login node of the remote machine, run the following:</p> <pre><code>from ase.build import bulk\nfrom jobflow import Flow\nfrom jobflow_remote import submit_flow\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\natoms_list = [bulk(\"Si\"), bulk(\"Al\")]\nfor atoms in atoms_list:\n    atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n    job1 = relax_job(atoms, relax_cell=True)\n    job2 = static_job(job1.output[\"atoms\"])\n    flow = Flow([job1, job2])\n\n    submit_flow(flow, worker=\"basic_vasp\")\n</code></pre> <p>Then monitor the progress with <code>jf job list</code>.</p> <p>You will need to update your <code>my_qadapter.yaml</code> file that you made when setting up FireWorks. Specifically, ensure that the following parameters are set:</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w &lt;/path/to/fw_config/my_fworker.yaml&gt; singleshot\nnodes: 1\nwalltime: 00:30:00\naccount: MySlurmAccountName\njob_name: quacc_firework\nqos: debug\nconstraint: gpu\nsignal: SIGINT@60\npre_rocket: |\n            conda activate cms\n            module load vasp/6.5.1_gpu\n            export OMP_NUM_THREADS=8\n            export OMP_PLACES=threads\n            export OMP_PROC_BIND=spread\n            export QUACC_VASP_PARALLEL_CMD=\"srun -N 1 -n 4 -c 32 --cpu_bind=cores -G 4 --gpu-bind=none\"\n            export QUACC_WORKFLOW_ENGINE=jobflow\npost_rocket: null\n</code></pre> <p>From the login node of the remote machine, run the following:</p> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom fireworks import LaunchPad\nfrom jobflow.managers.fireworks import flow_to_workflow\nfrom quacc.recipes.vasp.core import relax_job, static_job\n\nlpad = LaunchPad.auto_load()\n\natoms_list = [bulk(\"Si\"), bulk(\"Al\")]\nfor atoms in atoms_list:\n    atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n    job1 = relax_job(atoms, relax_cell=True)\n    job2 = static_job(job1.output[\"atoms\"])\n    flow = Flow([job1, job2])\n\n    wf = flow_to_workflow(flow)\n    lpad.add_wf(wf)\n</code></pre> <p>Then run the following on the remote machine:</p> <pre><code>qlaunch rapidfire -m 1\n</code></pre> Job Packing <p>FireWorks allows you to do something called \"job packing\" (also known as a pilot job model in Parsl or parallel batch mode in Jobflow-Remote) where you can request a relatively large allocation and run many concurrent jobs on that allocation. If you wanted to have each Slurm allocation request 5 nodes and have each VASP job run on one of those four nodes, you can do that as follows:</p> my_qadapter.yaml<pre><code>_fw_name: CommonAdapter\n_fw_q_type: SLURM\nrocket_launch: rlaunch -w &lt;/path/to/fw_config/my_fworker.yaml&gt; multi 5 --nlaunches 0\nnodes: 5\nwalltime: 00:30:00\naccount: MySlurmAccountName\njob_name: quacc_firework\nqos: debug\nconstraint: gpu\nsignal: SIGINT@60\npre_rocket: |\n            conda activate cms\n            module load vasp/6.5.1_gpu\n            export OMP_NUM_THREADS=8\n            export OMP_PLACES=threads\n            export OMP_PROC_BIND=spread\n            export QUACC_VASP_PARALLEL_CMD=\"srun -N 1 -n 4 -c 32 --cpu_bind=cores -G 4 --gpu-bind=none\"\n            export QUACC_WORKFLOW_ENGINE=jobflow\npost_rocket: null\n</code></pre> <p>Then you can do <code>rlaunch multi 5</code> to launch 5 jobs across 5 nodes for 1 job/node. Maybe. Please test and report back.</p>"},{"location":"user/wflow_engine/wflow_engines1.html","title":"Pre-Defined Recipes","text":"<p>Here, we will show how to use quacc with one of a variety of workflow engines to construct, dispatch, and monitor your calculations. In quacc, there are two types of recipes:</p> <ol> <li>Individual compute jobs with the suffix <code>_job</code> that have been pre-defined with a <code>@job</code> decorator.</li> <li>Multi-step workflows with the suffix <code>_flow</code> that have been pre-defined with a <code>@flow</code> decorator.</li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-job","title":"Running a Pre-Defined Job","text":"<p>We will now try running a job where we relax a bulk Cu structure using EMT, which is pre-defined in quacc as quacc.recipes.emt.core.relax_job.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C[Output];</code></pre> DaskParslPrefectRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Dask cluster:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE dask\n</code></pre> python<pre><code>from dask.distributed import Client\n\nclient = Client()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Call the PythonApp\ndelayed = relax_job(atoms)  # (1)!\n\n# Print result\nresult = client.compute(delayed).result()  #  (2)!\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here. We also did not need to use a <code>@flow</code> decorator because Dask does not have an analogous decorator. At this point, we have a <code>Delayed</code> object.</p> </li> <li> <p>Calling <code>client.compute(delayed)</code> dispatches the compute job to the active Dask cluster and returns a <code>Future</code>. The use of <code>.result()</code> serves to block any further calculations from running and resolves the <code>Future</code>. You could also achieve the same result by doing <code>delayed.compute()</code>, which will dispatch and resolve the <code>Future</code> as one action. This is identical to <code>result = dask.compute(delayed)[0]</code>, where the <code>[0]</code> indexing is needed because <code>dask.compute</code> always returns a tuple.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Call the PythonApp\nfuture = relax_job(atoms)  # (1)!\n\n# Print result\nprint(future.result())  # (2)!\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here. We also did not need to use a <code>@flow</code> decorator because Parsl does not have an analogous decorator.</p> </li> <li> <p>The use of <code>.result()</code> serves to block any further calculations from running until it is resolved. Calling <code>.result()</code> also returns the function output as opposed to the <code>AppFuture</code> object.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE prefect\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    return relax_job(atoms)  # (1)!\n\n\n# Dispatch the workflow\nresult = workflow(atoms)  # (2)!\n\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>The workflow has been dispatched to the Prefect server at this point and the result returned.</p> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc.recipes.emt.core import relax_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresult = scheduler.run(relax_job(atoms))  # (1)!\nprint(result)\n</code></pre> <ol> <li>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable. It also helps to have <code>RESULTS_DIR</code> set to the default value so Jobflow can handle the directory management.</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\nquacc unset RESULTS_DIR\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define the Job\njob = relax_job(atoms)  # (1)!\n\n# Run the job locally\nresponses = jf.run_locally(job, ensure_success=True, create_folders=True)  # (2)!\n\n# Get the result\nresult = responses[job.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>The <code>relax_job</code> function was pre-defined in quacc with a <code>@job</code> decorator, which is why we did not need to include it here.</p> </li> <li> <p>We chose to run the job locally, but other workflow managers supported by Jobflow can be imported and used.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines1.html#running-a-pre-defined-workflow","title":"Running a Pre-Defined Workflow","text":"<p>We will now try running a pre-defined workflow where we carve all possible slabs from a given structure, run a new relaxation calculation on each slab, and then a static calculation for each relaxed slab. This is implemented in quacc.recipes.emt.slabs.bulk_to_slabs_flow.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Make Slabs)\n  B --&gt; C(Slab Relax) --&gt; G(Slab Static) --&gt; K[Output]\n  B --&gt; D(Slab Relax) --&gt; H(Slab Static) --&gt; K[Output]\n  B --&gt; E(Slab Relax) --&gt; I(Slab Static) --&gt; K[Output]\n  B --&gt; F(Slab Relax) --&gt; J(Slab Static) --&gt; K[Output];</code></pre> DaskParslPrefectRedunJobflow <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\ndelayed = bulk_to_slabs_flow(atoms)\n\n# Print the results\nresult = client.compute(delayed).result()\nprint(result)\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nfuture = bulk_to_slabs_flow(atoms)\n\n# Print the results\nprint(future.result())\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow and get results\nresults = bulk_to_slabs_flow(atoms)\n\n# Print the results\nprint(results)\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Define the workflow\nresult = scheduler.run(bulk_to_slabs_flow(atoms))  # (1)!\n\n# Print the results\nprint(result)\n</code></pre> <ol> <li>We didn't need to wrap <code>bulk_to_slabs_flow</code> with a decorator because it is already pre-decorated with a <code>@flow</code> decorator.</li> </ol> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Create the workflow with arguments\nworkflow = bulk_to_slabs_flow(atoms)\n\n# Dispatch the workflow and get results\nresults = jf.run_locally(workflow)\n\n# Print the results\nprint(results)\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines2.html","title":"Combining Recipes","text":"<p>Here, we will show how to use combine quacc jobs and workflows into your own custom workflows that can be run with your chosen workflow engine.</p>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-serial-workflow","title":"Running a User-Constructed Serial Workflow","text":"<p>We will now try running a simple workflow where we relax a bulk Cu structure using EMT and take the output of that calculation as the input to a follow-up static calculation with EMT.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Static) --&gt; D[Output];</code></pre> DaskParslPrefectRedunJobflow <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Dask cluster:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE dask\n</code></pre> python<pre><code>from dask.distributed import Client\n\nclient = Client()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\ndef workflow(atoms):\n    # Define Job 1\n    delayed1 = relax_job(atoms)\n\n    # Define Job 2, which takes the output of Job 1 as input\n    delayed2 = static_job(delayed1[\"atoms\"])\n\n    return delayed2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\ndelayed = workflow(atoms)\n\n# Fetch the result\nresult = client.compute(delayed).result()\nprint(result)\n</code></pre> <p>Modifying the Decorator of a Pre-Made Job</p> <p>If you want to modify the decorator of a pre-made job for any reason, you can use the quacc.wflow_tools.customizers.redecorate function:</p> <pre><code>from quacc import redecorate\n\nrelax_job_ = redecorate(relax_job, job(name=\"my_custom_name\"))  # (1)!\n</code></pre> <ol> <li> <p>This is the same as simply re-decorating it directly and using this new function instead:</p> <pre><code>from quacc import job\n\n\n@job(name=\"my_custom_name\")\ndef relax_job_(*args, **kwargs):\n    return relax_job(*args, **kwargs)\n</code></pre> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable and load the default Parsl configuration:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE parsl\n</code></pre> python<pre><code>import parsl\n\nparsl.load()\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\ndef workflow(atoms):\n    # Define Job 1\n    future1 = relax_job(atoms)\n\n    # Define Job 2, which takes the output of Job 1 as input\n    future2 = static_job(future1[\"atoms\"])  # (1)!\n\n    return future2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the result\nresult = future.result()\nprint(result)\n</code></pre> <ol> <li>Parsl <code>PythonApp</code> objects will implicitly know to call <code>.result()</code> on any <code>AppFuture</code> it receives, and it is good to rely on this fact to avoid unnecessary blocking.</li> </ol> <p>Modifying the Decorator of a Pre-Made Job</p> <p>If you want to modify the decorator of a pre-made job, such as to modify the allowed executors of a given function, you can use the quacc.wflow_tools.customizers.redecorate function:</p> <pre><code>from quacc import redecorate\n\nrelax_job_ = redecorate(relax_job, job(executors=[\"all\"]))  # (1)!\n</code></pre> <ol> <li> <p>This is the same as simply re-decorating it directly and using this new function instead:</p> <pre><code>from quacc import job\n\n\n@job(executors=[\"all\"])\ndef relax_job_(*args, **kwargs):\n    return relax_job(*args, **kwargs)\n</code></pre> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> terminal<pre><code>quacc set WORKFLOW_ENGINE prefect\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    # Call Task 1\n    future1 = relax_job(atoms)\n\n    # Call Task 2, which takes the output of Task 1 as input\n    return static_job(future1[\"atoms\"])  # (1)!\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Run the workflow with Prefect tracking\nresult = workflow(atoms)\nprint(result)\n</code></pre> <ol> <li>Prefect <code>Task</code> objects will implicitly know to call <code>.result()</code> on any <code>PrefectFuture</code> it receives, and it is good to rely on this fact to avoid unnecessary blocking.</li> </ol> <p>Modifying the Decorator of a Pre-Made Job</p> <p>If you want to modify the decorator of a pre-made job, such as to modify the number of retries, you can use the quacc.wflow_tools.customizers.redecorate function:</p> <pre><code>from quacc import redecorate\n\nrelax_job_ = redecorate(relax_job, job(retries=2))  # (1)!\n</code></pre> <ol> <li> <p>This is the same as simply re-decorating it directly and using this new function instead:</p> <pre><code>from quacc import job\n\n\n@job(retries=2)\ndef relax_job_(*args, **kwargs):\n    return relax_job(*args, **kwargs)\n</code></pre> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable:</p> <pre><code>quacc set WORKFLOW_ENGINE redun\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n\n# Define the workflow\n@flow  # (1)!\ndef workflow(atoms):\n    # Define Job 1\n    result1 = relax_job(atoms)\n\n    # Define Job 2, which takes the output of Job 1 as input\n    result2 = static_job(result1[\"atoms\"])\n\n    return result2\n\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresult = scheduler.run(workflow(atoms))\nprint(result)\n</code></pre> <ol> <li>The <code>@flow</code> decorator defines the workflow that will be executed. It is the same as the <code>@task</code> decorator in Redun.</li> </ol> <p>Modifying the Decorator of a Pre-Made Job</p> <p>If you want to modify the decorator of a pre-made job for any reason, you can use the quacc.wflow_tools.customizers.redecorate function:</p> <pre><code>from quacc import redecorate\n\nrelax_job_ = redecorate(relax_job, job(name=\"my_custom_name\"))  # (1)!\n</code></pre> <ol> <li> <p>This is the same as simply re-decorating it directly and using this new function instead:</p> <pre><code>from quacc import job\n\n\n@job(name=\"my_custom_name\")\ndef relax_job_(*args, **kwargs):\n    return relax_job(*args, **kwargs)\n</code></pre> </li> </ol> <p>Important</p> <p>If you haven't done so yet, make sure you update the quacc <code>WORKFLOW_ENGINE</code> configuration variable. It also helps to have <code>RESULTS_DIR</code> set to the default value so Jobflow can handle the directory management.</p> <pre><code>quacc set WORKFLOW_ENGINE jobflow\nquacc unset RESULTS_DIR\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job, static_job\n\n# Make an Atoms object of a bulk Cu structure\natoms = bulk(\"Cu\")\n\n# Define Job 1\njob1 = relax_job(atoms)\n\n# Define Job 2, which takes the output of Job 1 as input\njob2 = static_job(job1.output[\"atoms\"])  # (1)!\n\n# Define the workflow\nworkflow = jf.Flow([job1, job2])  # (2)!\n\n# Run the workflow locally\nresponses = jf.run_locally(workflow, ensure_success=True, create_folders=True)\n\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre> <ol> <li> <p>In Jobflow, each <code>Job</code> is only a reference and so the <code>.output</code> must be explicitly passed between jobs.</p> </li> <li> <p>We must stitch the individual <code>Job</code> objects together into a <code>jf.Flow</code>, which can be easily achieved by passing them as a list to the <code>jf.Flow()</code> constructor.</p> </li> </ol>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-parallel-workflow","title":"Running a User-Constructed Parallel Workflow","text":"<p>Now we will define a workflow where we will carry out two EMT structure relaxations, but the two jobs are not dependent on one another. In this example, the workflow manager will know that it can run the two jobs separately, and even if Job 1 were to fail, Job 2 would still progress.</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; D[Output]\n  A[Input] --&gt; C(Relax) --&gt; D[Output];</code></pre> DaskParslPrefectRedunJobflow <pre><code>from ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return [result1, result2]\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\ndelayed = workflow(atoms1, atoms2)\n\n# Fetch the results\nresults = client.gather(client.compute(delayed))\nprint(results)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\nfutures = workflow(atoms1, atoms2)\n\n# Fetch the results\nresult1 = futures[\"result1\"].result()\nresult2 = futures[\"result2\"].result()\nprint(result1, result2)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow\nresults = workflow(atoms1, atoms2)\n\n# Fetch the results\nresult1 = results[\"result1\"]\nresult2 = results[\"result2\"]\nprint(result1, result2)\n</code></pre> <pre><code>from ase.build import bulk, molecule\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\n\n# Instantiate the scheduler\nscheduler = Scheduler()\n\n\n# Define workflow\n@flow\ndef workflow(atoms1, atoms2):\n    # Define two independent relaxation jobs\n    result1 = relax_job(atoms1)\n    result2 = relax_job(atoms2)\n\n    return {\"result1\": result1, \"result2\": result2}\n\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Dispatch the workflow\nresult = scheduler.run(workflow(atoms1, atoms2))\nprint(result)\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk, molecule\nfrom quacc.recipes.emt.core import relax_job\n\n# Define two Atoms objects\natoms1 = bulk(\"Cu\")\natoms2 = molecule(\"N2\")\n\n# Define two independent relaxation jobs\njob1 = relax_job(atoms1)\njob2 = relax_job(atoms2)\n\n# Define the workflow\nworkflow = jf.Flow([job1, job2])\n\n# Run the workflow locally\nresponses = jf.run_locally(workflow, ensure_success=True, create_folders=True)\n\n# Get the result\nresult = responses[job2.uuid][1].output\nprint(result)\n</code></pre>"},{"location":"user/wflow_engine/wflow_engines2.html#running-a-user-constructed-dynamic-workflow","title":"Running a User-Constructed Dynamic Workflow","text":"<p>For this example, let's consider a toy scenario where we wish to relax a bulk Cu structure, carve all possible slabs, and then run a new relaxation calculation on each slab (with no static calculation at the end).</p> <pre><code>graph LR\n  A[Input] --&gt; B(Relax) --&gt; C(Make Slabs)\n  C(Make Slabs) --&gt; D(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; E(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; F(Slab Relax) --&gt; H[Output]\n  C(Make Slabs) --&gt; G(Slab Relax) --&gt; H[Output];</code></pre> DaskParslPrefectRedunJobflow <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\ndelayed = workflow(atoms)\n\n# Fetch the results\nresult = client.compute(delayed).result()\nprint(result)\n</code></pre> <p>Selectively Modifying Job Decorators in a Pre-Made Flow</p> <p>If you want to modify the decorators of select jobs in a pre-made workflow, such as to modify the allowed executors of a given function, you can use the <code>job_decorators</code> keyword argument:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"static_job\": job(name=\"my_custom_name\")})\n</code></pre> <p>As a shorthand, all of the decorators can be modified at once using the \"all\" key:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"all\": job(name=\"my_custom_name\")})\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nfuture = workflow(atoms)\n\n# Fetch the results\nresult = future.result()\nprint(result)\n</code></pre> <p>Selectively Modifying Job Decorators in a Pre-Made Flow</p> <p>If you want to modify the decorators of select jobs in a pre-made workflow, such as to modify the allowed executors of a given function, you can use the <code>job_decorators</code> keyword argument:</p> <pre><code>bulk_to_slabs_flow(\n    atoms, job_decorators={\"static_job\": job(executors=[\"MyFavoriteExecutor\"])}\n)\n</code></pre> <p>As a shorthand, all of the decorators can be modified at once using the \"all\" key:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"all\": job(executors=[\"MyFavoriteExecutor\"])})\n</code></pre> <pre><code>from ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Dispatch the workflow\nresults = workflow(atoms)\n\n# print the results\nprint(results)\n</code></pre> <p>Selectively Modifying Job Decorators in a Pre-Made Flow</p> <p>If you want to modify the decorators of select jobs in a pre-made workflow, such as to modify the number of retries, you can use the <code>job_decorators</code> keyword argument:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"static_job\": job(retries=2)})\n</code></pre> <p>As a shorthand, all of the decorators can be modified at once using the \"all\" key:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"all\": job(retries=2)})\n</code></pre> <pre><code>from ase.build import bulk\nfrom redun import Scheduler\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\nscheduler = Scheduler()\n\n\n# Define the workflow\n@flow\ndef workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Run the workflow\nresult = scheduler.run(workflow(atoms))\nprint(result)\n</code></pre> <p>Selectively Modifying Job Decorators in a Pre-Made Flow</p> <p>If you want to modify the decorators of select jobs in a pre-made workflow, such as to modify the allowed executors of a given function, you can use the <code>job_decorators</code> keyword argument:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"static_job\": job(name=\"my_custom_name\")})\n</code></pre> <p>As a shorthand, all of the decorators can be modified at once using the \"all\" key:</p> <pre><code>bulk_to_slabs_flow(atoms, job_decorators={\"all\": job(name=\"my_custom_name\")})\n</code></pre> <pre><code>import jobflow as jf\nfrom ase.build import bulk\nfrom quacc import flow\nfrom quacc.recipes.emt.core import relax_job\nfrom quacc.recipes.emt.slabs import bulk_to_slabs_flow\n\n\n# Define the workflow\n@flow\ndef relaxed_slabs_workflow(atoms):\n    relaxed_bulk = relax_job(atoms)\n    relaxed_slabs = bulk_to_slabs_flow(relaxed_bulk[\"atoms\"], run_static=False)\n\n    return relaxed_slabs\n\n\n# Define the Atoms object\natoms = bulk(\"Cu\")\n\n# Create the workflow with arguments\nworkflow = relaxed_slabs_workflow(atoms)\n\n# Dispatch the workflow and get results\nresults = jf.run_locally(workflow)\n\n# print the results\nprint(results)\n</code></pre>"}]}